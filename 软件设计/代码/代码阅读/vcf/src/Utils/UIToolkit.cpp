/**
*Copyright (c) 2000-2001, Jim Crafton
*All rights reserved.
*Redistribution and use in source and binary forms, with or without
*modification, are permitted provided that the following conditions
*are met:
*	Redistributions of source code must retain the above copyright
*	notice, this list of conditions and the following disclaimer.
*
*	Redistributions in binary form must reproduce the above copyright
*	notice, this list of conditions and the following disclaimer in 
*	the documentation and/or other materials provided with the distribution.
*
*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
*AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
*A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS
*OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
*EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
*PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
*PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
*LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
*SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*NB: This software will not save the world.
*/

/* Generated by Together */

#include "ApplicationKit.h"
#include "Panel.h"
#include "DefaultPropertyEditors.h"

//Peers

#ifdef WIN32	
	#include "Win32ToolKit.h"
#elif GTK_VCF
	#include  "GTKToolkit.h"
#elif MACOS_VCF
	//Mac toolkit goes here
#endif

#include "ImageControl.h"
#include "ComponentInfo.h"



using namespace VCF;


UIToolkit* UIToolkit::toolKitInstance = NULL;

//Locales VCF::Locales::localListing;


UIToolkit::UIToolkit()
{	
	Component::initComponentRegistrar();
}

UIToolkit::~UIToolkit()
{
	std::map<String,ComponentInfo*>::iterator it2 = m_componentInfoMap.begin();
	while( it2 != m_componentInfoMap.end() ) {
		ComponentInfo* info = it2->second;
		delete info;
		info = NULL;
		it2++;
	}
	m_componentInfoMap.clear();

	delete m_systemClipboard;

	Component::clearRegistedComponents();
}

void UIToolkit::init()
{	
	
	this->m_graphicsToolKit = GraphicsToolkit::getDefaultGraphicsToolkit();
	this->m_systemClipboard = new Clipboard();	
	/**
	*register basic property editors
	*/
	
	PropertyEditorManager::registerPropertyEditor( new IntegerPropertyEditor(), CLASS_INTEGER );
	PropertyEditorManager::registerPropertyEditor( new DoublePropertyEditor(), CLASS_DOUBLE );
	PropertyEditorManager::registerPropertyEditor( new BoolPropertyEditor(), CLASS_BOOL );
	PropertyEditorManager::registerPropertyEditor( new StringPropertyEditor(), CLASS_STRING );
	PropertyEditorManager::registerPropertyEditor( new EnumPropertyEditor(), CLASS_ENUM );
	PropertyEditorManager::registerPropertyEditor( new ColorPropertyEditor(), "VCF::Color" );
	PropertyEditorManager::registerPropertyEditor( new FontPropertyEditor(), "VCF::Font" );
	PropertyEditorManager::registerPropertyEditor( new DefaultMenuItemPropertyEditor(), "VCF::DefaultMenuItem" );
	PropertyEditorManager::registerPropertyEditor( new DefaultListModelPropertyEditor(), "VCF::DefaultListModel" );	
	PropertyEditorManager::registerPropertyEditor( new ImageFilenamePropertyEditor(), "VCF::ImageFilenameString" );	
	PropertyEditorManager::registerPropertyEditor( new ImagePropertyEditor(), "VCF::Image" );
	PropertyEditorManager::registerPropertyEditor( new ImagePropertyEditor(), "VCF::Win32Image" );

	/**
	*register the components in categorys
	*/

	Component::registerComponent( "VCF::TabbedPages", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::Panel", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::CommandButton", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::ListBoxControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::ListViewControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::TreeControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::TextControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::MultilineTextControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::Label", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::CheckBoxControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::MenuBar", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::PopupMenu", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::OpenGLControl", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::ImageControl", ADDITIONAL_CATEGORY );

	//Desktop::getDesktop()->init();
}

void UIToolkit::initToolKit()
{	
	if ( NULL == UIToolkit::toolKitInstance ) {
#ifdef WIN32
		UIToolkit::toolKitInstance = new Win32ToolKit();
#elif GTK_VCF
		UIToolkit::toolKitInstance = new GTKToolkit();
#endif

		//inialize the toolkit instance
		((UIToolkit*)UIToolkit::toolKitInstance)->init();
	}
}

void UIToolkit::closeToolkit()
{
	delete UIToolkit::toolKitInstance;
	UIToolkit::toolKitInstance = NULL;
}

UIToolkit* UIToolkit::getDefaultUIToolkit() throw (NoToolKitFoundException)
{
	if ( NULL == UIToolkit::toolKitInstance ){
		throw new NoToolKitFoundException();
	}
	return UIToolkit::toolKitInstance;
}

ControlPeer* UIToolkit::createControlPeer( Control* component, ComponentType componentType)
{
	return NULL;
}

ListviewPeer* UIToolkit::createListViewPeer( ListViewControl* component, ComponentType componentType)
{
	return NULL;
}

TreePeer* UIToolkit::createTreePeer( TreeControl* component, ComponentType componentType)
{
	return NULL;
}

ComboBoxPeer* UIToolkit::createComboBoxPeer( ComboBoxControl* component, ComponentType componentType)
{
	return NULL;
}

TextPeer* UIToolkit::createTextPeer( TextControl* component, const bool& isMultiLineControl, ComponentType componentType)
{
	return NULL;
}	

RichTextPeer* UIToolkit::createRTFPeer( ComponentType componentType)
{
	return NULL;
}

ScrollbarPeer* UIToolkit::createScrollbarPeer( ComponentType componentType)
{
	return NULL;
}

ButtonPeer* UIToolkit::createButtonPeer( CommandButton* component, ComponentType componentType)
{
	return NULL;
}
	
HeaderPeer* UIToolkit::createHeaderPeer( ComponentType componentType)
{
	return NULL;
}

TabbedPagesPeer* UIToolkit::createTabsheetsPeer( ComponentType componentType)
{
	return NULL;
}

DialogPeer* UIToolkit::createDialogPeer( Frame* owner, Dialog* component, ComponentType componentType)
{
	return NULL;
}

DialogPeer* UIToolkit::createDialogPeer()
{
	return NULL;
}

WindowPeer* UIToolkit::createWindowPeer( Control* component, ComponentType componentType)
{
	return NULL;
}

ClipboardPeer* UIToolkit::createClipboardPeer()
{
	return NULL;
}

DragDropPeer* UIToolkit::createDragDropPeer()
{
	return NULL;
}

DataObjectPeer* UIToolkit::createDataObjectPeer()
{
	return NULL;
}

Clipboard* UIToolkit::getSystemClipboard()
{
	return this->m_systemClipboard;
}

ApplicationPeer* UIToolkit::createApplicationPeer()
{
	return NULL;
}

DropTargetPeer* UIToolkit::createDropTargetPeer()
{
	return NULL;
}


ContextPeer* UIToolkit::createContextPeer( const long& contextID )
{
	if ( NULL == m_graphicsToolKit ){
		//throw exception
	}
	return this->m_graphicsToolKit->createContextPeer( contextID );
}

ContextPeer* UIToolkit::createContextPeer( Control* component )
{
	if ( NULL == m_graphicsToolKit ){
		//throw exception
	}
	return NULL;//this->m_graphicsToolKit->createContextPeer( component );
}

ContextPeer* UIToolkit::createContextPeer( const unsigned long& width, const unsigned long& height )
{
	if ( NULL == m_graphicsToolKit ){
		//throw exception
	}
	return this->m_graphicsToolKit->createContextPeer( width, height );
}

MenuItemPeer* UIToolkit::createMenuItemPeer( MenuItem* item )
{
	return NULL;
}

MenuBarPeer* UIToolkit::createMenuBarPeer( MenuBar* menuBar )
{
	return NULL;
}

CommonFileDialogPeer* UIToolkit::createCommonFileOpenDialogPeer( Control* owner )
{
	return NULL;
}

CommonFolderBrowseDialogPeer* UIToolkit::createCommonFolderBrowseDialogPeer( Control* owner )
{
	return NULL;
}

CommonFileDialogPeer* UIToolkit::createCommonFileSaveDialogPeer( Control* owner )
{
	return NULL;
}

CommonColorDialogPeer* UIToolkit::createCommonColorDialogPeer( Control* owner )
{
	return NULL;
}

CommonFontDialogPeer* UIToolkit::createCommonFontDialogPeer( Control* owner )
{
	return NULL;
}

PopupMenuPeer* UIToolkit::createPopupMenuPeer( PopupMenu* popupMenu )
{
	return NULL;
}

DesktopPeer* UIToolkit::createDesktopPeer( Desktop* desktop )
{
	return NULL;
}

void UIToolkit::registerComponentInfo( const String& componentUUID, ComponentInfo* info )
{
	if ( componentUUID != info->getComponentUUID() ) {
		throw RuntimeException( "Attempting to register a component's info with a mismatched UUID." );
	}
	m_componentInfoMap[ componentUUID ] = info;
}

ComponentInfo* UIToolkit::getComponentInfo( const String& componentUUID )
{
	ComponentInfo* result = NULL;
	std::map< String,ComponentInfo*>::iterator found = m_componentInfoMap.find( componentUUID );
	if ( found != m_componentInfoMap.end() ) {
		result = found->second;
	}
	return result;
}

ComponentInfo* UIToolkit::getComponentInfo( Class* componentClass )
{
	if ( NULL == componentClass ) {
		throw RuntimeException( "Can't get Component information from a NULL Class." );
	}
	return getComponentInfo( componentClass->getID() );
}

void UIToolkit::removeComponentInfo( ComponentInfo* info )
{
	std::map< String,ComponentInfo*>::iterator found = m_componentInfoMap.find( info->getComponentUUID() );
	if ( found != m_componentInfoMap.end() ) {
		m_componentInfoMap.erase( found );
	}
}

ScrollPeer* UIToolkit::createScrollPeer( Control* control )
{
	return NULL;
}

CursorPeer* UIToolkit::createCursorPeer( Cursor* cursor )
{
	return NULL;
}