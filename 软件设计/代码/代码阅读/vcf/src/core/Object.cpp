/**
*Copyright (c) 2000-2001, Jim Crafton
*All rights reserved.
*Redistribution and use in source and binary forms, with or without
*modification, are permitted provided that the following conditions
*are met:
*	Redistributions of source code must retain the above copyright
*	notice, this list of conditions and the following disclaimer.
*
*	Redistributions in binary form must reproduce the above copyright
*	notice, this list of conditions and the following disclaimer in 
*	the documentation and/or other materials provided with the distribution.
*
*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
*AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
*A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS
*OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
*EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
*PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
*PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
*LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
*SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*NB: This software will not save the world.
*/

/* Generated by Together */
#include "FoundationKit.h"
#include <algorithm>

using namespace std;
using namespace VCF;

#ifdef USE_VCF_NEW
std::list<void*> Object::allocatedObjects;
#endif

Object::Object()
{
	//initialized to zero 
	//so a release after creating this object
	//will automaitically free it
	m_refCount = 0;
	
}

Object::~Object()
{	
	
}

void Object::init()
{

}

void Object::destroy()
{

}

void Object::free()
{
	m_refCount = 0;

	destroy();

	delete this;
}

unsigned long Object::addRef(Object* owner)
{
	m_refCount ++;
	return m_refCount;
}

unsigned long Object::release(Object* owner)
{
	if ( m_refCount > 0 ) {
		m_refCount --;
	}
	
	if ( 0 == m_refCount )  {
		free();
	}

	return m_refCount;
}

Class* Object::getClass()
{
	ClassRegistry* registry = ClassRegistry::getClassRegistry();
	Class* result = (Class*) registry->getClass( this );
	if ( NULL != result ){
		result->setSource( this );
	}
	return result;
}

String Object::getClassName()
{
	String result = "";
	Class* clazz = this->getClass();
	if ( NULL != clazz ){
		result = clazz->getClassName();
	}
	else {
#ifdef VCF_RTTI
		result = StringUtils::getClassNameFromTypeInfo( typeid(*this) );
#endif
	}

	return result;
}

String Object::toString()
{
	String result = "";
	char info[256];
	sprintf( info, "%s @ %p", 
		     this->getClassName().c_str(), this );
	result += info;
	return result;
}

unsigned long Object::hash()
{
	return (unsigned long)this;
}


#ifdef USE_VCF_NEW

int totalCount = 0;

void * Object::operator new( size_t allocSize )
{
    totalCount++;
	void *newPtr = malloc( allocSize );
    if( newPtr != 0 ){
        memset( newPtr, 0, allocSize );
		allocatedObjects.push_back( newPtr );
	}
    return newPtr;
}

void Object::operator delete( void *memPtr )
{
	
	std::list<void*>::iterator it = std::find( allocatedObjects.begin(), allocatedObjects.end(), memPtr );
    if ( it != allocatedObjects.end() ){
		allocatedObjects.erase( it );
	}
	free( memPtr );
}

void Object::dump()
{
	std::list<void*>::iterator it = allocatedObjects.begin();
	StringUtils::trace( "Dumping remaining allocated Objects...\n" );
	StringUtils::trace( StringUtils::toString( totalCount ) + " objects allocated\n" );
	long i = 0;
	Object* obj = NULL;
	while ( it != allocatedObjects.end() ){
		obj = (Object*)(*it);
		try {
			StringUtils::trace( "object " + StringUtils::toString( i ) + "\n" );// + obj->toString() + "\n" );
		}
		catch (... ){
			StringUtils::trace( "unknown object...\n" );
		}
		i++;
		it++;
	}
	StringUtils::trace( "Finished dumping objects ! "  + StringUtils::toString( i ) + " objects still allocated\n" );
}

#endif 

