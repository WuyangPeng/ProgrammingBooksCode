/* Generated by Together */

#ifndef ENUMOBJECT_H
#define ENUMOBJECT_H

#pragma warning (disable : 4786) //vector warnings about string too long...

#include "COMObject.h"
#include <iterator>
#include "CantCreateObjectException.h"

namespace VCFCOM{

/**
*Template class to make it easy to create IEnumXXX objects
*/



template <class T> class EnumObject : public COMObject {
	public:
		EnumObject(){
			m_currentPos = 0;
		};
		
		EnumObject( const EnumObject& enumObj ){
			this->m_items = enumObj.m_items;
			m_currentPos = enumObj.m_currentPos;
			unsigned long skipped = m_currentPos;
			if ( skipped > 0 ) {
				m_itemIterator = m_items.begin();
				while (  (m_itemIterator != m_items.end()) && (skipped > 0) ){
					m_itemIterator++;
					skipped--;
				}
			}
		};


		virtual ~EnumObject(){};		
		
		/**
		*Use this function to add data to initialize the enum object
		*/
		virtual void add( T item ){
			m_items.push_back( item );	
		};

		void initList() throw ( VCF::CantCreateObjectException ){
			/*
			IMalloc *memAlloc = NULL;
			//retreive memory from COM
			if ( S_OK != ::CoGetMalloc(MEMCTX_TASK, &memAlloc) ){
				throw VCF::CantCreateObjectException( CANT_GET_INTERFACE_ERROR );
			}			
			*/
			//m_prgfe=(LPFORMATETC)pIMalloc->Alloc(cItems*sizeof(FORMATETC));
			this->m_itemIterator = this->m_items.begin();
		};

		/**
		*IEnumXXX members 
		*documentation from the Win32 SDK (MSDN October 1999)
		*/
		/**
		*Retrieves the next elementsRequested items in the enumeration sequence. 
		*If there are fewer than the requested number of elements left in the sequence, 
		*it retrieves the remaining elements. The number of elements actually retrieved 
		*is returned through elementsFetched (unless the caller passed in NULL for that parameter).
		*@param ULONG elementsRequested - number of elements to fetch
		*@param T *elementList - an array of elements of type <T>
		*@param ULONG *elementsFetched - the numbers of items in the elementList array
		*/
        STDMETHODIMP Next( ULONG elementsRequested, T *elementList, ULONG *elementsFetched ){
			HRESULT result = ResultFromScode(S_FALSE);
			unsigned long fetchCount = 0;
			if ( NULL == elementsFetched ){
				if ( 1L != elementsRequested ){
					result = ResultFromScode(E_POINTER);
				}
			}
			else {
				*elementsFetched = 0;
				if ( (NULL == elementList) || (m_itemIterator == m_items.end()) ){
					result = ResultFromScode(S_FALSE);
				}
				else {
					while ( (m_itemIterator != m_items.end()) && (elementsRequested > 0) ){						
						m_currentPos ++;
						*elementList = *m_itemIterator;
						elementList++;
						m_itemIterator++;

						fetchCount++;
						elementsRequested--;
					}
					*elementsFetched = fetchCount;
					result = NO_ERROR;
				}
			}

			return result;
		};

		/**
		*Skips over the next specified number of elements in the enumeration sequence.
		*@param ULONG elementsToSkip - the number of items to skip over
		*/
        STDMETHODIMP Skip( ULONG elementsToSkip ){
			HRESULT result = ResultFromScode(S_FALSE);
			if ( m_itemIterator != m_items.end() ){
				while ( (m_itemIterator != m_items.end()) && (elementsToSkip > 0) ){
					elementsToSkip--;
					m_itemIterator++;
					m_currentPos++;
				}
				result = NOERROR;
			}
			return result;
		};

		/**
		*Resets the enumeration sequence to the beginning.
		*/
        STDMETHODIMP Reset(void){
			this->m_itemIterator = this->m_items.begin();
			return NOERROR;
		};

		/**
		*Creates another enumerator that contains the same enumeration state as the 
		*current one. Using this function, a client can record a particular point in 
		*the enumeration sequence, and then return to that point at a later time. 
		*The new enumerator supports the same interface as the original one.
		*/
        STDMETHODIMP Clone( EnumObject** clonedObject ){
			*clonedObject = new EnumObject<T>( this );
		};//( IEnumFORMATETC ** );

	protected:
		std::vector<T> m_items;
		std::vector<T>::iterator m_itemIterator;
		unsigned long m_currentPos;

};

};
#endif //ENUMOBJECT_H