.TH ACE_Timer_Hash_Iterator_T 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Timer_Hash_Iterator_T \- Iterates over an . 
.SH SYNOPSIS
.br
.PP
\fC#include <Timer_Hash_T.h>\fR
.PP
Inherits \fBACE_Timer_Queue_Iterator_T< TYPE,FUNCTOR,ACE_LOCK >\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Timer_Hash_Iterator_T\fR (\fBACE_Timer_Hash_T\fR<TYPE, FUNCTOR, ACE_LOCK, BUCKET> &)"
.br
.RI "\fIConstructor.\fR"
.ti -1c
.RI "virtual void \fBfirst\fR (void)"
.br
.RI "\fIPositions the iterator at the earliest node in the Timer Queue.\fR"
.ti -1c
.RI "virtual void \fBnext\fR (void)"
.br
.RI "\fIPositions the iterator at the next node in the Timer Queue.\fR"
.ti -1c
.RI "virtual int \fBisdone\fR (void) const"
.br
.RI "\fIReturns true when there are no more nodes in the sequence.\fR"
.ti -1c
.RI "virtual \fBACE_Timer_Node_T\fR<TYPE>* \fBitem\fR (void)"
.br
.RI "\fIReturns the node at the current position in the sequence.\fR"
.in -1c
.SS Protected Attributes

.in +1c
.ti -1c
.RI "\fBACE_Timer_Hash_T\fR<TYPE, FUNCTOR, ACE_LOCK, BUCKET>& \fBtimer_hash_\fR"
.br
.RI "\fIPointer to the  that we are iterating over.\fR"
.ti -1c
.RI "size_t \fBposition_\fR"
.br
.RI "\fICurrent position in <timer_hash_>'s table.\fR"
.ti -1c
.RI "\fBACE_Timer_Queue_Iterator_T\fR<TYPE, \fBACE_Timer_Hash_Upcall\fR<TYPE, FUNCTOR, ACE_LOCK>, \fBACE_Null_Mutex\fR>* \fBiter_\fR"
.br
.RI "\fICurrent iterator used on <position>'s bucket.\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET>  template class ACE_Timer_Hash_Iterator_T
Iterates over an .
.PP
.PP
 This is a generic iterator that can be used to visit every node of a timer queue. Be aware that it doesn't transverse in the order of timeout values. 
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classTYPE, classFUNCTOR, classACE_LOCK, classBUCKET> ACE_Timer_Hash_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET>::ACE_Timer_Hash_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET> (\fBACE_Timer_Hash_T\fR< TYPE,FUNCTOR,ACE_LOCK,BUCKET >&)
.PP
Constructor.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classTYPE, classFUNCTOR, classACE_LOCK, classBUCKET> void ACE_Timer_Hash_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET>::first (void)\fC [virtual]\fR
.PP
Positions the iterator at the earliest node in the Timer Queue.
.PP
Reimplemented from \fBACE_Timer_Queue_Iterator_T\fR.
.SS template<classTYPE, classFUNCTOR, classACE_LOCK, classBUCKET> int ACE_Timer_Hash_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET>::isdone (void) const\fC [virtual]\fR
.PP
Returns true when there are no more nodes in the sequence.
.PP
Reimplemented from \fBACE_Timer_Queue_Iterator_T\fR.
.SS template<classTYPE, classFUNCTOR, classACE_LOCK, classBUCKET> \fBACE_Timer_Node_T\fR< TYPE >* ACE_Timer_Hash_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET>::item (void)\fC [virtual]\fR
.PP
Returns the node at the current position in the sequence.
.PP
Reimplemented from \fBACE_Timer_Queue_Iterator_T\fR.
.SS template<classTYPE, classFUNCTOR, classACE_LOCK, classBUCKET> void ACE_Timer_Hash_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET>::next (void)\fC [virtual]\fR
.PP
Positions the iterator at the next node in the Timer Queue.
.PP
Reimplemented from \fBACE_Timer_Queue_Iterator_T\fR.
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classTYPE, classFUNCTOR, classACE_LOCK, classBUCKET> \fBACE_Timer_Queue_Iterator_T\fR< TYPE,\fBACE_Timer_Hash_Upcall\fR< TYPE,FUNCTOR,ACE_LOCK >,\fBACE_Null_Mutex\fR >* ACE_Timer_Hash_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET>::iter_\fC [protected]\fR
.PP
Current iterator used on <position>'s bucket.
.PP
.SS template<classTYPE, classFUNCTOR, classACE_LOCK, classBUCKET> size_t ACE_Timer_Hash_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET>::position_\fC [protected]\fR
.PP
Current position in <timer_hash_>'s table.
.PP
.SS template<classTYPE, classFUNCTOR, classACE_LOCK, classBUCKET> \fBACE_Timer_Hash_T\fR< TYPE,FUNCTOR,ACE_LOCK,BUCKET >& ACE_Timer_Hash_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET>::timer_hash_\fC [protected]\fR
.PP
Pointer to the  that we are iterating over.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.