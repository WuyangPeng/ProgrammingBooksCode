.TH ACE_Handler_Caching_Utility 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Handler_Caching_Utility \- Defines a helper class for the Caching Strategies. 
.SH SYNOPSIS
.br
.PP
\fC#include <Caching_Utility_T.h>\fR
.PP
.SS Public Types

.in +1c
.ti -1c
.RI "typedef \fBACE_Handler_Cleanup_Strategy\fR<KEY, VALUE, CONTAINER> \fBCLEANUP_STRATEGY\fR"
.br
.ti -1c
.RI "typedef \fBACE_Cleanup_Strategy\fR<KEY, VALUE, CONTAINER> \fBCLEANUP_STRATEGY_BASE\fR"
.br
.in -1c
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Handler_Caching_Utility\fR (\fBACE_Cleanup_Strategy\fR<KEY, VALUE, CONTAINER> *cleanup_strategy = 0, int delete_cleanup_strategy = 0)"
.br
.RI "\fIConstructor.\fR"
.ti -1c
.RI "\fB~ACE_Handler_Caching_Utility\fR (void)"
.br
.RI "\fIDestructor.\fR"
.ti -1c
.RI "int \fBclear_cache\fR (CONTAINER &container, double purge_percent)"
.br
.in -1c
.SS Protected Methods

.in +1c
.ti -1c
.RI "void \fBminimum\fR (CONTAINER &container, KEY *&key_to_remove, VALUE *&value_to_remove)"
.br
.in -1c
.SS Protected Attributes

.in +1c
.ti -1c
.RI "\fBCLEANUP_STRATEGY_BASE\fR* \fBcleanup_strategy_\fR"
.br
.RI "\fIThe cleanup strategy which can be used to destroy the entries of the container.\fR"
.ti -1c
.RI "int \fBdelete_cleanup_strategy_\fR"
.br
.RI "\fIWhether the cleanup_strategy should be destroyed or not.\fR"
.in -1c
.SS Private Methods

.in +1c
.ti -1c
.RI "void \fBoperator=\fR (const ACE_Handler_Caching_Utility<KEY,VALUE,CONTAINER,ITERATOR,ATTRIBUTES> &)"
.br
.ti -1c
.RI "\fBACE_Handler_Caching_Utility\fR (const ACE_Handler_Caching_Utility<KEY,VALUE,CONTAINER,ITERATOR,ATTRIBUTES> &)"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class KEY, class VALUE, class CONTAINER, class ITERATOR, class ATTRIBUTES>  template class ACE_Handler_Caching_Utility
Defines a helper class for the Caching Strategies.
.PP
.PP
 This class defines the methods commonly used by the different caching strategies. For instance: <clear_cache> method which decides and purges the entry from the container. Note: This class helps in the caching_strategies using a container containing entries of <KEY, HANDLER> kind where the HANDLER contains the caching attributes which help in deciding the entries to be purged. The Cleanup_Strategy is the callback class to which the entries to be cleaned up will be delegated. 
.PP
.SH MEMBER TYPEDEF DOCUMENTATION
.PP 
.SS template<classKEY, classVALUE, classCONTAINER, classITERATOR, classATTRIBUTES> typedef \fBACE_Handler_Cleanup_Strategy\fR<KEY, VALUE, CONTAINER> ACE_Handler_Caching_Utility<KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES>::CLEANUP_STRATEGY
.PP
.SS template<classKEY, classVALUE, classCONTAINER, classITERATOR, classATTRIBUTES> typedef \fBACE_Cleanup_Strategy\fR<KEY, VALUE, CONTAINER> ACE_Handler_Caching_Utility<KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES>::CLEANUP_STRATEGY_BASE
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classKEY, classVALUE, classCONTAINER, classITERATOR, classATTRIBUTES> ACE_Handler_Caching_Utility<KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES>::ACE_Handler_Caching_Utility<KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES> (\fBACE_Cleanup_Strategy\fR< KEY,VALUE,CONTAINER >* cleanup_strategy = 0, int delete_cleanup_strategy = 0)
.PP
Constructor.
.PP
.SS template<classKEY, classVALUE, classCONTAINER, classITERATOR, classATTRIBUTES> ACE_Handler_Caching_Utility<KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES>::~ACE_Handler_Caching_Utility<KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES> (void)
.PP
Destructor.
.PP
.SS template<classKEY, classVALUE, classCONTAINER, classITERATOR, classATTRIBUTES> ACE_Handler_Caching_Utility<KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES>::ACE_Handler_Caching_Utility<KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES> (const ACE_Handler_Caching_Utility< KEY,VALUE,CONTAINER,ITERATOR,ATTRIBUTES >&)\fC [private]\fR
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classKEY, classVALUE, classCONTAINER, classITERATOR, classATTRIBUTES> int ACE_Handler_Caching_Utility<KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES>::clear_cache (CONTAINER & container, double purge_percent)
.PP
Purge entries from the <container>. The Cleanup_Strategy will do the actual job of cleanup once the entries to be cleaned up are decided. 
.SS template<classKEY, classVALUE, classCONTAINER, classITERATOR, classATTRIBUTES> void ACE_Handler_Caching_Utility<KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES>::minimum (CONTAINER & container, KEY *& key_to_remove, VALUE *& value_to_remove)\fC [protected]\fR
.PP
Find the entry with minimum caching attributes. This is handler specific since this utility is to be used very specifically for handler who have caching_attributes for server side acched connection management. 
.SS template<classKEY, classVALUE, classCONTAINER, classITERATOR, classATTRIBUTES> void ACE_Handler_Caching_Utility<KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES>::operator= (const ACE_Handler_Caching_Utility< KEY,VALUE,CONTAINER,ITERATOR,ATTRIBUTES >&)\fC [private]\fR
.PP
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classKEY, classVALUE, classCONTAINER, classITERATOR, classATTRIBUTES> \fBCLEANUP_STRATEGY_BASE\fR * ACE_Handler_Caching_Utility<KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES>::cleanup_strategy_\fC [protected]\fR
.PP
The cleanup strategy which can be used to destroy the entries of the container.
.PP
.SS template<classKEY, classVALUE, classCONTAINER, classITERATOR, classATTRIBUTES> int ACE_Handler_Caching_Utility<KEY, VALUE, CONTAINER, ITERATOR, ATTRIBUTES>::delete_cleanup_strategy_\fC [protected]\fR
.PP
Whether the cleanup_strategy should be destroyed or not.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.