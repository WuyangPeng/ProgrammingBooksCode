.TH ACE_Process_Semaphore 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Process_Semaphore \- Wrapper for Dijkstra style general semaphores that work across processes. 
.SH SYNOPSIS
.br
.PP
\fC#include <Process_Semaphore.h>\fR
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Process_Semaphore\fR (u_int count = 1, const \fBACE_TCHAR\fR *name = 0, void * = 0, int max = 0x7FFFFFFF)"
.br
.RI "\fIInitialize the semaphore, with an initial value of <count> and a maximum value of <max>.\fR"
.ti -1c
.RI "\fB~ACE_Process_Semaphore\fR (void)"
.br
.ti -1c
.RI "int \fBremove\fR (void)"
.br
.ti -1c
.RI "int \fBacquire\fR (void)"
.br
.RI "\fIBlock the thread until the semaphore count becomes greater than 0, then decrement it.\fR"
.ti -1c
.RI "int \fBtryacquire\fR (void)"
.br
.ti -1c
.RI "int \fBrelease\fR (void)"
.br
.RI "\fIIncrement the semaphore, potentially unblocking a waiting thread.\fR"
.ti -1c
.RI "int \fBacquire_read\fR (void)"
.br
.ti -1c
.RI "int \fBacquire_write\fR (void)"
.br
.ti -1c
.RI "int \fBtryacquire_read\fR (void)"
.br
.ti -1c
.RI "int \fBtryacquire_write\fR (void)"
.br
.ti -1c
.RI "int \fBtryacquire_write_upgrade\fR (void)"
.br
.ti -1c
.RI "const ACE_sema_t& \fBlock\fR (void) const"
.br
.RI "\fIReturn the underlying lock.\fR"
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Protected Attributes

.in +1c
.ti -1c
.RI "\fBACE_Semaphore\fR \fBlock_\fR"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 
Wrapper for Dijkstra style general semaphores that work across processes.
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS ACE_Process_Semaphore::ACE_Process_Semaphore (u_int count = 1, const \fBACE_TCHAR\fR * name = 0, void * = 0, int max = 0x7FFFFFFF)
.PP
Initialize the semaphore, with an initial value of <count> and a maximum value of <max>.
.PP
.SS ACE_Process_Semaphore::~ACE_Process_Semaphore (void)
.PP
This method is a no-op, i.e., it doesn't remove the semaphore. If you want to remove the semaphore, you must call the <remove> method explicitly. 
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS int ACE_Process_Semaphore::acquire (void)
.PP
Block the thread until the semaphore count becomes greater than 0, then decrement it.
.PP
.SS int ACE_Process_Semaphore::acquire_read (void)
.PP
Acquire semaphore ownership. This calls  and is only here to make the  interface consistent with the other synchronization APIs. 
.SS int ACE_Process_Semaphore::acquire_write (void)
.PP
Acquire semaphore ownership. This calls  and is only here to make the  interface consistent with the other synchronization APIs. 
.SS void ACE_Process_Semaphore::dump (void) const
.PP
Dump the state of an object.
.PP
.SS const ACE_sema_t & ACE_Process_Semaphore::lock (void) const
.PP
Return the underlying lock.
.PP
.SS int ACE_Process_Semaphore::release (void)
.PP
Increment the semaphore, potentially unblocking a waiting thread.
.PP
.SS int ACE_Process_Semaphore::remove (void)
.PP
Explicitly destroy the semaphore. Note that only one thread should call this method since it doesn't protect against race conditions. 
.SS int ACE_Process_Semaphore::tryacquire (void)
.PP
Conditionally decrement the semaphore if count is greater than 0 (i.e., won't block). Returns -1 on failure. If we "failed" because someone else already had the lock, <errno> is set to <EBUSY>. 
.SS int ACE_Process_Semaphore::tryacquire_read (void)
.PP
Conditionally acquire semaphore (i.e., won't block). This calls <tryacquire> and is only here to make the  interface consistent with the other synchronization APIs. Returns -1 on failure. If we "failed" because someone else already had the lock, <errno> is set to <EBUSY>. 
.SS int ACE_Process_Semaphore::tryacquire_write (void)
.PP
Conditionally acquire semaphore (i.e., won't block). This calls <tryacquire> and is only here to make the  interface consistent with the other synchronization APIs. Returns -1 on failure. If we "failed" because someone else already had the lock, <errno> is set to <EBUSY>. 
.SS int ACE_Process_Semaphore::tryacquire_write_upgrade (void)
.PP
This is only here to make the  interface consistent with the other synchronization APIs. Assumes the caller has already acquired the semaphore using one of the above calls, and returns 0 (success) always. 
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS ACE_Process_Semaphore::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
.SS \fBACE_Semaphore\fR ACE_Process_Semaphore::lock_\fC [protected]\fR
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.