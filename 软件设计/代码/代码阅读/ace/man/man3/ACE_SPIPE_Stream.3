.TH ACE_SPIPE_Stream 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_SPIPE_Stream \- Define an ACE_SPIPE_Stream. 
.SH SYNOPSIS
.br
.PP
\fC#include <SPIPE_Stream.h>\fR
.PP
Inherits \fBACE_SPIPE\fR.
.PP
.SS Public Types

.in +1c
.ti -1c
.RI "typedef \fBACE_SPIPE_Addr\fR \fBPEER_ADDR\fR"
.br
.in -1c
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_SPIPE_Stream\fR (void)"
.br
.RI "\fIDefault constructor.\fR"
.ti -1c
.RI "int \fBget_remote_addr\fR (\fBACE_SPIPE_Addr\fR &remote_sap) const"
.br
.RI "\fIObtain the address of whom we are connected with.\fR"
.ti -1c
.RI "int \fBsend_handle\fR (ACE_HANDLE handle) const"
.br
.RI "\fISend an open FD to another process.\fR"
.ti -1c
.RI "int \fBrecv_handle\fR (ACE_HANDLE &handle) const"
.br
.RI "\fIRecv an open FD from another process.\fR"
.ti -1c
.RI "int \fBrecv_handle\fR (strrecvfd &recvfd) const"
.br
.RI "\fIRecv an open FD from another process.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBsend_n\fR (const void *buf, size_t n) const"
.br
.RI "\fISend n bytes, keep trying until n are sent.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBrecv_n\fR (void *buf, size_t n) const"
.br
.RI "\fIRecv n bytes, keep trying until n are received.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBsend\fR (const void *buf, size_t n) const"
.br
.RI "\fISend bytes via \fBSTREAM\fR pipes using "band" mode.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBrecv\fR (void *buf, size_t n) const"
.br
.RI "\fIRecv bytes via \fBSTREAM\fR pipes using "band" mode.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBsend\fR (const \fBACE_Str_Buf\fR *cntl, const \fBACE_Str_Buf\fR *data, int flags = 0) const"
.br
.RI "\fISend <cntl> and <data> via \fBSTREAM\fR pipes.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBrecv\fR (\fBACE_Str_Buf\fR *cntl, \fBACE_Str_Buf\fR *data, int *flags) const"
.br
.RI "\fIRecv <cntl> and <data> via \fBSTREAM\fR pipes.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBsend\fR (const \fBACE_Str_Buf\fR *cntl, const \fBACE_Str_Buf\fR *data, int band, int flags) const"
.br
.RI "\fISend bytes via \fBSTREAM\fR pipes using "band" mode.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBrecv\fR (\fBACE_Str_Buf\fR *cntl, \fBACE_Str_Buf\fR *data, int *band, int *flags) const"
.br
.RI "\fIRecv bytes via \fBSTREAM\fR pipes using "band" mode.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBsend\fR (const \fBiovec\fR iov[], size_t n) const"
.br
.RI "\fISend iovecs via <writev>.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBrecv\fR (\fBiovec\fR iov[], size_t n) const"
.br
.RI "\fIRecv iovecs via <readv>.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBsend\fR (size_t n, ...) const"
.br
.ti -1c
.RI "\fBssize_t\fR \fBrecv\fR (size_t n, ...) const"
.br
.ti -1c
.RI "\fBssize_t\fR \fBsend\fR (const void *buf, size_t n, \fBACE_OVERLAPPED\fR *overlapped) const"
.br
.RI "\fISend <n> bytes via Win32 WriteFile using overlapped I/O.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBrecv\fR (void *buf, size_t n, \fBACE_OVERLAPPED\fR *overlapped) const"
.br
.RI "\fIRecv <n> bytes via Win32 ReadFile using overlapped I/O.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBsendv\fR (const \fBiovec\fR iov[], size_t n) const"
.br
.RI "\fISend an <\fBiovec\fR> of size <n> to the stream.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBsendv_n\fR (const \fBiovec\fR iov[], size_t n) const"
.br
.RI "\fISend an <\fBiovec\fR> of size <n> to the stream. Will block until all bytes are sent or an error occurs.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBrecvv_n\fR (\fBiovec\fR iov[], size_t n) const"
.br
.RI "\fIReceive an <\fBiovec\fR> of size <n> to the stream.\fR"
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "\fBACE_SPIPE_Addr\fR \fBremote_addr_\fR"
.br
.in -1c
.SS Friends

.in +1c
.ti -1c
.RI "class \fBACE_SPIPE_Acceptor\fR"
.br
.ti -1c
.RI "class \fBACE_SPIPE_Connector\fR"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 
Define an ACE_SPIPE_Stream.
.PP
.SH MEMBER TYPEDEF DOCUMENTATION
.PP 
.SS typedef \fBACE_SPIPE_Addr\fR ACE_SPIPE_Stream::PEER_ADDR
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS ACE_SPIPE_Stream::ACE_SPIPE_Stream (void)
.PP
Default constructor.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS void ACE_SPIPE_Stream::dump (void) const
.PP
Dump the state of an object.
.PP
Reimplemented from \fBACE_SPIPE\fR.
.SS int ACE_SPIPE_Stream::get_remote_addr (\fBACE_SPIPE_Addr\fR & remote_sap) const
.PP
Obtain the address of whom we are connected with.
.PP
.SS \fBssize_t\fR ACE_SPIPE_Stream::recv (void * buf, size_t n, \fBACE_OVERLAPPED\fR * overlapped) const
.PP
Recv <n> bytes via Win32 ReadFile using overlapped I/O.
.PP
.SS \fBssize_t\fR ACE_SPIPE_Stream::recv (size_t n, ...) const
.PP
This is an interface to readv, that doesn't use the struct \fBiovec\fR explicitly. The ... can be passed as an arbitrary number of (char *ptr, int len) tuples. However, the count N is the *total* number of trailing arguments, *not* a couple of the number of tuple pairs! 
.SS \fBssize_t\fR ACE_SPIPE_Stream::recv (\fBiovec\fR iov[], size_t n) const
.PP
Recv iovecs via <readv>.
.PP
.SS \fBssize_t\fR ACE_SPIPE_Stream::recv (\fBACE_Str_Buf\fR * cntl, \fBACE_Str_Buf\fR * data, int * band, int * flags) const
.PP
Recv bytes via \fBSTREAM\fR pipes using "band" mode.
.PP
.SS \fBssize_t\fR ACE_SPIPE_Stream::recv (\fBACE_Str_Buf\fR * cntl, \fBACE_Str_Buf\fR * data, int * flags) const
.PP
Recv <cntl> and <data> via \fBSTREAM\fR pipes.
.PP
.SS \fBssize_t\fR ACE_SPIPE_Stream::recv (void * buf, size_t n) const
.PP
Recv bytes via \fBSTREAM\fR pipes using "band" mode.
.PP
.SS int ACE_SPIPE_Stream::recv_handle (strrecvfd & recvfd) const
.PP
Recv an open FD from another process.
.PP
.SS int ACE_SPIPE_Stream::recv_handle (ACE_HANDLE & handle) const
.PP
Recv an open FD from another process.
.PP
.SS \fBssize_t\fR ACE_SPIPE_Stream::recv_n (void * buf, size_t n) const
.PP
Recv n bytes, keep trying until n are received.
.PP
.SS \fBssize_t\fR ACE_SPIPE_Stream::recvv_n (\fBiovec\fR iov[], size_t n) const
.PP
Receive an <\fBiovec\fR> of size <n> to the stream.
.PP
.SS \fBssize_t\fR ACE_SPIPE_Stream::send (const void * buf, size_t n, \fBACE_OVERLAPPED\fR * overlapped) const
.PP
Send <n> bytes via Win32 WriteFile using overlapped I/O.
.PP
.SS \fBssize_t\fR ACE_SPIPE_Stream::send (size_t n, ...) const
.PP
Send N char *ptrs and int lengths. Note that the char *'s precede the ints (basically, an varargs version of writev). The count N is the *total* number of trailing arguments, *not* a couple of the number of tuple pairs! 
.SS \fBssize_t\fR ACE_SPIPE_Stream::send (const \fBiovec\fR iov[], size_t n) const
.PP
Send iovecs via <writev>.
.PP
.SS \fBssize_t\fR ACE_SPIPE_Stream::send (const \fBACE_Str_Buf\fR * cntl, const \fBACE_Str_Buf\fR * data, int band, int flags) const
.PP
Send bytes via \fBSTREAM\fR pipes using "band" mode.
.PP
.SS \fBssize_t\fR ACE_SPIPE_Stream::send (const \fBACE_Str_Buf\fR * cntl, const \fBACE_Str_Buf\fR * data, int flags = 0) const
.PP
Send <cntl> and <data> via \fBSTREAM\fR pipes.
.PP
.SS \fBssize_t\fR ACE_SPIPE_Stream::send (const void * buf, size_t n) const
.PP
Send bytes via \fBSTREAM\fR pipes using "band" mode.
.PP
.SS int ACE_SPIPE_Stream::send_handle (ACE_HANDLE handle) const
.PP
Send an open FD to another process.
.PP
.SS \fBssize_t\fR ACE_SPIPE_Stream::send_n (const void * buf, size_t n) const
.PP
Send n bytes, keep trying until n are sent.
.PP
.SS \fBssize_t\fR ACE_SPIPE_Stream::sendv (const \fBiovec\fR iov[], size_t n) const
.PP
Send an <\fBiovec\fR> of size <n> to the stream.
.PP
.SS \fBssize_t\fR ACE_SPIPE_Stream::sendv_n (const \fBiovec\fR iov[], size_t n) const
.PP
Send an <\fBiovec\fR> of size <n> to the stream. Will block until all bytes are sent or an error occurs.
.PP
.SH FRIENDS AND RELATED FUNCTION DOCUMENTATION
.PP 
.SS class ACE_SPIPE_Acceptor\fC [friend]\fR
.PP
.SS class ACE_SPIPE_Connector\fC [friend]\fR
.PP
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS ACE_SPIPE_Stream::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
Reimplemented from \fBACE_SPIPE\fR.
.SS \fBACE_SPIPE_Addr\fR ACE_SPIPE_Stream::remote_addr_\fC [private]\fR
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.