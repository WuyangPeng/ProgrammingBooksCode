.TH ACE_XtReactor 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_XtReactor \- An object-oriented event demultiplexor and event handler dispatcher that uses the X Toolkit functions. 
.SH SYNOPSIS
.br
.PP
\fC#include <XtReactor.h>\fR
.PP
Inherits \fBACE_Select_Reactor_T\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_XtReactor\fR (XtAppContext context = 0, size_t size = DEFAULT_SIZE, int restart = 0, \fBACE_Sig_Handler\fR * = 0)"
.br
.ti -1c
.RI "virtual \fB~ACE_XtReactor\fR (void)"
.br
.ti -1c
.RI "XtAppContext \fBcontext\fR (void) const"
.br
.ti -1c
.RI "void \fBcontext\fR (XtAppContext)"
.br
.ti -1c
.RI "virtual long \fBschedule_timer\fR (\fBACE_Event_Handler\fR *handler, const void *arg, const \fBACE_Time_Value\fR &delay_time, const \fBACE_Time_Value\fR &interval)"
.br
.ti -1c
.RI "virtual int \fBreset_timer_interval\fR (long timer_id, const \fBACE_Time_Value\fR &interval)"
.br
.ti -1c
.RI "virtual int \fBcancel_timer\fR (\fBACE_Event_Handler\fR *handler, int dont_call_handle_close = 1)"
.br
.ti -1c
.RI "virtual int \fBcancel_timer\fR (long timer_id, const void **arg = 0, int dont_call_handle_close = 1)"
.br
.in -1c
.SS Protected Methods

.in +1c
.ti -1c
.RI "virtual int \fBregister_handler_i\fR (ACE_HANDLE handle, \fBACE_Event_Handler\fR *handler, \fBACE_Reactor_Mask\fR mask)"
.br
.RI "\fIRegister a single <handler>.\fR"
.ti -1c
.RI "virtual int \fBregister_handler_i\fR (const \fBACE_Handle_Set\fR &handles, \fBACE_Event_Handler\fR *handler, \fBACE_Reactor_Mask\fR mask)"
.br
.RI "\fIRegister a set of <handlers>.\fR"
.ti -1c
.RI "virtual int \fBremove_handler_i\fR (ACE_HANDLE handle, \fBACE_Reactor_Mask\fR mask)"
.br
.RI "\fIRemove the <handler> associated with this <handle>.\fR"
.ti -1c
.RI "virtual int \fBremove_handler_i\fR (const \fBACE_Handle_Set\fR &handles, \fBACE_Reactor_Mask\fR)"
.br
.RI "\fIRemove a set of <handles>.\fR"
.ti -1c
.RI "virtual void \fBremove_XtInput\fR (ACE_HANDLE handle)"
.br
.RI "\fIRemoves an Xt handle.\fR"
.ti -1c
.RI "virtual int \fBwait_for_multiple_events\fR (\fBACE_Select_Reactor_Handle_Set\fR &, \fBACE_Time_Value\fR *)"
.br
.RI "\fIWait for events to occur.\fR"
.ti -1c
.RI "virtual int \fBXtWaitForMultipleEvents\fR (int, \fBACE_Select_Reactor_Handle_Set\fR &, \fBACE_Time_Value\fR *)"
.br
.RI "\fIWait for Xt events to occur.\fR"
.in -1c
.SS Protected Attributes

.in +1c
.ti -1c
.RI "XtAppContext \fBcontext_\fR"
.br
.ti -1c
.RI "\fBACE_XtReactorID\fR* \fBids_\fR"
.br
.ti -1c
.RI "XtIntervalId \fBtimeout_\fR"
.br
.in -1c
.SS Private Methods

.in +1c
.ti -1c
.RI "void \fBreset_timeout\fR (void)"
.br
.RI "\fIThis method ensures there's an Xt timeout for the first timeout in the Reactor's Timer_Queue.\fR"
.ti -1c
.RI "\fBACE_XtReactor\fR (const ACE_XtReactor &)"
.br
.RI "\fIDeny access since member-wise won't work...\fR"
.ti -1c
.RI "ACE_XtReactor& \fBoperator=\fR (const ACE_XtReactor &)"
.br
.in -1c
.SS Static Private Methods

.in +1c
.ti -1c
.RI "void \fBTimerCallbackProc\fR (XtPointer closure, XtIntervalId *id)"
.br
.ti -1c
.RI "void \fBInputCallbackProc\fR (XtPointer closure, int* source, XtInputId *id)"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 
An object-oriented event demultiplexor and event handler dispatcher that uses the X Toolkit functions.
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS ACE_XtReactor::ACE_XtReactor (XtAppContext context = 0, size_t size = DEFAULT_SIZE, int restart = 0, \fBACE_Sig_Handler\fR * = 0)
.PP
.SS virtual ACE_XtReactor::~ACE_XtReactor (void)\fC [virtual]\fR
.PP
.SS ACE_XtReactor::ACE_XtReactor (const ACE_XtReactor &)\fC [private]\fR
.PP
Deny access since member-wise won't work...
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS void ACE_XtReactor::InputCallbackProc (XtPointer closure, int * source, XtInputId * id)\fC [static, private]\fR
.PP
.SS void ACE_XtReactor::TimerCallbackProc (XtPointer closure, XtIntervalId * id)\fC [static, private]\fR
.PP
.SS int ACE_XtReactor::XtWaitForMultipleEvents (int, \fBACE_Select_Reactor_Handle_Set\fR &, \fBACE_Time_Value\fR *)\fC [protected, virtual]\fR
.PP
Wait for Xt events to occur.
.PP
.SS virtual int ACE_XtReactor::cancel_timer (long timer_id, const void ** arg = 0, int dont_call_handle_close = 1)\fC [virtual]\fR
.PP
Cancel the single  that matches the <timer_id> value (which was returned from the <schedule> method). If arg is non-NULL then it will be set to point to the ``magic cookie'' argument passed in when the <Event_Handler> was registered. This makes it possible to free up the memory and avoid memory leaks. If <dont_call_handle_close> is 0 then the <handle_close> method of <event_handler> will be invoked. Returns 1 if cancellation succeeded and 0 if the <timer_id> wasn't found. 
.PP
Reimplemented from \fBACE_Select_Reactor_T\fR.
.SS virtual int ACE_XtReactor::cancel_timer (\fBACE_Event_Handler\fR * handler, int dont_call_handle_close = 1)\fC [virtual]\fR
.PP
Cancel all <event_handlers> that match the address of <event_handler>. If <dont_call_handle_close> is 0 then the <handle_close> method of <event_handler> will be invoked. Returns number of handler's cancelled. 
.PP
Reimplemented from \fBACE_Select_Reactor_T\fR.
.SS void ACE_XtReactor::context (XtAppContext)
.PP
.SS XtAppContext ACE_XtReactor::context (void) const
.PP
.SS ACE_XtReactor& ACE_XtReactor::operator= (const ACE_XtReactor &)\fC [private]\fR
.PP
.SS int ACE_XtReactor::register_handler_i (const \fBACE_Handle_Set\fR & handles, \fBACE_Event_Handler\fR * handler, \fBACE_Reactor_Mask\fR mask)\fC [protected, virtual]\fR
.PP
Register a set of <handlers>.
.PP
Reimplemented from \fBACE_Select_Reactor_T\fR.
.SS int ACE_XtReactor::register_handler_i (ACE_HANDLE handle, \fBACE_Event_Handler\fR * handler, \fBACE_Reactor_Mask\fR mask)\fC [protected, virtual]\fR
.PP
Register a single <handler>.
.PP
Reimplemented from \fBACE_Select_Reactor_T\fR.
.SS void ACE_XtReactor::remove_XtInput (ACE_HANDLE handle)\fC [protected, virtual]\fR
.PP
Removes an Xt handle.
.PP
.SS int ACE_XtReactor::remove_handler_i (const \fBACE_Handle_Set\fR & handles, \fBACE_Reactor_Mask\fR mask)\fC [protected, virtual]\fR
.PP
Remove a set of <handles>.
.PP
Reimplemented from \fBACE_Select_Reactor_T\fR.
.SS int ACE_XtReactor::remove_handler_i (ACE_HANDLE handle, \fBACE_Reactor_Mask\fR mask)\fC [protected, virtual]\fR
.PP
Remove the <handler> associated with this <handle>.
.PP
Reimplemented from \fBACE_Select_Reactor_T\fR.
.SS void ACE_XtReactor::reset_timeout (void)\fC [private]\fR
.PP
This method ensures there's an Xt timeout for the first timeout in the Reactor's Timer_Queue.
.PP
.SS virtual int ACE_XtReactor::reset_timer_interval (long timer_id, const \fBACE_Time_Value\fR & interval)\fC [virtual]\fR
.PP
Resets the interval of the timer represented by <timer_id> to <interval>, which is specified in relative time to the current <gettimeofday>. If <interval> is equal to , the timer will become a non-rescheduling timer. Returns 0 if successful, -1 if not. 
.PP
Reimplemented from \fBACE_Select_Reactor_T\fR.
.SS virtual long ACE_XtReactor::schedule_timer (\fBACE_Event_Handler\fR * handler, const void * arg, const \fBACE_Time_Value\fR & delay_time, const \fBACE_Time_Value\fR & interval)\fC [virtual]\fR
.PP
Schedule an \fBACE_Event_Handler\fR that will expire after an amount of time. The return value of this method, a timer_id value, uniquely identifies the event_handler in the \fBACE_Reactor\fR's internal list of timers. This timer_id value can be used to cancel the timer with the \fBcancel_timer\fR() call.
.PP
\fBSee also: \fR
.in +1c
 \fBcancel_timer\fR() ,  \fBreset_timer_interval\fR()
.PP
\fBParameters: \fR
.in +1c
.TP
\fB\fIevent_handler\fR\fR event handler to schedule on reactor 
.TP
\fB\fIarg\fR\fR argument passed to the handle_timeout() method of event_handler  
.TP
\fB\fIdelta\fR\fR time interval after which the timer will expire 
.TP
\fB\fIinterval\fR\fR time interval after which the timer will be automatically rescheduled 
.PP
\fBReturns: \fR
.in +1c
 -1 on failure, a timer_id value on success 
.PP
Reimplemented from \fBACE_Select_Reactor_T\fR.
.SS int ACE_XtReactor::wait_for_multiple_events (\fBACE_Select_Reactor_Handle_Set\fR & handle_set, \fBACE_Time_Value\fR * max_wait_time)\fC [protected, virtual]\fR
.PP
Wait for events to occur.
.PP
Reimplemented from \fBACE_Select_Reactor_T\fR.
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS XtAppContext ACE_XtReactor::context_\fC [protected]\fR
.PP
.SS \fBACE_XtReactorID\fR * ACE_XtReactor::ids_\fC [protected]\fR
.PP
.SS XtIntervalId ACE_XtReactor::timeout_\fC [protected]\fR
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.