.TH ACE_Unbounded_Set 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Unbounded_Set \- Implement a simple unordered set of <T> of unbounded size. 
.SH SYNOPSIS
.br
.PP
\fC#include <Unbounded_Set.h>\fR
.PP
.SS Public Types

.in +1c
.ti -1c
.RI "typedef \fBACE_Unbounded_Set_Iterator\fR<T> \fBITERATOR\fR"
.br
.ti -1c
.RI "typedef \fBACE_Unbounded_Set_Iterator\fR<T> \fBiterator\fR"
.br
.ti -1c
.RI "typedef \fBACE_Unbounded_Set_Const_Iterator\fR<T> \fBCONST_ITERATOR\fR"
.br
.ti -1c
.RI "typedef \fBACE_Unbounded_Set_Const_Iterator\fR<T> \fBconst_iterator\fR"
.br
.in -1c
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Unbounded_Set\fR (\fBACE_Allocator\fR *alloc = 0)"
.br
.RI "\fIConstructor. Use user specified allocation strategy if specified.\fR"
.ti -1c
.RI "\fBACE_Unbounded_Set\fR (const ACE_Unbounded_Set<T> &)"
.br
.RI "\fICopy constructor.\fR"
.ti -1c
.RI "void \fBoperator=\fR (const ACE_Unbounded_Set<T> &)"
.br
.RI "\fIAssignment operator.\fR"
.ti -1c
.RI "\fB~ACE_Unbounded_Set\fR (void)"
.br
.RI "\fIDestructor.\fR"
.ti -1c
.RI "int \fBis_empty\fR (void) const"
.br
.RI "\fIReturns 1 if the container is empty, otherwise returns 0.\fR"
.ti -1c
.RI "int \fBis_full\fR (void) const"
.br
.RI "\fIReturns 1 if the container is full, otherwise returns 0.\fR"
.ti -1c
.RI "int \fBinsert\fR (const T &new_item)"
.br
.ti -1c
.RI "int \fBremove\fR (const T &item)"
.br
.ti -1c
.RI "int \fBfind\fR (const T &item) const"
.br
.RI "\fIFinds if <item> occurs in the set. Returns 0 if find succeeds, else -1.\fR"
.ti -1c
.RI "size_t \fBsize\fR (void) const"
.br
.RI "\fISize of the set.\fR"
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.ti -1c
.RI "void \fBreset\fR (void)"
.br
.RI "\fIReset the  to be empty.\fR"
.ti -1c
.RI "\fBACE_Unbounded_Set_Iterator\fR<T> \fBbegin\fR (void)"
.br
.ti -1c
.RI "\fBACE_Unbounded_Set_Iterator\fR<T> \fBend\fR (void)"
.br
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Private Methods

.in +1c
.ti -1c
.RI "int \fBinsert_tail\fR (const T &item)"
.br
.RI "\fIInsert <item> at the tail of the set (doesn't check for duplicates).\fR"
.ti -1c
.RI "void \fBdelete_nodes\fR (void)"
.br
.RI "\fIDelete all the nodes in the Set.\fR"
.ti -1c
.RI "void \fBcopy_nodes\fR (const ACE_Unbounded_Set<T> &)"
.br
.RI "\fICopy nodes into this set.\fR"
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "\fBACE_Node\fR<T>* \fBhead_\fR"
.br
.RI "\fIHead of the linked list of Nodes.\fR"
.ti -1c
.RI "size_t \fBcur_size_\fR"
.br
.RI "\fICurrent size of the set.\fR"
.ti -1c
.RI "\fBACE_Allocator\fR* \fBallocator_\fR"
.br
.RI "\fIAllocation strategy of the set.\fR"
.in -1c
.SS Friends

.in +1c
.ti -1c
.RI "class \fBACE_Unbounded_Set_Iterator< T >\fR"
.br
.ti -1c
.RI "class \fBACE_Unbounded_Set_Const_Iterator< T >\fR"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class T>  template class ACE_Unbounded_Set
Implement a simple unordered set of <T> of unbounded size.
.PP
.PP
 This implementation of an unordered set uses a circular linked list with a dummy node. This implementation does not allow duplicates, but it maintains FIFO ordering of insertions. 
.PP
.SH MEMBER TYPEDEF DOCUMENTATION
.PP 
.SS template<classT> typedef \fBACE_Unbounded_Set_Const_Iterator\fR<T> ACE_Unbounded_Set<T>::CONST_ITERATOR
.PP
.SS template<classT> typedef \fBACE_Unbounded_Set_Iterator\fR<T> ACE_Unbounded_Set<T>::ITERATOR
.PP
.SS template<classT> typedef \fBACE_Unbounded_Set_Const_Iterator\fR<T> ACE_Unbounded_Set<T>::const_iterator
.PP
.SS template<classT> typedef \fBACE_Unbounded_Set_Iterator\fR<T> ACE_Unbounded_Set<T>::iterator
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classT> ACE_Unbounded_Set<T>::ACE_Unbounded_Set<T> (\fBACE_Allocator\fR * alloc = 0)
.PP
Constructor. Use user specified allocation strategy if specified.
.PP
.SS template<classT> ACE_Unbounded_Set<T>::ACE_Unbounded_Set<T> (const ACE_Unbounded_Set< T >&)
.PP
Copy constructor.
.PP
.SS template<classT> ACE_Unbounded_Set<T>::~ACE_Unbounded_Set<T> (void)
.PP
Destructor.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classT> \fBACE_Unbounded_Set_Iterator\fR<T> ACE_Unbounded_Set<T>::begin (void)
.PP
.SS template<classT> void ACE_Unbounded_Set<T>::copy_nodes (const ACE_Unbounded_Set< T >&)\fC [private]\fR
.PP
Copy nodes into this set.
.PP
.SS template<classT> void ACE_Unbounded_Set<T>::delete_nodes (void)\fC [private]\fR
.PP
Delete all the nodes in the Set.
.PP
.SS template<classT> void ACE_Unbounded_Set<T>::dump (void) const
.PP
Dump the state of an object.
.PP
.SS template<classT> \fBACE_Unbounded_Set_Iterator\fR<T> ACE_Unbounded_Set<T>::end (void)
.PP
.SS template<classT> int ACE_Unbounded_Set<T>::find (const T & item) const
.PP
Finds if <item> occurs in the set. Returns 0 if find succeeds, else -1.
.PP
.SS template<classT> int ACE_Unbounded_Set<T>::insert (const T & new_item)
.PP
Insert <new_item> into the set (doesn't allow duplicates). Returns -1 if failures occur, 1 if item is already present, else 0. 
.SS template<classT> int ACE_Unbounded_Set<T>::insert_tail (const T & item)\fC [private]\fR
.PP
Insert <item> at the tail of the set (doesn't check for duplicates).
.PP
.SS template<classT> int ACE_Unbounded_Set<T>::is_empty (void) const
.PP
Returns 1 if the container is empty, otherwise returns 0.
.PP
.SS template<classT> int ACE_Unbounded_Set<T>::is_full (void) const
.PP
Returns 1 if the container is full, otherwise returns 0.
.PP
.SS template<classT> void ACE_Unbounded_Set<T>::operator= (const ACE_Unbounded_Set< T >&)
.PP
Assignment operator.
.PP
.SS template<classT> int ACE_Unbounded_Set<T>::remove (const T & item)
.PP
Remove first occurrence of <item> from the set. Returns 0 if it removes the item, -1 if it can't find the item, and -1 if a failure occurs. 
.SS template<classT> void ACE_Unbounded_Set<T>::reset (void)
.PP
Reset the  to be empty.
.PP
.SS template<classT> size_t ACE_Unbounded_Set<T>::size (void) const
.PP
Size of the set.
.PP
.SH FRIENDS AND RELATED FUNCTION DOCUMENTATION
.PP 
.SS template<classT> class \fBACE_Unbounded_Set_Const_Iterator\fR\fC [friend]\fR
.PP
.SS template<classT> class \fBACE_Unbounded_Set_Iterator\fR\fC [friend]\fR
.PP
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classT> ACE_Unbounded_Set<T>::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
.SS template<classT> \fBACE_Allocator\fR * ACE_Unbounded_Set<T>::allocator_\fC [private]\fR
.PP
Allocation strategy of the set.
.PP
.SS template<classT> size_t ACE_Unbounded_Set<T>::cur_size_\fC [private]\fR
.PP
Current size of the set.
.PP
.SS template<classT> \fBACE_Node\fR< T >* ACE_Unbounded_Set<T>::head_\fC [private]\fR
.PP
Head of the linked list of Nodes.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.