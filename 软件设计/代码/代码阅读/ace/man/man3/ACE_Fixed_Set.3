.TH ACE_Fixed_Set 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Fixed_Set \- Implement a simple unordered set of <T> with maximum . 
.SH SYNOPSIS
.br
.PP
\fC#include <Containers_T.h>\fR
.PP
.SS Public Types

.in +1c
.ti -1c
.RI "typedef \fBACE_Fixed_Set_Iterator\fR<T, ACE_SIZE> \fBITERATOR\fR"
.br
.in -1c
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Fixed_Set\fR (void)"
.br
.RI "\fIConstructor.\fR"
.ti -1c
.RI "\fBACE_Fixed_Set\fR (const ACE_Fixed_Set<T, ACE_SIZE> &)"
.br
.RI "\fICopy constructor.\fR"
.ti -1c
.RI "void \fBoperator=\fR (const ACE_Fixed_Set<T, ACE_SIZE> &)"
.br
.RI "\fIAssignment operator.\fR"
.ti -1c
.RI "\fB~ACE_Fixed_Set\fR (void)"
.br
.RI "\fIDestructor.\fR"
.ti -1c
.RI "int \fBis_empty\fR (void) const"
.br
.RI "\fIReturns 1 if the container is empty, otherwise returns 0.\fR"
.ti -1c
.RI "int \fBis_full\fR (void) const"
.br
.RI "\fIReturns 1 if the container is full, otherwise returns 0.\fR"
.ti -1c
.RI "int \fBinsert\fR (const T &new_item)"
.br
.ti -1c
.RI "int \fBremove\fR (const T &item)"
.br
.ti -1c
.RI "int \fBfind\fR (const T &item) const"
.br
.RI "\fIFinds if <item> occurs in the set. Returns 0 if finds, else -1.\fR"
.ti -1c
.RI "size_t \fBsize\fR (void) const"
.br
.RI "\fISize of the set.\fR"
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "struct {"
.br
.ti -1c
.RI "  T \fBitem_\fR"
.br
.ti -1c
.RI "  int \fBis_free_\fR"
.br
.ti -1c
.RI "} \fBsearch_structure_\fR [ACE_SIZE]"
.br
.RI ""
.br
.ti -1c
.RI "size_t \fBcur_size_\fR"
.br
.RI "\fICurrent size of the set.\fR"
.ti -1c
.RI "size_t \fBmax_size_\fR"
.br
.RI "\fIMaximum size of the set.\fR"
.in -1c
.SS Friends

.in +1c
.ti -1c
.RI "class \fBACE_Fixed_Set_Iterator< T,ACE_SIZE >\fR"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class T, size_t ACE_SIZE>  template class ACE_Fixed_Set
Implement a simple unordered set of <T> with maximum .
.PP
.PP
 This implementation of an unordered set uses a fixed array. This implementation does not allow duplicates... 
.PP
.SH MEMBER TYPEDEF DOCUMENTATION
.PP 
.SS template<classT, size_tACE_SIZE> typedef \fBACE_Fixed_Set_Iterator\fR<T, ACE_SIZE> ACE_Fixed_Set<T, ACE_SIZE>::ITERATOR
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classT, size_tACE_SIZE> ACE_Fixed_Set<T, ACE_SIZE>::ACE_Fixed_Set<T, ACE_SIZE> (void)
.PP
Constructor.
.PP
.SS template<classT, size_tACE_SIZE> ACE_Fixed_Set<T, ACE_SIZE>::ACE_Fixed_Set<T, ACE_SIZE> (const ACE_Fixed_Set< T,ACE_SIZE >&)
.PP
Copy constructor.
.PP
.SS template<classT, size_tACE_SIZE> ACE_Fixed_Set<T, ACE_SIZE>::~ACE_Fixed_Set<T, ACE_SIZE> (void)
.PP
Destructor.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classT, size_tACE_SIZE> void ACE_Fixed_Set<T, ACE_SIZE>::dump (void) const
.PP
Dump the state of an object.
.PP
.SS template<classT, size_tACE_SIZE> int ACE_Fixed_Set<T, ACE_SIZE>::find (const T & item) const
.PP
Finds if <item> occurs in the set. Returns 0 if finds, else -1.
.PP
.SS template<classT, size_tACE_SIZE> int ACE_Fixed_Set<T, ACE_SIZE>::insert (const T & new_item)
.PP
Insert <new_item> into the set (doesn't allow duplicates). Returns -1 if failures occur, 1 if item is already present, else 0. 
.SS template<classT, size_tACE_SIZE> int ACE_Fixed_Set<T, ACE_SIZE>::is_empty (void) const
.PP
Returns 1 if the container is empty, otherwise returns 0.
.PP
.SS template<classT, size_tACE_SIZE> int ACE_Fixed_Set<T, ACE_SIZE>::is_full (void) const
.PP
Returns 1 if the container is full, otherwise returns 0.
.PP
.SS template<classT, size_tACE_SIZE> void ACE_Fixed_Set<T, ACE_SIZE>::operator= (const ACE_Fixed_Set< T,ACE_SIZE >&)
.PP
Assignment operator.
.PP
.SS template<classT, size_tACE_SIZE> int ACE_Fixed_Set<T, ACE_SIZE>::remove (const T & item)
.PP
Remove first occurrence of <item> from the set. Returns 0 if it removes the item, -1 if it can't find the item, and -1 if a failure occurs. 
.SS template<classT, size_tACE_SIZE> size_t ACE_Fixed_Set<T, ACE_SIZE>::size (void) const
.PP
Size of the set.
.PP
.SH FRIENDS AND RELATED FUNCTION DOCUMENTATION
.PP 
.SS template<classT, size_tACE_SIZE> class \fBACE_Fixed_Set_Iterator\fR\fC [friend]\fR
.PP
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classT, size_tACE_SIZE> ACE_Fixed_Set<T, ACE_SIZE>::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
.SS template<classT, size_tACE_SIZE> size_t ACE_Fixed_Set<T, ACE_SIZE>::cur_size_\fC [private]\fR
.PP
Current size of the set.
.PP
.SS template<classT, size_tACE_SIZE> int ACE_Fixed_Set<T, ACE_SIZE>::is_free_\fC [private]\fR
.PP
.SS template<classT, size_tACE_SIZE> T ACE_Fixed_Set<T, ACE_SIZE>::item_\fC [private]\fR
.PP
.SS template<classT, size_tACE_SIZE> size_t ACE_Fixed_Set<T, ACE_SIZE>::max_size_\fC [private]\fR
.PP
Maximum size of the set.
.PP
.SS struct { ... }   ACE_Fixed_Set::search_structure_[ACE_SIZE]\fC [private]\fR
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.