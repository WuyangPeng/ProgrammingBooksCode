.TH ACE_Thread_Condition 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Thread_Condition \- \fBACE_Condition\fR variable wrapper that works within processes. 
.SH SYNOPSIS
.br
.PP
\fC#include <Synch_T.h>\fR
.PP
Inherits \fBACE_Condition< MUTEX >\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Thread_Condition\fR (MUTEX &m, const \fBACE_TCHAR\fR *name = 0, void *arg = 0)"
.br
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class MUTEX>  template class ACE_Thread_Condition
\fBACE_Condition\fR variable wrapper that works within processes.
.PP
.PP
 A condition variable enables threads to atomically block and test the condition under the protection of a mutual exclu- sion lock (mutex) until the condition is satisfied. That is, the mutex must have been held by the thread before calling wait or signal on the condition. If the condition is false, a thread blocks on a condition variable and atomically releases the mutex that is waiting for the condition to change. If another thread changes the condition, it may wake up waiting threads by signaling the associated condition variable. The waiting threads, upon awakening, reacquire the mutex and re-evaluate the condition. 
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classMUTEX> ACE_Thread_Condition<MUTEX>::ACE_Thread_Condition<MUTEX> (MUTEX & m, const \fBACE_TCHAR\fR * name = 0, void * arg = 0)
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classMUTEX> void ACE_Thread_Condition<MUTEX>::dump (void) const
.PP
Dump the state of an object.
.PP
Reimplemented from \fBACE_Condition\fR.

.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.