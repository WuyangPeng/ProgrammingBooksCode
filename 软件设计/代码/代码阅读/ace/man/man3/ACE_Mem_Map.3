.TH ACE_Mem_Map 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Mem_Map \- C++ interface OS memory mapping system call. 
.SH SYNOPSIS
.br
.PP
\fC#include <Mem_Map.h>\fR
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Mem_Map\fR (void)"
.br
.RI "\fIDefault constructor.\fR"
.ti -1c
.RI "\fBACE_Mem_Map\fR (ACE_HANDLE handle, int length = -1, int prot = PROT_RDWR, int share = ACE_MAP_PRIVATE, void *addr = 0, off_t offset = 0, LPSECURITY_ATTRIBUTES sa = 0)"
.br
.RI "\fIMap a file from an open file descriptor <handle>. This function will lookup the length of the file if it is not given.\fR"
.ti -1c
.RI "\fBACE_Mem_Map\fR (const \fBACE_TCHAR\fR *filename, int len = -1, int flags = O_RDWR | O_CREAT, int mode = ACE_DEFAULT_FILE_PERMS, int prot = PROT_RDWR, int share = ACE_MAP_PRIVATE, void *addr = 0, off_t offset = 0, LPSECURITY_ATTRIBUTES sa = 0)"
.br
.RI "\fIMap a file specified by <file_name>.\fR"
.ti -1c
.RI "int \fBmap\fR (ACE_HANDLE handle, int length = -1, int prot = PROT_RDWR, int share = ACE_MAP_PRIVATE, void *addr = 0, off_t offset = 0, LPSECURITY_ATTRIBUTES sa = 0)"
.br
.RI "\fIMap a file from an open file descriptor <handle>. This function will lookup the length of the file if it is not given.\fR"
.ti -1c
.RI "int \fBmap\fR (int length = -1, int prot = PROT_RDWR, int share = ACE_MAP_PRIVATE, void *addr = 0, off_t offset = 0, LPSECURITY_ATTRIBUTES sa = 0)"
.br
.RI "\fIRemap the file associated with <handle_>.\fR"
.ti -1c
.RI "int \fBmap\fR (const \fBACE_TCHAR\fR *filename, int len = -1, int flags = O_RDWR | O_CREAT, int mode = ACE_DEFAULT_FILE_PERMS, int prot = PROT_RDWR, int share = ACE_MAP_PRIVATE, void *addr = 0, off_t offset = 0, LPSECURITY_ATTRIBUTES sa = 0)"
.br
.RI "\fIMap a file specified by <filename>.\fR"
.ti -1c
.RI "\fB~ACE_Mem_Map\fR (void)"
.br
.RI "\fIDestructor.\fR"
.ti -1c
.RI "int \fBopen\fR (const \fBACE_TCHAR\fR *filename, int flags = O_RDWR | O_CREAT, int mode = ACE_DEFAULT_FILE_PERMS, LPSECURITY_ATTRIBUTES sa = 0)"
.br
.RI "\fIOpen the file without mapping it.\fR"
.ti -1c
.RI "int \fBclose\fR (void)"
.br
.RI "\fIClose down the <handle_> if necessary and unmap the mapping.\fR"
.ti -1c
.RI "int \fBclose_handle\fR (void)"
.br
.RI "\fIClose down the <handle_> if necessary.\fR"
.ti -1c
.RI "int \fBclose_filemapping_handle\fR (void)"
.br
.ti -1c
.RI "int \fBoperator()\fR (void *&addr)"
.br
.RI "\fIThis operator passes back the starting address of the mapped file.\fR"
.ti -1c
.RI "void* \fBaddr\fR (void) const"
.br
.RI "\fIReturn the base address.\fR"
.ti -1c
.RI "size_t \fBsize\fR (void) const"
.br
.RI "\fIThis function returns the number of bytes currently mapped in the file.\fR"
.ti -1c
.RI "int \fBunmap\fR (int len = -1)"
.br
.RI "\fIUnmap the region starting at <base_addr_>.\fR"
.ti -1c
.RI "int \fBunmap\fR (void *addr, int len)"
.br
.RI "\fIUnmap the region starting at .\fR"
.ti -1c
.RI "int \fBsync\fR (\fBssize_t\fR len = -1, int flags = MS_SYNC)"
.br
.ti -1c
.RI "int \fBsync\fR (void *addr, size_t len, int flags = MS_SYNC)"
.br
.RI "\fISync <len> bytes of the memory region to the backing store starting at .\fR"
.ti -1c
.RI "int \fBprotect\fR (\fBssize_t\fR len = -1, int prot = PROT_RDWR)"
.br
.ti -1c
.RI "int \fBprotect\fR (void *addr, size_t len, int prot = PROT_RDWR)"
.br
.RI "\fIChange the protection of the pages of the mapped region to <prot> starting at  up to <len> bytes.\fR"
.ti -1c
.RI "int \fBremove\fR (void)"
.br
.RI "\fIClose and remove the file from the file system.\fR"
.ti -1c
.RI "int \fBadvise\fR (int behavior, int len = -1)"
.br
.RI "\fIHook into the underlying VM system.\fR"
.ti -1c
.RI "ACE_HANDLE \fBhandle\fR (void) const"
.br
.RI "\fIReturn the underlying <handle_>.\fR"
.ti -1c
.RI "const \fBACE_TCHAR\fR* \fBfilename\fR (void) const"
.br
.RI "\fIReturn the name of file that is mapped (if any).\fR"
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Private Methods

.in +1c
.ti -1c
.RI "int \fBmap_it\fR (ACE_HANDLE handle, int len = -1, int prot = PROT_RDWR, int share = MAP_SHARED, void *addr = 0, off_t offset = 0, LPSECURITY_ATTRIBUTES sa = 0)"
.br
.RI "\fIThis method does the dirty work of actually calling mmap to map the file into memory.\fR"
.ti -1c
.RI "\fBACE_Mem_Map\fR (const ACE_Mem_Map &)"
.br
.ti -1c
.RI "void \fBoperator=\fR (const ACE_Mem_Map &)"
.br
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "void* \fBbase_addr_\fR"
.br
.RI "\fIBase address of the memory-mapped file.\fR"
.ti -1c
.RI "\fBACE_TCHAR\fR \fBfilename_\fR [MAXPATHLEN + 1]"
.br
.RI "\fIName of the file that is mapped.\fR"
.ti -1c
.RI "size_t \fBlength_\fR"
.br
.RI "\fILength of the mapping.\fR"
.ti -1c
.RI "ACE_HANDLE \fBhandle_\fR"
.br
.RI "\fIHANDLE for the open file.\fR"
.ti -1c
.RI "ACE_HANDLE \fBfile_mapping_\fR"
.br
.RI "\fIHANDLE for the open mapping.\fR"
.ti -1c
.RI "int \fBclose_handle_\fR"
.br
.RI "\fIKeeps track of whether we need to close the handle. This is set if we opened the file.\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 
C++ interface OS memory mapping system call.
.PP
.PP
 This class works with both the mmap(2) UNIX system and the Win32 family of memory mapping system calls. 
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS ACE_Mem_Map::ACE_Mem_Map (void)
.PP
Default constructor.
.PP
.SS ACE_Mem_Map::ACE_Mem_Map (ACE_HANDLE handle, int length = -1, int prot = PROT_RDWR, int share = ACE_MAP_PRIVATE, void * addr = 0, off_t offset = 0, LPSECURITY_ATTRIBUTES sa = 0)
.PP
Map a file from an open file descriptor <handle>. This function will lookup the length of the file if it is not given.
.PP
.SS ACE_Mem_Map::ACE_Mem_Map (const \fBACE_TCHAR\fR * filename, int len = -1, int flags = O_RDWR | O_CREAT, int mode = ACE_DEFAULT_FILE_PERMS, int prot = PROT_RDWR, int share = ACE_MAP_PRIVATE, void * addr = 0, off_t offset = 0, LPSECURITY_ATTRIBUTES sa = 0)
.PP
Map a file specified by <file_name>.
.PP
.SS ACE_Mem_Map::~ACE_Mem_Map (void)
.PP
Destructor.
.PP
.SS ACE_Mem_Map::ACE_Mem_Map (const ACE_Mem_Map &)\fC [private]\fR
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS void * ACE_Mem_Map::addr (void) const
.PP
Return the base address.
.PP
.SS int ACE_Mem_Map::advise (int behavior, int len = -1)
.PP
Hook into the underlying VM system.
.PP
.SS int ACE_Mem_Map::close (void)
.PP
Close down the <handle_> if necessary and unmap the mapping.
.PP
.SS int ACE_Mem_Map::close_filemapping_handle (void)
.PP
Close down the internal <file_mapping_> if necessary. This is mostly necessary on Win32, which has a different handle for file-mapping kernel object. 
.SS int ACE_Mem_Map::close_handle (void)
.PP
Close down the <handle_> if necessary.
.PP
.SS void ACE_Mem_Map::dump (void) const
.PP
Dump the state of an object.
.PP
.SS const \fBACE_TCHAR\fR * ACE_Mem_Map::filename (void) const
.PP
Return the name of file that is mapped (if any).
.PP
.SS ACE_HANDLE ACE_Mem_Map::handle (void) const
.PP
Return the underlying <handle_>.
.PP
.SS int ACE_Mem_Map::map (const \fBACE_TCHAR\fR * filename, int len = -1, int flags = O_RDWR | O_CREAT, int mode = ACE_DEFAULT_FILE_PERMS, int prot = PROT_RDWR, int share = ACE_MAP_PRIVATE, void * addr = 0, off_t offset = 0, LPSECURITY_ATTRIBUTES sa = 0)
.PP
Map a file specified by <filename>.
.PP
.SS int ACE_Mem_Map::map (int length = -1, int prot = PROT_RDWR, int share = ACE_MAP_PRIVATE, void * addr = 0, off_t offset = 0, LPSECURITY_ATTRIBUTES sa = 0)
.PP
Remap the file associated with <handle_>.
.PP
.SS int ACE_Mem_Map::map (ACE_HANDLE handle, int length = -1, int prot = PROT_RDWR, int share = ACE_MAP_PRIVATE, void * addr = 0, off_t offset = 0, LPSECURITY_ATTRIBUTES sa = 0)
.PP
Map a file from an open file descriptor <handle>. This function will lookup the length of the file if it is not given.
.PP
.SS int ACE_Mem_Map::map_it (ACE_HANDLE handle, int len = -1, int prot = PROT_RDWR, int share = MAP_SHARED, void * addr = 0, off_t offset = 0, LPSECURITY_ATTRIBUTES sa = 0)\fC [private]\fR
.PP
This method does the dirty work of actually calling mmap to map the file into memory.
.PP
.SS int ACE_Mem_Map::open (const \fBACE_TCHAR\fR * filename, int flags = O_RDWR | O_CREAT, int mode = ACE_DEFAULT_FILE_PERMS, LPSECURITY_ATTRIBUTES sa = 0)
.PP
Open the file without mapping it.
.PP
.SS int ACE_Mem_Map::operator() (void *& addr)
.PP
This operator passes back the starting address of the mapped file.
.PP
.SS void ACE_Mem_Map::operator= (const ACE_Mem_Map &)\fC [private]\fR
.PP
.SS int ACE_Mem_Map::protect (void * addr, size_t len, int prot = PROT_RDWR)
.PP
Change the protection of the pages of the mapped region to <prot> starting at  up to <len> bytes.
.PP
.SS int ACE_Mem_Map::protect (\fBssize_t\fR len = -1, int prot = PROT_RDWR)
.PP
Change the protection of the pages of the mapped region to <prot> starting at <base_addr_> up to <len> bytes. If <len> == -1 then change protection of all pages in the mapped region. 
.SS int ACE_Mem_Map::remove (void)
.PP
Close and remove the file from the file system.
.PP
.SS size_t ACE_Mem_Map::size (void) const
.PP
This function returns the number of bytes currently mapped in the file.
.PP
.SS int ACE_Mem_Map::sync (void * addr, size_t len, int flags = MS_SYNC)
.PP
Sync <len> bytes of the memory region to the backing store starting at .
.PP
.SS int ACE_Mem_Map::sync (\fBssize_t\fR len = -1, int flags = MS_SYNC)
.PP
Sync <len> bytes of the memory region to the backing store starting at <base_addr_>. If <len> == -1 then sync the whole region. 
.SS int ACE_Mem_Map::unmap (void * addr, int len)
.PP
Unmap the region starting at .
.PP
.SS int ACE_Mem_Map::unmap (int len = -1)
.PP
Unmap the region starting at <base_addr_>.
.PP
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS ACE_Mem_Map::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
.SS void * ACE_Mem_Map::base_addr_\fC [private]\fR
.PP
Base address of the memory-mapped file.
.PP
.SS int ACE_Mem_Map::close_handle_\fC [private]\fR
.PP
Keeps track of whether we need to close the handle. This is set if we opened the file.
.PP
.SS ACE_HANDLE ACE_Mem_Map::file_mapping_\fC [private]\fR
.PP
HANDLE for the open mapping.
.PP
.SS \fBACE_TCHAR\fR ACE_Mem_Map::filename_[MAXPATHLEN+1]\fC [private]\fR
.PP
Name of the file that is mapped.
.PP
.SS ACE_HANDLE ACE_Mem_Map::handle_\fC [private]\fR
.PP
HANDLE for the open file.
.PP
.SS size_t ACE_Mem_Map::length_\fC [private]\fR
.PP
Length of the mapping.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.