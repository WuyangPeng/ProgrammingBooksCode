.TH ACE_RW_Process_Mutex 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_RW_Process_Mutex \- Wrapper for readers/writer locks that exist across processes. 
.SH SYNOPSIS
.br
.PP
\fC#include <RW_Process_Mutex.h>\fR
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_RW_Process_Mutex\fR (const \fBACE_TCHAR\fR *name = 0, int flags = O_CREAT|O_RDWR)"
.br
.RI "\fICreate a readers/writer <Process_Mutex>, passing in the optional <name>.\fR"
.ti -1c
.RI "\fB~ACE_RW_Process_Mutex\fR (void)"
.br
.ti -1c
.RI "int \fBremove\fR (void)"
.br
.ti -1c
.RI "int \fBacquire\fR (void)"
.br
.RI "\fIAcquire lock ownership (wait on queue if necessary).\fR"
.ti -1c
.RI "int \fBtryacquire\fR (void)"
.br
.ti -1c
.RI "int \fBrelease\fR (void)"
.br
.RI "\fIRelease lock and unblock a thread at head of queue.\fR"
.ti -1c
.RI "int \fBacquire_read\fR (void)"
.br
.RI "\fIAcquire lock ownership (wait on queue if necessary).\fR"
.ti -1c
.RI "int \fBacquire_write\fR (void)"
.br
.RI "\fIAcquire lock ownership (wait on queue if necessary).\fR"
.ti -1c
.RI "int \fBtryacquire_read\fR (void)"
.br
.ti -1c
.RI "int \fBtryacquire_write\fR (void)"
.br
.ti -1c
.RI "int \fBtryacquire_write_upgrade\fR (void)"
.br
.RI "\fIAttempt to upgrade a read lock to a write lock. Returns 0 on success, -1 on failure.\fR"
.ti -1c
.RI "const \fBACE_File_Lock\fR& \fBlock\fR (void) const"
.br
.RI "\fIReturn the underlying lock.\fR"
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "\fBACE_File_Lock\fR \fBlock_\fR"
.br
.RI "\fIWe need this to get the readers/writer semantics...\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 
Wrapper for readers/writer locks that exist across processes.
.PP
.PP
 Note that because this class uses the  as its implementation it only can be reliably used between separate processes, rather than threads in the same process. This isn't a limitation of \fBACE\fR, it's simply the file lock semantics on UNIX and Win32. 
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS ACE_RW_Process_Mutex::ACE_RW_Process_Mutex (const \fBACE_TCHAR\fR * name = 0, int flags = O_CREAT|O_RDWR)
.PP
Create a readers/writer <Process_Mutex>, passing in the optional <name>.
.PP
.SS ACE_RW_Process_Mutex::~ACE_RW_Process_Mutex (void)
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS int ACE_RW_Process_Mutex::acquire (void)
.PP
Acquire lock ownership (wait on queue if necessary).
.PP
.SS int ACE_RW_Process_Mutex::acquire_read (void)
.PP
Acquire lock ownership (wait on queue if necessary).
.PP
.SS int ACE_RW_Process_Mutex::acquire_write (void)
.PP
Acquire lock ownership (wait on queue if necessary).
.PP
.SS void ACE_RW_Process_Mutex::dump (void) const
.PP
Dump the state of an object.
.PP
.SS const \fBACE_File_Lock\fR & ACE_RW_Process_Mutex::lock (void) const
.PP
Return the underlying lock.
.PP
.SS int ACE_RW_Process_Mutex::release (void)
.PP
Release lock and unblock a thread at head of queue.
.PP
.SS int ACE_RW_Process_Mutex::remove (void)
.PP
Explicitly destroy the mutex. Note that only one thread should call this method since it doesn't protect against race conditions. 
.SS int ACE_RW_Process_Mutex::tryacquire (void)
.PP
Conditionally acquire lock (i.e., don't wait on queue). Returns -1 on failure. If we "failed" because someone else already had the lock, <errno> is set to <EBUSY>. 
.SS int ACE_RW_Process_Mutex::tryacquire_read (void)
.PP
Conditionally acquire a lock (i.e., won't block). Returns -1 on failure. If we "failed" because someone else already had the lock, <errno> is set to <EBUSY>. 
.SS int ACE_RW_Process_Mutex::tryacquire_write (void)
.PP
Conditionally acquire a lock (i.e., won't block). Returns -1 on failure. If we "failed" because someone else already had the lock, <errno> is set to <EBUSY>. 
.SS int ACE_RW_Process_Mutex::tryacquire_write_upgrade (void)
.PP
Attempt to upgrade a read lock to a write lock. Returns 0 on success, -1 on failure.
.PP
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS ACE_RW_Process_Mutex::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
.SS \fBACE_File_Lock\fR ACE_RW_Process_Mutex::lock_\fC [private]\fR
.PP
We need this to get the readers/writer semantics...
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.