<!doctype linuxdoc system>

<article>

<!--<title> How to add an (S)VGA driver to XFree86-->
<title> XFree86 へ (S)VGA ドライバを追加する方法
<author> Copyright (c) 1993, 1994 David E. Wexelblat
  <tt/&lt;dwex@XFree86.org&gt;/
<date> 1.3 号 - 1994 年 5 月 29 日
<trans> 岡本　一幸 Kazuyuki Okamoto &lt;ikko-@pacific.rim.or.jp&gt;
<tdate> 1996 年 01 月 07 日
<toc>
<!-- ....1.........2.........3.........4.........5.........6...... -->

<!--<sect> Introduction <p>-->
<sect> 序文 <p>
<!--Adding support for a new SVGA chipset to XFree86 is a challenging project 
for someone who wants to learn more about hardware-level programming.  It 
can be fraught with hazards (in particular, crashing the machine is all too 
common).  But in the end, when the server comes up and functions, it is
immensely satisfying.-->
XFree86 に新しい SVGA チップセットのサポートを追加することはハードウェ
アに密着したプログラミングについて学習したい人にとって手ごたえのある
作業です。このような作業には危険が一杯です。特に、マシンがハングアッ
プしてしまうようなことは日常茶飯事です。それでも最終的に、サーバーが
立ち上がってうまく動いてくれた時は、底知れぬ満足感にひたれます。

<!--Adding support for an SVGA chipset does not change any of the basic 
functioning of the server.  It is still a dumb 8-bit PseudoColor server or 
1-bit StaticGray server.  Adding support for new hardware (e.g. accelerated 
chips) is a major undertaking, and is not anywhere near formalized enough yet 
that it can be documented.-->
SVGA チップセット対応のドライバを追加することはサーバーの基本機能を
変更するものではありません。ただ、256 色同時発色のカラーサーバーか
モノクロサーバーが出来るだけです。新しいハードウェア（例えばアクセ
ラレータチップ）を追加することは重要な仕事で、文書化出来るような定
型的作業には程遠いものです。

<!--Nonetheless, the driver-level programming here is a good introduction.  And 
can well be the first step for adding support for an accelerated chipset, as 
many are SVGA-supersets.  Writing an SVGA-level driver for the chipset can 
provide a stable development platform for making use of new features (in fact,
this has been done for the S3, Cirrus, and WD accelerated chipsets, for 
internal use as the accelerated servers are developed for XFree86 2.0).-->
それにもかかわらず、ここで行うドライバを書くようなプログラミングは
良い入門となります。アクセラレータチップセットを追加する最初の段階
では SVGA の上位互換としてのドライバを追加するのが良いでしょう。該
当するチップ対応の SVGA のドライバーを書くことは新しい機能を追加す
るときの安定した開発環境を構築することになります（実際、XFree86 2.0 
対応に内部で開発された S3, Cirrus や WD のアクセタレータチップセッ
トのドライバではそうでした）。

<!--Now let's get down to it.  In addition to this documentation, a stub
driver has 
been provided.  This should provide you a complete framework for your new 
driver.  Don't let the size of this document persuade you that this is an
overly difficult task.  A lot of work has been put into making this document
as close to complete as possible; hence it should, in theory, be possible to
use this as a cookbook, and come out with a working driver when you reach the
end.  I do advise that you read it all the way through before starting.-->
さあ、例題のソースを手にいれましょう。この文書に加えて、スタブド
ライバを提供します。これは新しいドライバの徹底した骨組みとして提供
するものです。この文書が大きいからといって作業が過度に難しいと思わ
ないでください。殆どの作業を出来る限りこの文書に沿って進めるならば、
今晩のうちに理論的にはこの文書を料理の本のように使い、最後には動く
ドライバが出来るでしょう。

<!--<sect> Getting Started <p>-->
<sect> 始めに <p>
<!--The first step in developing a new driver is to get the documentation for 
your chipset.  I've included a list of vendor contact information that I have 
collected so far (it's far from complete, so if you have any that isn't on 
the list, please send it to me).  You need to obtain the databook for the 
chipset.  Make sure that the person you speak to is aware that you intend to 
do register-level programming (so they don't send you the EE-style datasheet).
Ask for any example code, or developer's kits, etc.  I've learned that at the 
SVGA level, in general, a databook that lists and describes the registers is 
the most you can hope to find.-->
新しいドライバを作る最初の段階はそのチップセットに関する資料を集め
ることです。わたしの集めたベンダーの連絡先情報の一覧をこの文書に入
れています（完璧とは言えないものですのでこの一覧に無いもので知って
いるものがありましたら著者まで送ってください）。チップセットのデー
タブックを手に入れる必要があります。レジスタを直接操作するプログラ
ミングがしたいとベンダーの人と話す機会に確認して下さい。（そうしな
いと EE 形式のデータシートを送付してくれません）。何かサンプルプロ
グラムか開発者用のキット等について問い合わせてください。著者が一般
的な SVGA について詳しく学習したときは、レジスタについて知りたい
殆どの事がデータシートに一覧や記事にありました。

<!--If you are not familiar with VGA register-level programming, you should get 
(and read!) a copy of Richard Ferraro's bible (see references below).  The 
best way to understand what is happening in the server is to study the 
workings of the monochrome server's ``generic'' server, and compare it with 
the documentation in Ferraro's book (be aware that there are a few errors 
in the book).  You can find the generic-VGA-register handling functions in 
the file ``vgaHW.c''.-->
VGA レジスタを直接操作するようなプログラミングに慣れていない場合は
Richard Ferraro の必読書を入手して（是非読んで！）下さい（以降の
「参考文献」を見てください）。サーバーで何が起っているかを理解する
最良の方法はモノクロの ``generic'' サーバーの動作を調べ、Ferraro 
の本に書かれている情報と比較して下さい（本に少し間違いがあることに
気付くでしょう）。generic な VGA レジスタを扱う関数を ``vgaHW.c'' 
ファイルに見つけることが出来ます。

<!--Once you understand what's happening in the generic server, you should
study 
one or more of the existing SVGA drivers.  Obtain the databook for a supported
SVGA chipset, and study the documentation along with the code.  When you have 
a good understanding of what that driver does over and above the generic VGA, 
you will know what information you need to obtain from the databook for the 
new chipset.  Once you have this information, you are ready to begin work on 
your new driver.-->
generic なサーバーで何が起っているか理解したら、一つかそれ以上の既
存の SVGA サーバーについて調べてください。サポートしている SVGA チッ
プのデータブックを入手してプログラムを追いながら文書を調査してくだ
さい。generic な VGA から何が仕様を超えていて何が仕様に収まっている
か良く理解したら、新しいチップについてデータブックからどんな情報を得
ればよいか分かるでしょう。この情報を収集したら、新しいドライバーに取
りかかる準備が出来ました。

<!--<sect> Directory Tree Structure <p>-->
<sect> ディレクトリ構造 <p>
<!--Here is an outline of the directory tree structure for the source tree.
Only directories/files that are relevant to writing a driver are presented.
The structure for the Link Kit is presented below.-->
ここではソースのディレクトリ構造の概要を説明します。書こうとしてい
るドライバに関連するディレクトリ／ファイルは既知とします。リンクキッ
トの構造は以降で示します。

<descrip>
<tag>xc/config/cf/</tag>
        <descrip>
        <tag>site.def</tag>
<!--            Local configuration customization-->
                ローカルな構成のカスタマイズ
        <tag>xf86site.def</tag>
<!--            XFree86 local configuration customization-->
                XFree86 のローカルな構成のカスタマイズ
        </descrip>

<tag>xc/programs/Xserver/hw/xfree86/</tag>
<!--    The server source-->
        サーバーのソース
        <descrip>
        <tag>common/</tag>
<!--                    Files common to all of the server (XF86Config
                        parser, I/O device handlers, etc)-->
                        全サーバーに共通なファイル (XF86Config のパラメータ
                                解析/パーサ, I/O デバイスハンドラ等)
                <descrip>
                <tag>xf86.h</tag>
<!--                    Contains the `ScrnInfoRec' data structure-->
                        `ScrnInfoRec' データ構造を含む
                <tag>xf86_Option.h</tag>
<!--                    Contains option flags-->
                        オプションフラグを含む
                <tag>compiler.h</tag>
<!--                    Contains in-line assembler macros and
                                utility functions-->
                        インラインアセンブラマクロと
                                ユーティリティ関数を含む
                </descrip>
<!--    <tag>os-support/</tag>          OS-support layer-->
        <tag>os-support/</tag>          OS サポート層
                <descrip>
                <tag>assyntax.h</tag>
<!--                    Contains macro-ized assembler mnemonics-->
                        マクロ化したアセンブラニモニックを含む
                <tag>xf86_OSlib.h</tag>
<!--                    OS-support includes, defines, and prototypes-->
                        OS がサポートする include, define と プロトタイプ
                </descrip>
        <tag>LinkKit/</tag>
                <descrip>
                <tag>site.def.LK</tag>
<!--                    Template for Link Kit site.def-->
                        リンクキットの site.def 用のテンプレート
                </descrip>
<!--    <tag>vga256/</tag>                      256-color VGA server directories-->
        <tag>vga256/</tag>                      256 色 VGA サーバーのディレクトリ
                <descrip>
                <tag>vga/</tag>
<!--                            The generic VGA handling code-->
                                generic な VGA を取り扱うプログラム
                        <descrip>
                        <tag>vga.h</tag>
<!--                            Contains the `vgaVideoChipRec' and `vgaHWRec'
                                data structures-->
                                `vgaVideoChipRec' と `vgaHWRec' データ構造を
                                含む
                        <tag>vgaHW.c</tag>
<!--                            Contains the generic-VGA-register handling
                                functions <bf>vgaHWInit()</bf>,
                                <bf>vgaHWSave()</bf> and 
                                <bf>vgaHWRestore()</bf>.-->
                                generic な VGA レジスタを取り扱う関数
                                <bf>vgaHWInit()</bf>,
                                <bf>vgaHWSave()</bf> と 
                                <bf>vgaHWRestore()</bf>を含む。
                        </descrip>
<!--            <tag>drivers/</tag>     Contains the SVGA driver subdirectories.-->
                <tag>drivers/</tag>     SVGA ドライバのサブディレクトリを含む。
<!--                            Each contains an Imakefile, a .c file for
                                the driver, and a .s file for the bank-
                                switching functions.-->
                                各々、ドライバ用 Imakefile, .c ファイルと
                                バンク切り替え関数用の .s ファイルを含む
                </descrip>
        <tag>vga2/</tag>
<!--                            The monochrome vga server directories.  Most of
                                the files are linked from vga256, and the
                                differences handled by conditional compilation.-->
                                モノクロの vga サーバーのディレクトリ。vga256 に
                                リンクするファイルと条件コンパイルで使用する差分。
                <descrip>
                <tag>drivers/</tag>
<!--                            The SVGA driver subdirectories.  The `generic'
                                VGA driver is also located here.-->
                                SVGA ドライバのサブディレクトリ。`generic' な VGA
                                ドライバもここに配置する。
                </descrip>
        <tag>vga16/</tag>
<!--                            The 16-color vga server directories.  Most of
                                the files are linked from vga256, and the
                                differences handled by conditional compilation.-->
                                16 色 vga サーバーのディレクトリ。vga256 
                                にリンクする殆どのファイルと条件コンパイルで
                                使用する差分。
                <descrip>
<!--            <tag>drivers/</tag>     The SVGA driver subdirectories.-->
                <tag>drivers/</tag>     SVGA ドライバのサブディレクトリ。
                </descrip>
<!--    <tag>VGADriverDoc/</tag>                This documentation and the stub driver.-->
        <tag>VGADriverDoc/</tag>                この文書とスタブドライバ。
        </descrip>
</descrip>
<!--The Link Kit is usually installed in /usr/X11R6/lib/Server.-->
リンクキットは通常 /usr/X11R6/lib/Server に導入します。
<!--The Link Kit
contains everything that is needed to relink the server.  It is possible
to write a new driver and build a new server without having even the server
source installed.-->
リンクキットはサーバーの再リンクを行うのに必要な全てのものが含まれ
ています。新しいドライバを書くのとサーバーのソースの導入なしに新し
いサーバーを生成するのに必要です。
<descrip>
<tag>Server/</tag>
        <descrip>
        <tag>site.def</tag>
<!--            Local configuration customization-->
                ローカルな構成のカスタマイズ
        <tag>include/</tag>
<!--            All of the include files listed under the
                `common' directory above-->
                上記 `common' ディレクトリ下にある全ての include ファイル
        <tag>drivers/</tag>
<!--            All of the SVGA drivers-->
                SVGA ドライバの全て
                <descrip>
<!--            <tag>vga2/</tag> The SVGA driver subdirectories.-->
                <tag>vga2/</tag> SVGA ドライバのサブディレクトリ。
<!--            <tag>vga16/</tag> The SVGA driver subdirectories.-->
                <tag>vga16/</tag> SVGA ドライバのサブディレクトリ。
<!--            <tag>vga256/</tag> The SVGA driver subdirectories.-->
                <tag>vga256/</tag> SVGA ドライバのサブディレクトリ。
                </descrip>
<!--    <tag>VGADriverDoc/</tag>                The directory with this documentation and
                                the stub driver.  `vgaHW.c' is also copied
                                here, for reference (it is not built as
                                part of the Link Kit).-->
        <tag>VGADriverDoc/</tag>                この文書とスタブドライバの
                                ディレクトリ。`vgaHW.c' はここにもコピーされ
                                参照されます（リンクキットの一部としては生成し
                                ません）。
        </descrip>
</descrip>
        
<!--<sect> Setting Up The Build Information <p>-->
<sect> 生成情報の設定 <p>
<!--  This section describes the peripheral configuration and build steps that
must be performed to set up for your new driver.  The steps are the same
whether you are building from the source tree of from the Link Kit; only
the locations of the files is different.  Here are the configuration steps
that must be followed:-->
この節では新しいドライバ用設定を行なう為の周辺の構成変更と生成段階
について説明します。この段階ではソースから生成するかリンクキットか
ら生成するかにかかわらず同様で、ただファイルの配置が異なっているだ
けのことです。以下に構成変更について説明します:

<enum>
<!--<item>       Choose the name for your driver subdirectory and data structures.
   Since the current driver scheme allows (in fact, encourages)
           putting drivers for multiple related chipsets in a single driver,
           it is usually best to use the vendor name, rather than a chipset
           version.  The fact that older XFree86 drivers do not follow this
           convention should not deter you from using it now - most of that
           code was developed before the driver interface had been made
           flexible and extensible.-->
<item>   ドライバのサブディレクトリとデータ構造を決定して下さい。
           単一のドライバ内にそのチップセットに関連する複数のドライバ
           を実装することが現状のドライバに許されるならば（実際には奨
           励されています）、通常チップセットのバージョンよりはベンダー
           名称を使用するのが良いでしょう。昔の XFree86 のドライバはこ
           の慣習を採用していなかったですが現在は殆どのドライバがドライ
           バのインターフェースを柔軟且つ拡張可能になるようにこの慣習
           を使用していますのでベンダー名称を使いましょう。

<!--       For this documentation, we'll use chips from the SuperDuper Chips
           vendor.  Hence, we'll use `sdc' for the name of the driver.-->
           この文書では SuperDuper Chips というベンダーを例に取り挙げ
           ます。以降、ドライバの名称に `sdc' を用います。

<!--<item>       Decide whether your driver will support the color server, the
           monochrome server, or both.  For this documentation, we will
           assume that both the color and monochrome servers will be
           supported.  If you intend to support only the color server, the
           steps for the monochrome server can be ignored.  If you intend
           to support only the monochrome server, the steps for the color
           server listed should be performed for the monochrome server,
           and the monochrome steps ignored.  Most of the existing drivers
           support only the color or both servers; the ``generic'' driver is
           the only driver (currently) that supports just the monochrome
           server.-->
<item>   カラーサーバーをサポートするかモノクロサーバーをサポートす
           るか又は両方サポートするのか決定してください。この文書では、
           カラーとモノクロ両方のサーバーをサポートするように仮定してい
           ます。カラーサーバーだけをサポートしたいと思う場合はモノクロ
           のサーバーを実現する段階を無視してください。モノクロサーバー
           だけをサポートしたい場合はカラーサーバーの段階で一覧にある可
           能なモノクロサーバーを実現させ、モノクロサーバーの段階は無視
           してください。現存する殆どのドライバーはカラーのみか、両方の
           サーバーをサポートしていて、``generic'' なドライバーは（現在
           は）モノクロサーバーをサポートしています。

<!--<item>       Create your driver directories:-->
<item>   ドライバーのディレクトリを作成してください:

         <itemize>
<!--     <item>   If you are working in the source tree, create the
                  following directories:-->
         <item>   ソースから作業する場合は、次のディレクトリを作成
                してください:

<verb>
   xc/programs/Xserver/hw/xfree86/vga256/drivers/sdc
   xc/programs/Xserver/hw/xfree86/vga16/drivers/sdc
   xc/programs/Xserver/hw/xfree86/vga2/drivers/sdc
</verb>

<!--    <item>    If you are working in the Link Kit, create the
                  following directories:-->
        <item>    リンクキットから作業する場合は次のディレクトリを
                作成してください:

                        
<verb>
   /usr/X11R6/lib/Server/drivers/vga256/sdc
   /usr/X11R6/lib/Server/drivers/vga16/sdc
   /usr/X11R6/lib/Server/drivers/vga2/sdc
</verb>
         </itemize>

<!--<item>       Set up the Imakefile parameters to cause your driver to be
           built:-->
<item>   ドライバーを生成する為の Imakefiel パラメタを設定しましょう:

         <itemize>
<!--     <item>    If you are working in the source tree:-->
         <item>    ソースから作業するなら:
                   <enum>
<!--               <item>  Edit the file xc/config/cf/xfree86.cf,
                           and add 
                           `sdc' to the list for the definitions for 
                           `XF86Vga256Drivers', `XF86Vga16Drivers' and
                           `XF86Vga2Drivers'.
                           You should put `sdc' just before `generic' in the
                           list (i.e. second last), to ensure that none of the
                           other driver's probe functions incorrectly detect
                           the `sdc' chipset .-->
                   <item>  xc/config/cf/xfree86.cf を編集して `sdc' を
                           `XF86Vga256Drivers', `XF86Vga16Drivers' と
                           `XF86Vga2Drivers' の定義の一覧に追加してください。
                           一覧の `generic' の直前（例えば最後から二番目）に
                           `sdc' を追加し `sdc' を他のドライバーの探査が不正
                           に `sdc' チップセットを検知しないようにしてくださ
                           い。
<!--               <item>  Edit the file xc/config/cf/xf86site.def,
                           and add
                           the same entries in this file (this is just a
                           comment that shows the default values).-->
                   <item>  xc/config/cf/xf86site.def を編集してこのファイ
                           ルにいくつかの項目を追加してください（これは標準値の
                           設定の作業です）。
<!--               <item>  Edit the site.def.LK file in
                           xc/programs/Xserver/hw/xfree86/LinkKit/,
                           and add the same entries in this file.  This is
                           the prototype `site.def' file that will be
                           installed in the Link Kit.-->
                   <item>  xc/programs/Xserver/hw/xfree86/LinkKit/ にある
                           site.def.LK ファイルを編集してこのファイルにいくつか
                           の項目を追加してください。これはリンクキットに含まれ
                           る `site.def' ファイルの雛型です。
                   </enum>
                
<!--    <item>    If you are working in the Link Kit, edit the file
                  /usr/X11R6/lib/Server/site.def, and add `sdc' to
                  the `XF86Vga256Drivers', `XF86Vga16Drivers' and
                  `XF86Vga2Drivers' definitions as described in (a) above.-->
        <item>リンクキットから作業をするなら、/usr/X11R6/lib/Server/site.def
                  を編集して`sdc' を `XF86Vga256Drivers', `XF86Vga16Drivers' と
                  `XF86Vga2Drivers' の定義に最初に書いた様に追加してください。
         </itemize>
<!--<item>       Now copy the prototype files into your new directories:-->
<item>   さて新しいディレクトリに雛型のファイルをコピーしましょう:
         <itemize>
<!--     <item> If you are working in the source tree, copy the `stub' 
                  files as follows (directories are below xc/programs/Xserver):-->
         <item> ソースから作業するなら、`stub' ファイルを次のようにコピー
                してください（ディレクトリは xc/programs/Xserver の下です）:
                <descrip>
                <tag>Imakefile.stub =&gt;</tag>
                    hw/xfree86/vga256/drivers/sdc/Imakefile
                <tag>stub_driver.c =&gt;</tag>
                    hw/xfree86/vga256/drivers/sdc/sdc_driver.c
                <tag>stub_bank.s =&gt;</tag>
                    hw/xfree86/vga256/drivers/sdc/sdc_bank.s
                <tag>Imakefile.stub =&gt;</tag>
                    hw/xfree86/vga16/drivers/sdc/Imakefile
<!--                  (then edit this Imakefile and make the changes
                       described in the comments).-->
                      （そして Imakefile を編集してコメントに従って
                      変更してください）。
                <tag>Imakefile.stub =&gt;</tag>
<!--                hw/xfree86/vga2/drivers/sdc/Imakefile
                      (then edit this Imakefile and make the changes
                       described in the comments).-->
                      （そして Imakefile を編集してコメントに従って
                      変更してください）。
                </descrip>
<!--      <item>  If you are working in the Link Kit, copy the `stub' files
                  as follows:-->
         <item> リンクキットから作業するなら、`stub' ファイルを次のよう
            にコピーしてください:
                <descrip>
                <tag>Imakefile.stub =&gt; </tag>
                  /usr/X11R6/lib/Server/drivers/vga256/sdc/Imakefile
                <tag>stub_driver.c =&gt; </tag>
                  /usr/X11R6/lib/Server/drivers/vga256/sdc/sdc_driver.c
                <tag>stub_bank.s =&gt; </tag>
                  /usr/X11R6/lib/Server/drivers/vga256/sdc/sdc_bank.s
                <tag>Imakefile.stub =&gt; </tag>
                  /usr/X11R6/lib/Server/drivers/vga16/sdc/Imakefile
<!--                 (then edit this Imakefile and make the changes
                      described in the comments).-->
                      （そして Imakefile を編集してコメントに従って
                      変更してください）。
                <tag>Imakefile.stub =&gt; </tag>
                  /usr/X11R6/lib/Server/drivers/vga2/sdc/Imakefile
<!--                 (then edit this Imakefile and make the changes
                      described in the comments).-->
                      （そして Imakefile を編集してコメントに従って
                      変更してください）。
                </descrip>
         </itemize>
<!--<item>       Edit each of the files you've just copied, and replace `stub'
           with `sdc' and `STUB' with `SDC' wherever they appear.-->
<item>  たった今コピーした各々のファイルを編集して `stub' を `sdc' 
に、`STUB' を `SDC' に全て置き換えてください。
</enum>
<!--That's all the prep work needed.  Now it's time to work on the actual
driver.-->
必要な準備作業は以上です。これで実際のドライバを作成する作業が出来
ます。

<!--<sect> The Bank-Switching Functions <p>-->
<sect> バンク切り替え機能 <p>
<!--The normal VGA memory map is 64k starting at address 0xA0000.  To access
more than 64k of memory, SuperVGA chipsets implement ``bank switching'' - 
the high-order address bits are used to select the bank of memory in which
operations will take place.  The size and number of these banks varies,
and will be spelled out in the chipset documentation.  A chipset will
have zero, one or two bank registers.  Likely the ONLY case of zero bank
registers is a generic VGA, and hence is not a concern.-->
普通の VGA メモリマップは 0xA0000 から始まる 64k です。64k より大き
なメモリにアクセスするには、``バンク切り替え機能(bank switching)'' 
- 高位のアドレスビットをメモリのバンク選択に使うような操作に置き換
える機能を実現しているSuperVGA チップセットが必要です。サイズと数の
バンクは変化し、その名称はチップセットの資料に記載されています。チッ
プセットはバンクレジスタ無しか一つか二つのバンクレジスタを持ってい
ます。バンクレジスタなしの場合は generic な VGA *だけ* ですので、関
係ありません。

<!--Note that some of the newer chipsets (e.g. Trident 8900CL, Cirrus) allow
for a linear mapping of the video memory.  While using such a scheme would
improve the performance of the server, it is not currently supported.  Hence
there is no way to use such features for a new chipset.-->
新しいチップセット（例えば Trident 8900CL, Cirrus製）はビデオメモリ
をリニアに割り当てる事が出来る事に注意してください。このやり方を使う
場合はサーバーの性能を向上させますが、現在はサポートしていません。故
に新しいチップセットのこの機能は使用出来ません。

<!--Most SVGA chipsets have two bank registers.  This is the most desirable 
structure (if any banking structure can be called ``desirable''), because 
data can be moved from one area of the screen to another with a simple 
`mov' instruction.  There are two forms of dual-banking - one where the 
two bank operations define a read-only bank and a write-only bank, and
one with two read/write windows.  With the first form, the entire SVGA
memory window is used for both read a write operations, and the two
bank registers determine which bank is actually used (e.g. ET3000, ET4000).
With the second form, the SVGA memory window is split into two read/write
banks, with each bank pointer being used to control one window.  In
this case, one window is used for read operations and the other for write
operations (e.g. PVGA1/Western Digital, Cirrus).-->
殆どの SVGA チップセットは二つのバンクレジスタを持っています。デー
タを画面のある領域から他の領域に単純に 'mov' 命令で移動出来るので
非常に望ましい構造です（どんなバンク構造も ``望ましい'' と呼んでい
ます）。二重化バンキング(dual-banking) は二つの方式があり、一方は
読み込み専用バンクと書き込み専用バンクの二つのバンク操作で、もう一
方は二つの書き込み／読み込み兼用窓です。最初の方式は全ての SVGA メ
モリ窓を読み込みと書き込み両方に使い、二つのバンクレジスタはどちら
のバンクを実際に使うのか（例えばET3000, ET4000 では）決定するのに
使用しています。二番目の方式では SVGA メモリ窓を読み込み／書き込み
可能な二つのバンクに分けどちらかのバンクポインタが一つの窓を制御す
るようになっています。この場合一つの窓が読み込み操作を行うときは他
の窓が書き込み操作を（例えば PVGA1/Western Digital, Cirrus では）行
うようになります。

<!--A chipset that has a single bank register uses that one bank for both
read and write access.  This is problematic, because copying information
from one part of the screen to another requires that the data be read in,
stored, and then written out.  Fortunately, the server is able to handle
both one-bank and two-bank chipsets; the determination of behavior is
defined by an entry in the driver data structure described below.-->
単一のバンクレジスタを持っているチップセットは一つのバンクへの読み
込みと書き込みの両方のアクセスを行います。画面の一部の情報を他の部
分へコピーする事はデータを読み込み、蓄え、それから書き出すという手
順が要求されるため困難です。幸運にも、サーバーは一つのバンクのチッ
プセットと二つのバンクのチップセットの両方を扱え、その挙動を次に説
明するドライバデータ構造の項目定義で決定します。

<!--A driver requires that three assembly-language functions be written, in
the file `<tt>sdc_bank.s</tt>'.
These functions set the read bank - <bf>SDCSetRead()</bf>,
the write bank - <bf>SDCSetWrite()</bf>, and set both banks -
<bf>SDCSetReadWrite()</bf>.
For a chipset with only one bank, all three will be declared as entry points
to the same function (see the ``tvga8900'' driver for an example).-->
ドライバには`<tt>sdc_bank.s</tt>' ファイル内の三つのアセンブラ言語
で書いてある関数が必要です。
これらの関数はバンク読み込み設定 - <bf>SDCSetRead()</bf>,
バンク書き込み - <bf>SDCSetWrite()</bf> と 両バンク設定 -
<bf>SDCSetReadWrite()</bf> です。
一つのバンクだけのチップセット用に三つ全ての関数の入り口点を同じ関
数に宣言できるでしょう(``tvga8900'' ドライバを例として参照してくだ
さい)。

<!--The functions are fairly simple - the bank number is passed to the function
in register &percnt;al.  The function will shift, bitmask, etc - whatever is 
required to put the bank number into the correct form - and then write
it to the correct I/O port.  For chipsets where the two banks are read-only
HERE
and write-only, the <bf>SetReadWrite()</bf> function will have to do this
twice - once 
for each bank.  For chipsets with two independent read/write windows, the
<bf>SetReadWrite()</bf> function should use the same bank as the
<bf>SetWrite()</bf> function.-->
関数はかなり単純で - バンク番号を関数の &percnt;al レジスタへ渡し、
関数はシフトやビットマスク等行い正しい形式でバンク番号をレジスタヘ
保存し、正しい I/O ポートへ書き込みます。二つのバンクが読み込み専
用と書き込み専用になっているチップセットの場合、一回づつ各々のバン
クに、計二回 <bf>SetReadWrite()</bf>関数を実行する必要があります。
二つの独立な読み込み／書き込み窓になっているチップセットの場合、
<bf>SetReadWrite()</bf> 関数を <bf>SetWrite()</bf> 関数の代わりに
同じバンクに実行するべきです。

<!--A special note - these functions MUST be written in the macroized assembler
format defined in the header file ``assyntax.h''.  This will ensure that
the correct assembler code will be generated, regardless of OS.  This
macroized format currently supports USL, GNU, and Intel assembler formats.-->
特別な注意として、これらの関数は ``assyntax.h'' ファイルに定義して
いるマクロアセンブラの書式で書く必要があります。これは OS に関係な
く正しいアセンブラコードを生成することを保証する為です。現在、この
マクロ形式は USL, GNU と インテルのアセンブラの書式をサポートしてい
ます。

<!--That's all there is to the banking functions.  Usually the chipset reference
will give examples of this code; if not, it is not difficult to figure out,
especially using the other drivers as examples.-->
以上がバンク機能に関する作業です。普通、チップセットの参考書がこの
プログラムの例題を掲載していますが、そうでない場合でも他のドライバ
の例を用いれば想像するのは難しくはありません。

<!--<sect> The Driver Itself <p>-->
<sect> ドライバ自身について <p>
<!--  Now it's time to get down to the real work - writing the major driver
functions in the files sdc_driver.c.  First, an overview of what the
responsibilities of the driver are:-->
さて、本来の作業である殆どのドライバの機能を sdc_driver.c ファイル
に書く段階に来ました。先ず、ドライバの主な機能の概要は次のとおり:

<enum>
<!--<item>         Provide a chipset-descriptor data structure to the server.  This
           data structure contains pointers to the driver functions and
           some data-structure initialization as well.-->
<item>     サーバーのチップセット記述子のデータ構造を提供します。
           このデータ構造はドライバ関数へのポインタといくつかのデータ
           構造の初期値も含みます。
<!--<item>         Provide a driver-local data structure to hold the contents of
           the chipset registers.  This data structure will contain a 
           generic part and a driver-specific part.  It is used to save the
           initial chipset state, and is initialized by the driver to put
           the chipset into different modes.-->
<item>     ドライバ固有のチップセットのレジスタのデータ構造を提供し
           ます。このデータ構造には一般的な部分とドライバ固有の部分があ
           ります。チップセットの初期状態を保存したり、他のモードにチッ
           プセットを変えるときに初期化するのに用います。
<!--<item>         Provide an identification function that the server will call to
           list the chipsets that the driver is capable of supporting.-->
<item>     ドライバがサポートしているチップセットの一覧を呼び出せる
           ような識別機能を提供します。
<!--<item>         Provide a probe function that will identify this chipset as
           different from all others, and return a positive response if
           the chipset this driver supports is installed, and a negative
           response otherwise.-->
<item>     他のチップセットと異なるということを認識してドライバが
           そのチップセットをサポートしインストールしてあれば正の応答
           をし、そうでなければ負の応答をする探査機能を提供します。
<!--<item>         Provide a function to select dot-clocks available on the board.-->
<item>     ボードで可能なドットクロックを選択する機能を提供します。
<!--<item>         Provide functions to save, restore, and initialize the driver-
           local data structure.-->
<item>     ドライバに依存するデータ構造を保存、回復、初期化する機能を
           提供します。
<!--<item>         Provide a function to set the starting address for display in
           the video memory.  This implements the virtual-screen for the
           server.-->
<item>     ビデオメモリ内にディスプレイの開始アドレスを設定する機能
           を提供します。これはサーバーに仮想スクリーンを実現します。
<!--<item>         Perhaps provide a function for use during VT-switching.-->
<item>     VT 切り替えを行う機能を提供するでしょう。
<!--<item>         Perhaps provide a function to check if each mode is suitable for
           the chipset being used.-->
<item>     モードがチップセットの使用する各々のモードに一致するか
           チェックする機能を提供するでしょう。
</enum>

<!--Before stepping through the driver file in detail, here are some important
issues:-->
詳細にドライバーのファイルを追いかける前に、重要な情報がここにあり
ます:

<enum>
<!--<item>         If your driver supports both the color and monochrome servers,
           you should take care of both cases in the same file.  Most things
           are the same - you can differentiate between the two with the
           MONOVGA <tt>&num;define</tt>.  If the 16 color server is supported,
           code specific to it can be enabled with the XF86VGA16
           <tt>&num;define</tt>.  In most cases  it is sufficient to put
           the following near the top of the stub_driver.c file:-->
<item>     ドライバがカラーとモノクロサーバーの両方をサポートする
           場合、一つのファイルに両方の事例が含まれていることに注意し
           てください。これらは殆ど同じですが、MONOVGA を 
           <tt>&num;define</tt> してある所で両者を区別することが出来ま
           す。16 色サーバーをサポートする場合、XF86VGA16 の 
           <tt>&num;define</tt> が有効になるようにプログラムに指定して
           ください。殆どの場合、次を stub_driver.c ファイルの先頭近く
           に指定する事で充分です。
<verb>
   #ifdef XF86VGA16
   #define MONOVGA
   #endif
</verb>

<!--<item>         The color server uses the SVGA's 8-bit packed-pixel mode.  Thes
           monochrome and vga16 servers uses the VGA's 16-color mode
           (4 bit-planes).  Only one plane is enabled for the monochrome
           server.-->
<item>     カラーサーバーは SVGA の 8-ビットパックトピクセルモード
           を使用します。モノクロと vga16 サーバーは VGA の 16-色モード
           （4 ビットプレーン）を使用します。モノクロサーバーでは 1 プ
           レーンだけ使用します。
           [ 訳注 : パックトピクセル： 1 ドットのピクセル（画面上の点）
           を表現するのに、連続した 8 ビットを 4 つ並べて表わす方式。
           4 ビットプレーン： 1 ドットを表わすのに、それぞれの色毎にプ
           レーンを持ち各プレーン上の連続しない 8 ビット 4 つを使って
           表わす方式。]
<!--<item>         It is possible for you to define your monochrome driver so that
           no bank-switching is done.  This is not particularly desirable,
           as it yields only 64k of viewing area.-->
<item>     バンク切り替えを使わないように、モノクロサーバーを設定
           できます。これは表示領域のメモリをたった 64k に出来る事以外
           は特に魅力的ではありません。
</enum>
<!--Keeping these things in mind, you need to find the registers from your
SVGA chipset that control the desired features.  In particular, registers
that control:-->
これらを踏まえて、所定の機能を制御するチップセットからレジスタを探
す必要があります。特に、レジスタは以下を制御します:
<enum>
<!--<item>         Clock select bits.  The two low-order bits are part of the
           standard Miscellaneous Output Register; most SVGA chipsets
           will include 1 or 2 more bits, allowing the use of 8 or 16
           discrete clocks.-->
<item>     クロック選択ビット。低位の 2 ビットは標準の（殆どの 
SVGA チップセットが 1 若くは 2 ビット以上持っている）周辺機器出力
レジスタ(Miscellaneous Output Register) の一部で、8 か 16 に分解し
たクロックを使うように設定します。
<!--<item>         Bank selection.  The SVGA chipset will have one or two registers
           that control read/write bank selection.-->
<item>     バンク選択。読み書きするバンク選択の制御を行うレジスタを
           SVGA チップセットは一つか二つ持っているでしょう。
<!--<item>         CRTC extensions.  The standard VGA registers don't have enough
           bits to address large displays.  So the SVGA chipsets have
           extension bits.-->
<item>     CRTC 機能拡張。標準的な VGA レジスタは大きな表示を行うのに十分なビッ
           ト数を持っていません。故に SVGA チップセットは拡張したビット数を持ってい
           ます。
<!--<item>         Interlaced mode.  Standard VGA does not support interlaced
           displays.  So the SVGA chipset will have a bit somewhere to
           control interlaced mode.  Some chipsets require additional
           registers to be set up to control interlaced mode-->
<item>     インターレースモード。標準的な VGA はインターレース表示
           をサポートしていません。故に SVGA チップセットはインターレー
           スモードを制御するビットを持っています。インターレースモード
           制御用の設定を行うレジスタを追加しているいくつかのチップセッ
           トがあります。
<!--<item>         Starting address.  The standard VGA only has 16 bits in which
           to specify the starting address for the display.  This restricts
           the screen size usable by the virtual screen feature.  The SVGA
           chipset will usually provide one or more extension bits.-->
<item>    開始アドレス。標準的な VGA だけは表示用メモリの開始アドレ
           スを指定するのに 16 ビットのアドレスを使います。これは仮想ス
           クリーン機能で使うスクリーンのサイズを制限します。SVGA チッ
           プセットは通常一つかそれ以上の拡張ビットを持っています。
<!--<item>         Lock registers.  Many SVGA chipset prevent modification of
           extended registers unless the registers are first ``unlocked''.
           You will need to disable protection of any registers you will
           need for other purposes.-->
<item>     レジスタロック。殆どの SVGA チップセットはレジスタを最初に
           ``unlocked'' にしない限り拡張レジスタの更新を防止します。
           何か意図を持ってレジスタの保護を無効にしたい時に必要になります。
<!--<item>         Any other facilities.  Some chipset may, for example, require
           that certain bits be set before you can access extended VGA
           memory (beyond the IBM-standard 256k).  Or other facilities;
           read through all of the extended register descriptions and see
           if anything important leaps out at you.-->
<item>     その他の機能。例えば、いくつかのチップセットが拡張 VGA 
           メモリを（IBM-標準の 265k を超えて）アクセスしたい時、正しい
           ビットを設定する必要があるでしょう。または全ての拡張レジスタ
           の内容を読み取るとか、目に留まった重要な何かを見る等の他の機
           能があるでしょう。
</enum>

<!--If you are fortunate, the chipset vendor will include in the databook some
tables of register settings for various BIOS modes.  You can learn a lot
about what manipulations you must do by looking at the various BIOS modes.-->
運がよければ、チップセットのベンダーのデータブックに様々な BIOS モー
ド用のレジスタの設定の表が掲載されているでしょう。様々な BIOS モード
でどんな操作が可能であるか学習することが出来ます。

<!--<sect1> Multiple Chipsets And Options <p>-->
<sect1> 複数のチップセットとオプション <p>
<!--It is possible, and in fact desirable, to have a single driver support
multiple chipsets from the same vendor.  If there are multiple supported
chipsets, then you would have a series of &num;define's for them, and a
variable `SDCchipset', which would be used throughout the driver when
distinctions must be made.  See the Trident and PVGA1/WD drivers for
examples (the Tseng ET3000 and ET4000 are counter-examples - these were
implemented before the driver interface allowed for multiple chipsets, so
this example should NOT be followed).  Note that you should only distinguish
versions when your driver needs to do things differently for them.  For
example, suppose the SDC driver supports the SDC-1a, SDC-1b, and SDC-2
chipsets.  The -1a and -1b are essentially the same, but different from the
-2 chipset.  Your driver should support the -1 and -2 chipsets, and not
distinguish between the -1a and -1a.  This will simplify things for the
end user.-->
同じベンダーから出荷している複数のチップセットは単一のドライバでサ
ポート可能で、実際魅力的です。複数のサポートしているチップセットが
ある場合、一連の対応する &num;define とドライバを識別する為の変数の
`SDCchipset' を保持して下さい。Trident と PVGA1/WD を例題として見て
ください（Tseng ET3000 と ET4000は逆の意味での例題です。つまり複数
のチップセットに対応したドライバインターフェースが開発される前に実
現してしまいました。従ってこの場合はもうフォロー出来ません。）。追
加するドライバはこれらと異なるように作業をするときはバージョンを意
識するだけで良いことに注意してください。例えば、SDC ドライバが 
SDC-1a,SDC-1b と SDC-2 のチップセットをサポートしていると仮定して下
さい。この -1a と-1b は本質的には同一ですが、-2 とは異なります。追
加するドライバが -1 と -2 のチップセットをサポートすれば、-1a と -1b 
の違いを意識しなくても良いでしょう。この事はエンドユーザの作業を簡
単にします。

<!--In cases where you want to give the user control of driver behavior, or
there are things that cannot be determined without user intervention, you
should use ``option'' flags.  Say that board vendors that use the SDC 
chipsets have the option of providing 8 or 16 clocks.  There's no way you 
can determine this from the chipset probe, so you provide an option flag to 
let the user select the behavior from the XF86Config file.  The option flags
are defined in the file ``xf86_option.h''.  You should look to see if there is 
already a flag that can be reused.  If so, use it in your driver.  If not, 
add a new &num;define, and define the string->symbol mapping in the table in 
that file.  To see how option flags are used, look at the ET4000, 
PVGA1/WD, and Trident drivers.-->
ユーザにドライバの挙動を制御させるか、ユーザの介入無しにドライバを
決定できない場合は、``option'' を使いましょう。SDC チップセットを
使用しているボードベンダーは 8 個か 16 個のクロックパラメータをオ
プションで与えてなさいと言うでしょう。チップセットの探査の結果から
決定するしか方法は無いので XF86Config ファイル からユーザがオプショ
ンで挙動を選択できるように提供しましょう。オプションは 
``xf86_option.h'' ファイルに定義します。再利用可能なオプションが既
にそこにあるかもしれません。再利用可能な場合は追加するドライバに使
いましょう。再利用可能で無い場合は新たに &num;define を追加し、そ
のファイルに 文字列->シンボルの割り当てを表形式で定義します。オプ
ションの使い方を理解するには ET4000, PVGA1/WD と Trident のドライ
バを見てください。

<!--<sect1> Data Structures <p>-->
<sect1> データ構造 <p>
<!--Once you have an understanding of what is needed from the above description,
it is time to fill in the driver data structures.  First we will deal with
the `vgaSDCRec' structure.  This data structure is the driver-local structure
that holds the SVGA state information.  The first entry in this data structure
is ALWAYS `vgaHWRec std'.  This piece holds the generic VGA portion of the
information.  After that, you will have one `unsigned char' field for each
register that will be manipulated by your driver.  That's all there is to
this data structure.-->
上記の説明から何が必要なのか理解したら、ドライバのデータ構造を記入
する段階です。最初に `vgaSDCRec' の構造に取り掛かりましょう。このデ
ータ構造は SVGA の状態情報を保持するドライバ特有のデータ構造です。
このデータ構造の最初の項目は常に `vgaHWRec std' です。この項目は汎
用 VGA の一部分の情報を保持します。それ以降に追加するドライバが操作
するレジスタ毎に一つの `unsigned char' の領域を取ってください。これ
が最初のデータ構造の全てです。

<!--Next you must initialize the `SDC' structure (type `vgaVideoChipRec').  This
is the global structure that identifies your driver to the server.  Its name
MUST be `SDC', in all caps - i.e. it must match the directory name for your
driver.  This is required so that the Link Kit reconfiguration can identify
all of the requisite directories and global data structures.-->
次に `SDC' 構造(`vgaVideoChipRec' 型) の初期化をしなければいけませ
ん。これは追加するドライバをサーバーに識別させるグローバルな構造体
です。その名称はすべて大文字で `SDC' としなければいけません。つまり、
追加するドライバのあるディレクトリの名称と一致しなければなりません。
この事はリンクキットの再構成を行う時に必要なディレクトリとグローバ
ルなデータ構造の全てを確認することが必須です。

<!--The first section of this structure simply holds pointers to the driver
functions.-->
この構造体の始めの部分はドライバ関数へのポインタを単に保持します。

<!--Next, you must initialize the information about how your chipset does
bank switching.  The following fields must be filled in:-->
次は、チップセットがバンク切り替えをどうするかについての情報を初期
化します。以降の領域は次のように記入しなければいけません:
<enum>
<!--<item>         ChipMapSize - the amount of memory that must be mapped into
           the server's address space.  This is almost always 64k (from
           0xA0000 to 0xAFFFF).  Some chipsets use a 128k map (from
           0xA0000 to 0xBFFFF).  If your chipset gives an option, use the
           64k window, as a 128k window rules out using a Hercules or
           Monochrome Display Adapter card with the SVGA.-->
<item>     ChipMapSize - サーバーのアドレス空間に割り付けるメモリ量。
           ほぼ通常 64k (0xA0000 から 0xAFFFF まで) です。いくつかのチッ
           プセットは 128k を使います (0xA0000 から 0xBFFFF まで)。追加
           するチップセットにオプションを付加すると、64k の窓を 128k の
           窓にして Hercules またはモノクロ ディスプレイ アダプタカード
           で SVGA として使用出来ます。
<!--<item>         ChipSegmentSize - the size of each bank within the ChipMapSize
           window.  This is usually also 64k, however, some chipsets split
           the mapped window into a read portion and a write portion (for
           example the PVGA1/Western Digital chipsets).-->
<item>     ChipSegmentSize - ChipMapSize の窓内のバンクの大きさ。
           これもまた通常 64k ですが、いくつかのチップセットは割り付け
           られた窓を読み込み部分と書き込み部分に分割します（例えば 
           PVGA1/Western Digita チップセット）。
<!--<item>         ChipSegmentShift - the number of bits by which an address will
           be shifted right to mask of the bank number.  This is log-base-2
           of ChipSegmentSize.-->
<item>     ChipSegmentShift - バンク番号をマスクするときのアドレス
           を右シフトする際のビット数。これは ChipSegmentSize の 2 を底
           とした log になります。
<!--<item>         ChipSegmentMask - a bitmask used to mask off the address within
           a given bank.  This is (ChipSegmentSize-1).-->
<item>     ChipSegmentMask - 与えられたバンクのアドレスをマスクオフするとき
           のビットマスク。これは (ChipSegmentSize-1) になります。
<!--<item>         ChipReadBottom,ChipReadTop - the addresses within the mapped
           window in which read operations can be done.  Usually 0, and 
           64k, respectively, except for those chipset that have separate
           read and write windows.-->
<item>     ChipReadBottom,ChipReadTop - 読み込み操作を行ったときの
           割り付けられた窓のアドレス。が、チップセットが分割された読み
           込みと書き込みの窓を持っている場合を除いて、通常はおのおの 
           0 と 64k です。
<!--<item>         ChipWriteBottom,ChipWriteTop - same as above, for write
operations.-->
<item>     ChipWriteBottom,ChipWriteTop - 書き込み操作において上記
           と同様です。
<!--<item>         ChipUse2Banks - a boolean value for whether this chipset has one
           or two bank registers.  This is used to set up the screen-to-screen
           operations properly.-->
<item>     ChipUse2Banks - 該当チップセットが一つ又は二つのバンク
           レジスタを持っているか、いないかに関わらないブーリアン値。
           これはスクリーンからスクリーンへの操作の設定に適正に用いら
           れます。
</enum>
<!--There are three more fields that must be filled in:-->
さらに 3 個の領域を記入しましょう:
<enum>
<!--<item>         ChipInterlaceType - this is either VGA_NO_DIVIDE_VERT or
           VGA_DIVIDE_VERT.  Some chipsets require that the vertical timing
           numbers be divided in half for interlaced modes.  Setting this
           flag will take care of that.-->
<item>     ChipInterlaceType - VGA_NO_DIVIDE_VERT または VGA_DIVIDE_VERT
           のどちらかになります。いくつかのチップセットはインタレースモー
           ド用に垂直方向の調整数値を 2 で割ったものを必要とします。その
           ため、この設定には注意してください。
<!--<item>         ChipOptionFlags - this should always be `{0,}' in the data
           structure initialization.  This is a bitfield that contains
           the Option flags that are valid for this driver.  The appropriate 
           bits are initialized at the end of the Probe function.-->
<item>     ChipOptionFlags - データ構造の初期化では通常 `{0,}' に
           します。これはこのドライバで有効な オプション を含んだビッ
           ト列です。探査関数の終了時に適正なビット列に初期化されます。
<!--<item>         ChipRounding - this gets set to the multiple by which the
           virtual width of the display must be rounded for the 256-color
           server.  This value is usually 8, but may be 4 or 16 for some
           chipsets.-->
<item>     ChipRounding - 256 色サーバー用に仮想スクリーンの幅をこ
           の値の倍数になるように丸めるのに用いるため設定します。この値
           は通常は 8 ですが、いくつかのチップセットでは 4 とか 16 にな
           ります。
</enum>

<!--<sect1> The Ident() function <p>-->
<sect1> Ident() 関数 <p>
<!--The <bf>Ident()</bf> function is a very simple function.  The server
will call
this function repeatedly, until a NULL is returned, when printing out the
list of configured drivers.  The <bf>Ident()</bf> function should return a
chipset
name for a supported chipset.  The function is passed a number which
increments from 0 on each iteration.-->
<bf>Ident()</bf> 関数は大変単純な関数です。サーバーがこの関数を 
NULL を帰すまで繰り返し呼び出したときに、組み込まれているドライバの
一覧を出力します。<bf>Ident()</bf> 関数はサポートしているチップセッ
トの名称を返します。この関数は各々の繰り返しで 0 から増加する数値を
渡します。

<!--<sect1> The ClockSelect() function <p>-->
<sect1> ClockSelect() 関数 <p>
<!--The <bf>ClockSelect()</bf> function is used during clock probing (i.e.
when no
`Clocks' line is specified in the XF86Config file) to select the dot-clock
indicated by the number passed in the parameter.  The function should
set the chipset's clock-select bits according to the passed-in number.
Two dummy values will be passed in as well (CLK_REG_SAVE, CLK_SAVE_RESTORE).
When CLK_REG_SAVE is passed, the function should save away copies of
any registers that will be modified during clock selection.  When
CLK_REG_RESTORE is passed, the function should restore these registers.
This ensure that the clock-probing cannot corrupt registers.-->
<bf>ClockSelect()</bf> 関数はクロックの探査をするときに（例えば 
`Clocks' 行を XF86Config ファイルで指定しなかった場合）選択したドッ
トクロックをパラメタで受け取るのに用います。受け取った数値によって
関数はチップセットの clock-select ビットを設定します。
(CLK_REG_SAVE, CLK_SAVE_RESTORE) のような値は二つのダミーとして受け
取る場合があります。CLK_REG_SAVE を受け取った時は、関数がクロック
選択途中に変更したレジスタの写しが保存されています。CLK_REG_RESTORE 
を受け取った時は、関数がレジスタを回復しました。クロック探査がレジ
スタの内容を破壊しなかったことを保証します。

<!--This function should return FALSE if the passed-in index value is invalid
or if the clock can't be set for some reason.-->
受け取ったインデックスの値が不正か、もしくはクロックが不正で設定出
来なかった場合、この関数は FALSE を返します

<!--<sect1> The Probe() function <p>-->
<sect1> Probe() 関数 <p>
<!--The <bf>Probe()</bf> function is perhaps the most important, and perhaps the
least intuitive function in the driver.  The Probe function is required
to identify the chipset independent of all other chipsets.  If the user
has specified a `<tt>Chipset</tt>' line in the XF86Config file, this is a simple
string comparison check.  Otherwise, you must use some other technique
to figure out what chipset is installed.  If you are lucky, the chipset
will have an identification mechanism (ident/version registers, etc), and
this will be documented in the databook.  Otherwise, you will have to
determine some scheme, using the reference materials listed below.-->
<bf>Probe()</bf> 関数はドライバの中で多分最も重要でかつ最も直感的で
無い関数でしょう。Probe 関数は全てのチップセットに依存せずにチップ
セットを識別しなければなりません。XF86Config ファイルに 
`<tt>Chipset</tt>' 行を指定した時に、単純な文字列比較を行います。運
がよければ、チップセットの認識機構(識別/バージョン レジスタ, 等)が
あって、それがデータブックに掲載されているでしょう。さもなければ、
以下に述べるような何らかの手順によって認識しなければなりません。

<!--The identification is often done by looking for particular patterns in
register, or for the existence of certain extended registers.  Or with
some boards/chipsets, the requisite information can be obtained by reading
the BIOS for certain signature strings.  The best advise is to study the
existing probe functions, and use the reference documentation.  You
must be certain that your probe is non-destructive - if you modify a
register, it must be saved before, and restored after.-->
よくレジスタに特有のパターンや、一定の拡張レジスタを探して認識しま
す。又はいくつかのボードやチップセットでは、必要な情報は一定の署名
文字列を BIOSから読みだして獲得しています。既存の探査関数を勉強する
事と参考文献を参照する事を強くお薦めします。追加する探査が非破壊で
行われていることを確認して、レジスタを更新するならば、更新前に保存
して、更新後に回復しなければいけません。

<!--Once the chipset is successfully identified, the <bf>Probe()</bf>
function must
do some other initializations:-->
チップセットが認識できたら、<bf>Probe()</bf> 関数はいくつかの他の
初期化を行う必要があります。
<enum>
<!--<item>         If the user has not specified the `<tt>VideoRam</tt>'
parameter in the
           XF86Config file, the amount of installed memory must be determined.-->
<item>     XF86Config ファイルに `<tt>VideoRam</tt>' パラメタを指定
しない場合は、搭載しているメモリ量を特定しなければいけません。
<!--<item>         If the user has not specified the `<tt>Clocks</tt>' parameter
in the
           XF86Config file, the values for the available dot-clocks must
           be determined.  This is done by calling the <bf>vgaGetClocks()</bf>
           function, and passing it the number of clocks available and
           a pointer to the <bf>ClockSelect()</bf> function.-->
<item>     XF86Config ファイルに `<tt>Clocks</tt>' パラメタを指定し
           ない場合は、可能なドットクロックの値を特定しなければいけませ
           ん。<bf>vgaGetClocks()</bf> 関数を呼ぶことで、可能なクロック
           の値と<bf>ClockSelect()</bf> へのポインタを受け取れます。
<!--<item>         It is recommended that the `maxClock' field of the server's
           `vga256InfoRec' structure be filled in with the maximum
           dot-clock rate allowed for this chipset (specified in KHz).
           If this is not filled in a probe time, a default (currently
           90MHz) will be used.-->
<item>     サーバーの `vga256InfoRec' 構造体の `maxClock' 領域をチッ
           プセットでの可能な最大ドットクロックを (KHz 単位で) 指定する
           ことをお薦めします。探査時にここを記入しないと、標準値 (現在
           は 99MHz ) を使用します。
<!--<item>         The `chipset' field of the server's `vga256InfoRec' structure
           must be initialized to the name of the installed chipset.-->
<item>     サーバーの `vga256InfoRec' 構造体の `chipset' 領域を搭載
           しているチップセットの名称で初期化しましょう。
<!--<item>         If the driver will be used with the monochrome server, the
           `bankedMono' field of the server's `vga256InfoRec' structure
           must be set to indicate whether the monochrome driver supports
           banking.-->
<item>     モノクロサーバーでドライバが使用されるならば、サーバーの 
           `vga256InfoRec' 構造体の `bankedMono' 領域にモノクロドライバ
           がバンク切り替えをサポートしているかどうかを指定しなければい
           けません。
<!--<item>         If any option flags are used by this driver, the
`ChipOptionFlags' 
           structure in the `vgaVideoChipRec' must be initialized with the 
           allowed option flags using the <bf>OFLG_SET()</bf> macro.-->
<item>     追加するサーバーが他のオプションをサポートする場合、
           `vgaVideoChipRec' 型の `ChipOptionFlags'構造体を 
           <bf>OFLG_SET()</bf> マクロを用いてオプションの使用許可を初期
           設定しましょう。
</enum>

<!--<sect1> The EnterLeave() function <p>-->
<sect1> EnterLeave() 関数 <p>
<!--The <bf>EnterLeave()</bf> function is called whenever the virtual
console on which
the server runs is entered or left (for OSs without virtual consoles, the
function is called when the server starts and again when it exits).  The
purpose of this function is to enable and disable I/O permissions (for
OSs where such is required), and to unlock and relock access to ``protected''
registers that the driver must manipulate.  It is a fairly trivial function,
and can be implemented by following the comments in the stub driver.-->
<bf>EnterLeave()</bf> 関数はサーバー上の仮想コンソールに入ったり出
たりする度に呼ばれます(仮想コンソールの無い OS では、この関数はサー
バーの開始時に呼ばれ、終了時にもう一度呼ばれます)。この関数の目的は 
I/O の権限を(OS が要求するように)譲渡したり剥奪したりする事にある為
 と ドライバが操作しなければならない``保護された''レジスタへのロック
 解除と再ロックアクセスをする為です。これは、とても小さな関数ですが
 以降のスタブドライバのコメントにあるように実現しました。

<!--<sect1> The Restore() function <p>-->
<sect1> Restore() 関数 <p>
<!--The <bf>Restore()</bf> function is used for restoring a saved video
state.  Note
that `restore' is a bit of a misnomer - this function is used to both
restore a saved state and to install a new one created by the server.  The
<bf>Restore()</bf> function must complete the following actions:-->
<bf>Restore()</bf> 関数は保存されたビデオ状態を回復するのに用いま
す。restore という名称は少し誤った名称で、この関数は保存された状態
を回復する事とサーバーが新規に作成した状態を保存する事の両方に使用
します。<bf>Restore()</bf> 関数は次の手続きをふむ必要があります:

<enum>
<!--<item>         Ensure that Bank 0 is selected, and that any other state
           information required prior to writing out a new state has been
           set up.-->
<item>     バンク 0 を選択し、新規状態の出力に先だって要求されたバ
           ンク 0 のその他の状態情報が設定済みである事を確認する。
<!--<item>         Call <bf>vgaHWRestore()</bf> to restore the generic VGA
portion of the
           state information.  This function is in the vgaHW.c file.-->
<item>     <bf>vgaHWRestore()</bf> を状態情報の汎用 VGA 部分を回復
           する為に呼ぶ。この関数は vgaHW.c ファイルの中にあります。
<!--<item>         Restore the chipset-specific portion of the state information.
           This may be done by simply writing out the register, or by
           doing a read/modify/write cycle if only certain bits are to
           be modified.  Be sure to note the comment in the sample driver
           about how to handle clock-select bits.-->
<item>     状態情報のチップセット特有部分を回復する。これは単純に
           レジスタに書き込むか、変更すべき適正なビットだけに 
           read/modify/write 操作を行う。クロック選択ビットの扱いを如
           何に行うかについて、ドライバの例題の中のコメントに注意事項
           を書いたので確認してください。
</enum>
<!--<sect1> The Save() function <p>-->
<sect1> Save() 関数 <p>
<!--The <bf>Save()</bf> function is used to extract the initial video state
information
when the server starts.  The <bf>Save()</bf> function must complete the
following
actions:-->
<bf>Save()</bf> 関数はサーバー開始時に初期ビデオ状態情報を取り出す
のに使用する。<bf>Save()</bf> 関数は次の手続きをふむ必要があります:
<enum>
<!--<item>         Ensure that Bank 0 is selected.-->
<item>     バンク 0 を選択したことを確認する。
<!--<item>         Call <bf>vgaHWSave()</bf> to extract the generic VGA portion
of the state
           information.  This function is in the vgaHW.c file.-->
<item>     <bf>vgaHWSave()</bf> を状態情報の汎用 VGA 部分を取り出す
           為に呼ぶ。この関数は vgaHW.c ファイルの中にあります。
<!--<item>         Extract the chipset-specific portion of the state information.-->
<item>     状態情報のチップセット特有部分を取り出す。
</enum>
<!--<sect1> The Init() function <p>-->
<sect1> Init() 関数 <p>
<!--  The <bf>Init()</bf> function is the second most important function in
the driver
(after the <bf>Probe()</bf> function).  It is used to initialize a data
structure
for each of the defined display modes in the server.  This function is
required to initialize the entire `vgaSDCRec' data structure with the
information needed to put the SVGA chipset into the required state.  The
generic VGA portion of the structure is initialized with a call to 
<bf>vgaHWInit()</bf> (also located in vgaHW.c).-->
<bf>Init()</bf> 関数はドライバの中で (<bf>Probe()</bf> 関数の次に) 
二番目に重要です。サーバーの中に定義された表示モード各々についてデー
タ構造を初期化します。この関数は SVGA チップセットに必要な状態に 
`vgaSDCRec' データ構造全体を初期化するのに使います。構造体の汎用 
VGA 部分は (これも vgaHW.c 内にある) <bf>vgaHWInit()</bf> を呼ぶこ
とにより初期化します。

<!--Once the generic portion is initialized, the <bf>Init()</bf> function
can override
any of the generic register initialization, if necessary.  All of the other
fields are filled in with the correct initialization.  The information
about the particular mode being initialized is passed in the `mode'
parameter, a pointer to a `DisplayModeRec' structure.  This can be
dereferenced to determine the needed parameters.-->
汎用の部分を初期化したら、必要なら <bf>Init()</bf> 関数が汎用レジス
タのいくつかの初期化を行います。正しい初期化によってその他全ての領
域が埋められます。初期化した特有のモードの情報は `mode' パラメタで
ある`DisplayModeRec' 構造体へのポインタで受け取ります。

<!--If you only know how to initialize certain bits of the register, do that
here, and make sure that the <bf>Restore()</bf> function does a
read/modify/write
to only manipulate those bits.  Again, refer to the existing drivers
for examples of what happens in this function.-->
レジスタの適正なビットの初期化の方法が分かっている場合はここで初期
化しましょう。<bf>Restore()</bf> 関数でしかそのビットを 
read/modify/write 出来ない事を確認してください。

<!--<sect1> The Adjust() function <p>-->
<sect1> Adjust() 関数 <p>
<!--The <bf>Adjust()</bf> function is another fairly basic function.  It is
called
whenever the server needs to adjust the start of the displayed part of
the video memory, due to scrolling of the virtual screen or when changing
the displayed resolution.  All it does is set the starting address on the
chipset to match the specified coordinate.  Follow the comments in the 
stub driver for details on how to implement it.-->
<bf>Adjust()</bf> 関数は比較的根本的な関数です。仮想スクリーンのス
クロールや表示解像度の変更によって、サーバーがビデオメモリの表示用
領域の開始点を調整する必要のあるときはいつも呼ばれます。毎回、指定
した座標に合わせてチップセットの開始アドレスを設定します。これを実
現する方法の詳細はスタブドライバの中のコメントに従ってください。

<!--<sect1> The ValidMode() function <p>-->
<sect1> ValidMode() 関数 <p>
<!--The <bf>ValidMode()</bf> function is required.  It is used to check
for any chipset-dependent reasons why a graphics mode might not be valid.  It
gets called by higher levels of the code after the Probe() stage.  In
many cases no special checking will be required and this function will
simply return TRUE always.-->
<bf>ValidMode()</bf> 関数は必須です。何故グラフィックモードが妥当で
無いのか、チップセットに依存した理由を調査するのに使用します。
Probe() 実行後のプログラムのより上位のプログラムから呼ばれます。多くの場
合、特別な調査は必要なくこの関数は通常、単に TRUE を返します。

<!--<sect1> The SaveScreen() function <p>-->
<sect1> SaveScreen() 関数 <p>
<!--The <bf>SaveScreen()</bf> function is not needed by most chipsets. 
This function
would only be required if the extended registers that your driver needs
will be modified when a synchronous reset is performed on the SVGA chipset
(your databook should tell you this).  If you do NOT need this function,
simply don't define it, and put `NoopDDA' in its place in the vgaVideoChipRec
structure initialization (NoopDDA is a generic-use empty function).-->
<bf>SaveScreen()</bf> 関数は殆どのチップセットでは必要ありません。
追加するドライバが同期リセットをチップセットで実行する場合、拡張レ
ジスタを更新するのでこの関数が必要になります（データブックに詳細に
記載があります）。この関数が必要*無い*とき、特に定義は必要無く、
vgaVideoChipRec 構造体型で初期化した `NoopDDA' を置きましょう
（NoopDDA は汎用の空の関数です）。

<!--If you DO need this function, it is fairly simple to do.  It will be
called twice - once before the reset, and again after.  It will be passed
a parameter of SS_START in the former case, and SS_FINISH in the latter.
All that needs to be done is to save any registers that will be affected
by the reset into static variables on the SS_START call, and then restore
them on the SS_FINISH call.-->
この関数が*必要*ならば、比較的単純な次の作業を行ってください。二回
呼び出すのですが、一回目はリセット前と二回目はリセット後に呼び出し
ます。前者の場合は 引数にSS_START を渡し、後者では SS_FINISH を渡し
て下さい。毎回、SS_START で呼び出した場合はリセットによって影響のあ
るレジスタを格納し、SS_FINISH で呼び出した場合はそれを回復する必要
があります。

<!--<sect1> The GetMode() function <p>-->
<sect1> GetMode() 関数 <p>
<!--The <bf>GetMode()</bf> function is not used as of XFree86 1.3; its
place in the
vgaVideoChipRec should be initialized to `NoopDDA'.-->
<bf>GetMode()</bf> 関数は XFree86 1.3 迄は使っていませんし、これは 
vgaVideoChipRec 型で `NoopDDA' を初期化したものです。

<!--At some point in the future, this function will be used to enable the server
and/or a standalone program using the server's driver libraries to do 
interactive video mode adjustments.  This function will read the SVGA
registers and fill in a DisplayModeRec structure with the current video
mode.-->
将来、いくつかの点でこの関数はサーバーのドライバライブラリを使うサー
バー且つ／又はスタンドアローンのプログラムの対話型ビデオモード調節
に使用可能になるでしょう。この関数は SVGA レジスタを読み込み現在の
ビデオモードの DisplayModeRec 構造体に書き込みます。

<!--<sect1> The FbInit() function <p>-->
<sect1> FbInit() 関数 <p>
<!--The <bf>FbInit()</bf> function is required for drivers with accelerated
graphics
support.  It is used to replace default cfb.banked functions with
accelerated chip-specific versions.  vga256LowlevFuncs is a struct containing
a list of functions which can be replaced.  This struct defined in
vga256.h.  Examples of <bf>FbInit()</bf> functions can be found in the et4000,
pvga1 and cirrus drivers.-->
<bf>FbInit()</bf> 関数はアクセラレータグラフィックスをサポートする
ドライバに必須です。アクセラレータチップ固有のバージョンでは標準で 
cfb.banked 関数を置き換えて使用します。vga256LowlevFuncs は置き換え
可能な関数の一覧を含む構造体です。この構造体は vga256.h で定義して
います。<bf>FbInit()</bf> 関数の例は et4000, pvga1 とcirrus のドラ
イバにあります。

<!--If you do NOT need this function, simply don't define it, and put `NoopDDA'
in its place in the vgaVideoChipRec structure initialization.-->
この関数が必要ない場合、単に定義をしないで、vgaVideoChipRec 型で初
期化した `NoopDDA' を置いてください。

<!--<sect> Building The New Server <p>-->
<sect> 新サーバーの生成 <p>
<!--As in the setup work, the steps for building the server depend whether
you are working in the source tree or in the Link Kit.  Here are the
steps for the initial build after installing your new driver files:-->
この設定作業は、ソースファイルからか、リンクキットからかによらずサー
バーを生成する段階の作業を行います。
<itemize>
<!--    <item> If you are working in the source tree, follow these steps:-->
        <item> ソースファイルから作業をしている場合は、次の手順で行っ
        て下さい:

<!--            Go to xc/programs/Xserver, and enter-->
                xc/programs/Xserver に移動して、
<!--            `<tt>make Makefile</tt>', then-->
                `<tt>make Makefile</tt>' と入力したら
<!--            `<tt>make Makefiles depend all</tt>'-->
                `<tt>make Makefiles depend all</tt>' と入力します。

<!--    <item> If you are working in the Link Kit, follow these steps:-->
        <item> リンクキットから作業をしている場合は、次の手順で行って
        ください:

        <enum>
<!--    <item> Go to /usr/X11R6/lib/Server, and enter-->
        <item> /usr/X11R6/lib/Server へ移動して、
<!--           `<tt>./mkmf</tt>'-->
               `<tt>./mkmf</tt>' と入力したら
<!--    <item> In the same directory, enter `<tt>make</tt>'-->
        <item> 同じディレクトリで、`<tt>make</tt>' と入力します。
        </enum>
</itemize>
<!--To rebuild the server after the initial build (e.g. after making changes
to your driver):-->
最初の生成の後でサーバーの再生成を行うならば（例えば追加するドライ
バに変更してから）:

<itemize>
<!--<item>      If you are working in the source tree, follow these steps:-->
<item>  ソースファイルから作業をしている場合は、次の手順で行って下さい:
                
        <enum>
<!--    <item>  Go to the appropriate drivers/ directory (e.g.,
           xc/programs/Xserver/hw/xfree86/vga256/drivers),
           and enter `<tt>make</tt>'.-->
        <item>  適切な drivers/ 下の ディレクトリへ移動して（例えば
           xc/programs/Xserver/hw/xfree86/vga256/drivers）、そして
           `<tt>make</tt>' と入力してください。
<!--    <item>  Go to xc/programs/Xserver, and enter-->
        <item>  xc/programs/Xserver へ移動して、次を入力してください。
<!--       `<tt>make loadXF86_SVGA</tt>' (to link the color server),-->
           `<tt>make loadXF86_SVGA</tt>' (カラーサーバーへのリンク),
<!--       `<tt>make loadXF86_VGA16</tt>' (to link the 16 color server) or-->
           `<tt>make loadXF86_VGA16</tt>' (16 色サーバーへのリンク) 又は
<!--       `<tt>make loadXF86_Mono</tt>' (to link the mono server).-->
           `<tt>make loadXF86_Mono</tt>' (モノクロサーバーへのリンク)。
        </enum>

<!--<item>      If you are working in the Link Kit, follow these steps:-->
<item>  リンクキットから作業を行っている場合は、次の手順で行って下さい:
        <enum>
<!--    <item>  Go to the appropriate driver directory, and enter
           `<tt>make</tt>'.-->
        <item>  適切なドライバのディレクトリへ移動して、そして
           `<tt>make</tt>' と入力してください。
<!--    <item>  Go to /usr/X11R6/lib/server, and enter -->
        <item>  /usr/X11R6/lib/server に移動して、次を入力してください。
<!--       `<tt>make loadXF86_SVGA</tt>' (to link the color server) or -->
           `<tt>make loadXF86_SVGA</tt>' (カラーサーバーへのリンク), 又は
<!--       `<tt>make loadXF86_VGA16</tt>' (to link the 16 color server) or -->
           `<tt>make loadXF86_VGA16</tt>' (16 色サーバーへのリンク) 又は
<!--       `<tt>make loadXF86_Mono</tt>' (to link the mono server).-->
           `<tt>make loadXF86_Mono</tt>' (モノクロサーバーへのリンク)。
        </enum>
</itemize>

<!--<sect> Debugging <p>-->
<sect> デバッグ <p>
<!--Debugging a new driver can be a painful experience, unfortunately.  It
is likely that incorrect programming of the SVGA chipset can lock up your
machine.  More likely, however, is that the display will be lost, potentially
requiring a reboot to correct.  It is HIGHLY recommended that the server
be run from an attached terminal or a network login.  This is the only
rational way in which a debugger can be used on the server.  Attempting
to use multiple VTs for debugging is basically a waste of time.-->
残念ながら新しいドライバのデバッグは辛いものです。例えば SVGA チッ
プセットのプログラムが間違った場合マシンが固まってしまうでしょう。
ディスプレイの表示が消えたりするので、もしかすると正常に戻すために
再立ち上げをする必要があるかもしれません。外部端末を繋ぐか、ネット
ワークからログインすることを*強く*お勧めします。サーバーでデバッガ
が動作する場合に、唯一合理的な方法です。複数の VT を使いながらのデ
バッグは基本的に時間の無駄です。

<!--Because of the potential for locking up the machine, it is a VERY good idea
to remember to do a `sync' or two before starting the server.  In addition,
any unnecessary filesystems should be unmounted while the debugging session
is going on (to avoid having to run unnecessary fsck's).-->
マシンが固まってしまう場合は、サーバーを起動する前に一つか二つの
`同期'を取る事を思い出すことは*とても*良いと思います。加えて、デバッ
グを始める前に必要のないファイルシステムをアンマウント（必要のない 
fsck が実行されないように）しておきましょう。

<!--By default the server is built without debugging symbols.  The server can
grow VERY large with debugging enabled.  It is very simple to rebuild
your driver for debugging, though.  Do the following:-->
標準ではサーバーはデバッグ用のシンボルが付属していません。デバッグ
できるようにしたサーバーは*とても*大きなものになります。ですがデバッ
グの為のサーバーを再構築することは簡単です。次の手順で行ってください:

<enum>
<!--    <item> Go to the driver directory.-->
        <item> ドライバのディレクトリへ移動してください。
<!--    <item> Edit the Makefile.  Look for the SECOND definition of 
           `<tt>CDEBUGFLAGS</tt>'.  Change this definition to -->
        <item> Makefile を編集してください。 `<tt>CDEBUGFLAGS</tt>' の
        *二番目*の定義を探してください。次のように修正してください。
                
        <verb>
                CDEBUGFLAGS = -g -DNO_INLINE
        </verb>

<!--       (this will enable debugging symbols and disable inlining of
           functions, which can make single-stepping a nightmare).
        <item> Remove the `sdc_driver.o' file.
        <item> Now follow the steps above for rebuilding the server.-->
           (これはデバッグ用シンボルを有効にし、シングルステップ実行時
           の悪夢を引き起こす関数のインライン展開を無効にします。)
        <item> `sdc_driver.o' ファイルを消してください。
        <item> 上記の手順に注目してサーバーを再構築してください。

<!--    (Alternatively, instead of editing the Makefile, you can simply
        do `<tt>make CDEBUGFLAGS="-g -DNO_INLINE"</tt>' after removing the
        old .o file, then rebuild the server as described above).-->
        (又は、古い .o ファイルを消した後で Makefile を修正する代わりに、
        単に `<tt>make CDEBUGFLAGS="-g -DNO_INLINE"</tt>' を実行して
        上記の手順でサーバーを再構築してください。)
</enum>

<!--This will give you a server with which you can set breakpoints in the driver
functions and single-step them.  If you are working in the source tree,
and just learning about SVGA programming, it may be useful to rebuild 
vgaHW.c with debugging as well.-->
これを行うことによってドライバの関数にブレークポイントを設定しシン
グルステップ実行をサーバーで行うことが出来ます。ソースから作業を行
い、SVGA プログラミングを学習し始めたばかりならば、vgaHW.c を再構築
しデバッグするのがちょうど良いでしょう。

<!--<sect> Advice <p>-->
<sect> アドバイス <p>
<!--I cannot stress this enough - study all available references, and the
existing code, until you understand what is happening.  Do this BEFORE you
begin writing a driver.  This will save you a massive amount of headache.
Try to find a driver for a chipset that is similar to yours, if possible.
Use this as an example, and perhaps derive your driver from it.-->
全ての利用可能な参考文献と存在するプログラムを調べて、何が起ってい
るのか分かるようになるまでかなりストレスを感じます。ドライバを書き
始める*前に*調査を行って下さい。かなり頭痛を減らすことになります。
可能ならば、これから追加しようとするチップセットに似たチップセット
のドライバを探しましょう。この例題から派生させてドライバを作成
できるかもしれません。

<!--Do not let the gloom-and-doom in the debugging section  discourage you.  
While you will probably have problems initially (I still do), careful, 
deliberate debugging steps can bear fruit very quickly.  It is likely 
that, given a good understanding of the chipset, a driver can be written 
and debugged in a day or two.  For someone just learning about this kind 
of programming, a week is more reasonable.-->
デバッグ中は暗く思い詰めてはいけません。はじめのうち（私もまだそう
です）、多分問題を抱えているときは注意深く慎重にデバッグするので迅
速に成果が上がります。それはチップセットについての理解を高め一日か
二日の内にドライバが書き上がりデバッグ出来ます。この種のプログラミ
ングを学習し始めた人では一週間もあればより妥当な線でしょう。

<!--<sect> Advanced Topics <p>-->
<sect> 高度な話題 <p>
<!--Newer chipsets are getting into two advanced areas: programmable clock
generators, and accelerated capabilities (BitBlt, line drawing, HW cursor).
These are new areas, and the formal interfaces to them are not yet defined.
It is advised that you contact the XFree86 team and get involved with the
development/beta-testing team if you need to be working in these areas.-->
新しいチップセットは二つの高度な技術領域を取り組みました: それはプ
ログラマブルクロックジェネレータとアクセラレータの各種特性(BitBlt, 
line drawing, HW カーソル) です。これらは新しい技術領域で、正式な
インターフェースは未だ定義されていません。これらの新しい技術領域
について作業したい場合は、XFree86 チームと連絡を取って開発/ベータ
テストチームに参画してください。

<!--<sect> References <p>-->
<sect> 参考文献 <p>
<itemize>
<item> Programmer's Guide to the EGA and VGA Cards, 3rd ed. <newline>
   Richard Ferraro <newline>
   Addison-Wesley, 1990 <newline>
   ISBN 0-201-57025-4 <newline>
<!--
-<item> Programmer's Guide to the EGA and VGA Cards, 2nd ed. <newline>
-   Richard Ferraro <newline>
-   Addison-Wesley, 1990 <newline>
-   ISBN 0-201-57025-4 <newline>
-   (This is the bible of SVGA programming - it has a few errors, so watch out).
-
-<item> vgadoc3.zip <newline>
+<item> Programmer's Guide to the EGA and VGA Cards, 3rd ed. <newline>
+   Richard Ferraro <newline>
+   Addison-Wesley, 1994 <newline>
+   ISBN 0-201-62490-7 <newline>
+   (This is the bible of SVGA programming - it has a few errors, so watch out.
+   The third edition also covers several accelerated video cards.)
+
+<item> vgadoc4.zip <newline>
-->
<!--   (This is the bible of SVGA programming - it has a few errors, so
watch out).-->
   (これは SVGA プログラミングの必読書です。ちょっとエラーがあ
	るので注意しましょう。第 3 版でもアクセラレータビデオカードに言及
	しています。)

<item> vgadoc4.zip <newline>
   Finn Thoegersen <newline>
<!--   (This is a collection of SVGA and other chipset documentation.  It is
   available on most MS-DOS/Windows related FTP archives, including wuarchive.
   It is DOS/BIOS oriented, but is still extremely useful, especially for
   developing probe functions).-->
<!-- ....1.........2.........3.........4.........5.........6...... -->
   (SVGA とその他のチップセットの資料を集めたものです。wuarchive を
   含む FTP から取り寄せ可能で殆どの MS-DOS/Windows で見ることが可
   能です。DOS/BIOS に依存したものですが、探査関数を開発する時にと
   ても有用です。)
</itemize>

<!--<sect> Vendor Contact Information <p>-->
<sect> ベンダー連絡先情報 <p>
<descrip>
<tag/ATI Technologies (VGA-Wonder, Mach8, Mach32)
     33 Commerce Valley Drive East/
Thornhill, Ontario <newline>
Canada L3T 7N6 <newline>
(905) 882-2600 (sales) <newline>
(905) 882-2626 (tech support) <newline>
(905) 764-9404 (BBS) <newline>
(905) 882-0546 (fax) <newline>

<tag/Chips &amp; Technologies/
??? <newline>

<tag/Cirrus Logic (SVGA, Accelerators - CL-GD5426)/
3100 West Warren Ave. <newline>
Fremont, CA  94538 <newline>
(510) 623-8300 (N. CA, USA) <newline>
(49) 8152-40084 (Germany) <newline>
(44) 0727-872424 (UK) <newline>

<tag/Genoa Systems (GVGA)/
75 E. Trimble Road <newline>
San Jose, CA 95131 <newline>
(408) 432-9090 (sales) <newline>
(408) 432-8324 (tech support) <newline>

<tag/Headland Technologies, Inc (Video-7 VGA 1024i, VRAM II)/
46221 Landing Parkway <newline>
Fremont, CA  94538 <newline>
(415) 623-7857 <newline>

<tag/Oak Technology, Inc (OTI-067,OTI-077)/
139 Kifer Ct. <newline>
Sunnyvale, CA 94086 <newline>
(408) 737-0888 <newline>
(408) 737-3838 (fax) <newline>

<tag>S3 (911, 924, 801/805, 928, 864, 868, 964, 968, 764, 765)</tag>
(408) 980-5400 <newline>

<tag/Trident Microsystems Inc (8800, 8900, 9000)/
205 Ravendale Dr <newline>
Mountainside, CA 94043 <newline>
(415) 691-9211 <newline>

<tag/Tseng Labs Inc,/
6 Terry Drive <newline>
Newtown, PA  18940 <newline>
(215) 968-0502 <newline>

<tag/Weitek (Power9000, 5186)/
1060 E. Arques Ave, <newline>
Sunnyvale, CA  94086 <newline>
(408) 738-5765 <newline>

<tag/Western Digital/
(714) 932-4900 <newline>
</descrip>

<verb>
$XFree86: xc/programs/Xserver/hw/xfree86/doc/Japanese/sgml/VGADriv.sgml,v 3.1 1997/01/26 04:34:26 dawes Exp $
</verb>
<hrule>

このファイルは xc/programs/Xserver/hw/xfree86/doc/sgml/VGADriv.sgml,v 3.10 1996/10/23 13:10:05 を、 岡本  一幸 
( Kazuyuki Okamoto <url url="mailto:ikko-@pacific.rim.or.jp"
name="&lt;ikko-@pacific.rim.or.jp&gt;"> ) が XFree86 3.2 を
日本でインストールする人向けに和訳したものです。ここがおかしいとか、
ここはこうしたほうがいいといったご意見がありましたら、電子メールで
お知らせ下さい。
原文の著作権は XFree86 プロジェクト社にあります。この和訳の著作権は 
XFree86 プロジェクト社と岡本　一幸にありますが、この和訳の不具合は私に、
電子メールで送って下さい。
<hrule>
&lsqb;EOF&rsqb;

</article>
