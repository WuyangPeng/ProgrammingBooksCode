/**
*Copyright (c) 2000-2001, Jim Crafton
*All rights reserved.
*Redistribution and use in source and binary forms, with or without
*modification, are permitted provided that the following conditions
*are met:
*	Redistributions of source code must retain the above copyright
*	notice, this list of conditions and the following disclaimer.
*
*	Redistributions in binary form must reproduce the above copyright
*	notice, this list of conditions and the following disclaimer in 
*	the documentation and/or other materials provided with the distribution.
*
*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
*AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
*A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS
*OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
*EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
*PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
*PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
*LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
*SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*NB: This software will not save the world.
*/

/* Generated by Together */



#ifndef GRAPHICSCONTEXT_H
#define GRAPHICSCONTEXT_H


namespace VCF{

class ContextPeer;
class FontState;
class StrokeState;
class FillState;
class Image;
class Fill;
class Path;
class Stroke;
class Font;

#define RH_ANTI_ALIAS_ON	1
#define RH_ANTI_ALIAS_OFF	0

#define RHN_ANTI_ALIAS		"RHN_ANTI_ALIAS"

/**
*A Graphics Context provides the lowest level graphics interface to the
*native systems 2D drawing operations. Based loosely on PostScript,
*a Context takes a series of of drawing operations, or commands 
*(lineTo, moveTo, etc), and then executes them by either filling or
*strokeing the path(s) that result from the commands. Thus calling 
*ellipse() will not draw anything till the strokePath() or fillPath()
*methods have been called. All path commands should add their information
*to a stack of some sort that is then looped through and executed
*using the appropriate native graphics calls. At each path command
*a test should be made as to whether the buffer should be cleared.
*The buffer should be cleared only after the stroke of fill methods
*have been  called. For example:
*
*<p><pre>
*	ellipse(23,23,45,67) //added to buffer 
*	moveTo(89,100) //add to buffer
*	lineTo(300,40) //add to buffer
*	strokePath()
*	fillPath()
*	rectangle(200,300,400,400)//buffer cleared, then add to buffer
*</pre></p>
*
*@version 1.0
*@author Jim Crafton
*
*/
class GRAPHICSKIT_API GraphicsContext : public Object {
public:
	GraphicsContext();
	/**
	*Creates a new blank graphics context of the specified width and height
	*/
	GraphicsContext( const unsigned long& width, const unsigned long& height );
	
	/**
	*Create a new context based on a context ID. See ContextPeer getContextID()
	*Doing this should caryy over any of the current settings of the context that the contextID represents.
	*/
	GraphicsContext( const long& contextID );

	virtual ~GraphicsContext();

	void init();

	/**
	*Sets the rendering hints for the context. Rendering hints are used to indicate what the best 
	*case performance for the context should be. For example, if anti-aliasing is specified, then the
	*context will try to anti-aliase whenever possible, according to the capabilities of the
	*graphics subsystem that the context represents. Thus if the context was on a machine that only 
	*supported 16 colors, anti-aliasing might be specified, but would be out of the question due to 
	*the lack of available colors.
	*@param hintName - name of the hint
	*@param hintValue - the value of the hint, i.e. on or off for example
	*/
    void setRenderingHint(const String & hintName, const unsigned long & hintValue);

	/**
	*see above, sets multiple rendering hints at once. 
	*@param renderingHints - a map of all the rendering hints being set in this method
	*/
    void setRenderingHints(const std::map<String, unsigned long> &renderingHints );
	
	/**
	*sets the current font 
	*A copy of the Font is made when this is set
	*/
    void setCurrentFont(Font * font);

	/**
	*returns the current Font
	*/
	Font* getCurrentFont();

	/**
	*sets the current fill
	*/
    void setCurrentFill(Fill * fill);

	/**
	*sets the current stroke
	*/
    void setCurrentStroke(Stroke * stroke);

	/**
	*draws a path. See Path for more info. Basically this simple enumerates all the 
	*path points and uses the current stroke and fill to render the shape
	*/
    void draw(Path * path);

	/**
	*draws an image at the x,y, coordinates
	*/
    void drawImage( const double& x, const double& y, Image * image);

	/**
	*draws an image at the x,y, coordinates, with 
	*state
	*@param double x coordinate
	*@param double y coordinate
	*@param Image the image to draw
	*@param bool the state of the image, if true then draws the 
	*image normally, if false draws a grayed out and embossed 
	*version
	*Note: as of 8/4/2001 not implemented yet
	*/
    void drawImageWithState( const double& x, const double& y, Image * image, const bool& enabled );

	/**
	*draws a portion of the image.
	*@param Rect boudns - the m_left, m_top members of the bounds rect describe
	*where on the GraphicsContext the image will be drawn, while the height
	*and width of the bounds tells how much of the image to draw. A height or width
	*greater than the Image is ignored, and the whole image is draw. A height
	*or width less than the image results in only a portion of the image getting 
	*drawn, or the top, left of the image to the specified height and width.
	*@param Image the image to draw
	*/
	void drawImageWithinBounds( Rect* bounds, Image* image );

	/**
	*draws a partial image at the x,y, coordinates specified
	*@param double x - the x coordinate on the GraphicsContext
	*@param double y - the y coordinate on the GraphicsContext
	*@param Rect* imageBounds - a rectangle in the coordinate space
	*of the image that specifies which rectangular portion of the 
	*image to draw
	*@param Image image - the image to draw
	*/
	void drawPartialImage( const double& x, const double& y, Rect* imageBounds, Image* image );

	/**
	*Draws a string at the x,y coordinates
	*/
	void drawString( const double& x, const double& y, const String& text );

	void drawStringWithState( const double& x, const double& y, const String& text, const bool& enabled );

	void drawStringAlongBaseline( const double& x, const double& y, const String& text );
	/**
	*gets the capabilites of the GraphicsContext
	*/
    void getCapabilities();    
	
	/**
	*returns current transform matrix for this GraphicsContext instance.
	*Before the matrix is returned, a new matrix is created and then multiplied
	*into the final transform matrix. These matrices represent the various trnasform
	*values (i.e. m_theta, m_scaleX, etc)
	*/
	void setCurrentTransform( Matrix2D* transform );

	Matrix2D* getCurrentTransform();

	/**
	*End of high level gaphics functions. The funtions below are lower level 
	*See ContextPeer for more information on the functions below
	*/

    virtual void setCurrentFontState(FontState * state);

	
	virtual void textAt(const double & x, const double & y, const String & text);

	/**
	*draws text within the bounds specified. If specified the 
	*text will be word wrapped within the bounds. 
	*@param Rect bounds - the left, top, right, and bottom of the 
	*rectangle to draw the text within
	*@param String the text to draw
	*@param bool wordWrap whether or not wrap the text to
	*bounds specified. If wordWrap is false, then the text is 
	*treated as a single line, and any text extending past the 
	*right coordinate value will be clipped using an ellipsis.
	*So if "Hello World" is passed in and the bounds only fits
	*"Hello W", then the string will be drawn as "Hello..."
	*/
	void textBoundedBy( Rect* bounds, const String& text, const bool& wordWrap=true );

	double getTextWidth( const String& text );

	double getTextHeight( const String& text );

    virtual void rectangle(const double & x1, const double & y1, const double & x2, const double & y2);

	virtual void rectangle( Rect* r ){
		if ( NULL != r ) {
			this->rectangle( r->m_left, r->m_top, r->m_right, r->m_bottom );	
		}
	};

    virtual void circle(const double & x, const double & y, const double & radius);

    virtual void ellipse(const double & x1, const double & y1, const double & x2, const double & y2, const double & angle=0.0);

	virtual void setColor( Color* color );

	virtual Color* getColor();

    virtual void setCurrentStrokeState(StrokeState * state);

    virtual void setCurrentFillState(FillState * state);

    virtual void polyline(std::vector<Point*> & pts);

    virtual void curve(const double& x1, const double& y1, const double& x2, const double& y2,
                          const double& x3, const double& y3, const double& x4, const double& y4);

    virtual void lineTo(const double& x, const double& y);

    virtual void moveTo(const double& x, const double& y);
    
    virtual void fillPath();

    virtual void strokePath();
	
	ContextPeer* getPeer();

	virtual void copyContext( const double& x, const double& y, GraphicsContext* context );

	/**
	*Sets the context's origin for drawing. The default is 0,0 in the top, left of the corner of 
	*screen real estate the context represents
	*/
	void setOrigin( const double& x, const double& y );

	Point* getOrigin();	

	/**
	*sets the current rotation value
	*/
	void setRotation( const double& theta );

	void setTranslation( const double transX, const double& transY );

	void setShear( const double& shearX, const double& shearY );

	void setScale( const double& scaleX, const double& scaleY );

	/**
	*returns whether or not the XOR Mode is turned on.
	*@return bool if the return is true then the 
	*XOR mode is on, which means that colors are alternated 
	*at the pixel level. Thus a line drawn once, and then
	*a second time at the same coordinates will erase itself
	*/
	bool isXORModeOn();

	/**
	*Turns the XOR mode on or off.
	*@param bool XORModeOn, if true then turns the XORMode on
	*otherwise if it's false it turns it off.
	*/
	void setXORModeOn( const bool& XORModeOn );
protected:
    std::map<String, unsigned long>  m_renderingHints;
    ContextPeer * m_contextPeer;
	Fill* m_currentFill;
	Stroke* m_currentStroke;
	Font* m_currentFont;
	Matrix2D m_transformMatrix;
	double m_theta;
	double m_xScale;
	double m_yScale;
	double m_xTranslate;
	double m_yTranslate;
	double m_xShear;
	double m_yShear;
	Color m_color;

	void compositeMatrices();	
};

};
#endif //GRAPHICSCONTEXT_HONTEXT_H