/**
*Copyright (c) 2000-2001, Jim Crafton
*All rights reserved.
*Redistribution and use in source and binary forms, with or without
*modification, are permitted provided that the following conditions
*are met:
*	Redistributions of source code must retain the above copyright
*	notice, this list of conditions and the following disclaimer.
*
*	Redistributions in binary form must reproduce the above copyright
*	notice, this list of conditions and the following disclaimer in 
*	the documentation and/or other materials provided with the distribution.
*
*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
*AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
*A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS
*OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
*EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
*PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
*PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
*LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
*SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*NB: This software will not save the world.
*/

/* Generated by Together */


#ifndef MATRIX2D_H
#define MATRIX2D_H



namespace VCF{

#define M_00	0
#define M_01	1
#define M_02	2
#define M_10	3
#define M_11	4
#define M_12	5
#define M_20	6
#define M_21	7
#define M_22	8

class GRAPHICSKIT_API Matrix2D : public Object {
public:

	Matrix2D();

	Matrix2D ( const Matrix2D& matrix );

	virtual ~Matrix2D();   

	/**
	*transposes the matrix
	*@param Matrix2D dest the matrix that is transposed by this 
	*matrix.
	*/
    void transpose( Matrix2D* dest );

	/**
	*creates a reflection matrix
	*@param bool reflectX whether or not to reflect on the X axis
	*@param bool reflectY whether or not to reflect on the Y axis
	*/
    void reflect( const bool& reflectX, const bool& reflectY );

	/**
	*creates a rotation matrix
	*@param double the angle of the newly created rotation matrix
	*from 0.0..360.0
	*/
    void rotate( const double& theta );

	/**
	*creates a shear matrix
	*@param double shearX the amount to shear along the X axis ranges in degrees
	*from 0.0...360.0
	*@param double shearY the amount to shear along the Y axis ranges in degrees
	*from 0.0...360.0
	*/
    void shear( const double& shearX, const double& shearY );

	/**
	*creates a scale matrix
	*<code>
	*|0|scaleX|0|
	*|scaleY|0|0|
	*|0|0|1|
	*</code>
	*@param double scaleX the amount of scaling to apply along the x axis
	*@param double scaleY the amount of scaling to apply along the Y axis
	*/
    void scale( const double& scaleX, const double& scaleY );

	/**
	*Creates an identity matrix
	*<code>
	*|1|0|0|
	*|0|1|0|
	*|0|0|1|
	*</code>
	*/
    void identity();

	/**
	*multiply m1 X m2 and store the result in the current instance
	*@return Matrix2D a pointer to the current instance
	*/
    Matrix2D* multiply( Matrix2D* m1, Matrix2D* m2 );
	
	/**
	*creates a translation matrix
	*@param double transX the amount to translate along the X axis	
	*@param double transY the amount to translate along the Y axis	
	*/
    void translate( const double& transX, const double& transY );

	/**
	*inverts the current matrix
	*/
	void invert();

	Point* apply( Point* point ); 

	/**
	*is the current matrix instance equal to the object passed in ?
	*where hopefully the object is a pointer to a Matrix2D instance.
	@return  bool true if the two Matrix2D's m_matrix data is equal in
	*value, otherwise false
	*/
	virtual bool isEqual( Object* object )const;

	/**
	*copy the data in the Matrix2D source into the current
	*instance.
	*/
	virtual void copy( Object* source );


	Matrix2D& operator= ( const Matrix2D& matrix );

	bool operator == ( const Matrix2D& matrix )const;	

	/**
	*subscript operator overload for conveniently accessing the matrix
	*elements. Access is provided by using the #defines above, where M_00
	*represents the double value at m_matrix[0][0], and M_01 represents 
	*the double value at m_matrix[0][1], and so forth.
	*/
	double operator[]( int subscript );

protected:

	double m_matrix[3][3];

private:
	
};

};
#endif //MATRIX2D_H