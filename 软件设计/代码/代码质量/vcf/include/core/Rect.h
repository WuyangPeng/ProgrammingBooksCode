/**
*Copyright (c) 2000-2001, Jim Crafton
*All rights reserved.
*Redistribution and use in source and binary forms, with or without
*modification, are permitted provided that the following conditions
*are met:
*	Redistributions of source code must retain the above copyright
*	notice, this list of conditions and the following disclaimer.
*
*	Redistributions in binary form must reproduce the above copyright
*	notice, this list of conditions and the following disclaimer in 
*	the documentation and/or other materials provided with the distribution.
*
*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
*AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
*A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS
*OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
*EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
*PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
*PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
*LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
*SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*NB: This software will not save the world.
*/

/* Generated by Together */

#ifndef RECT_H
#define RECT_H


namespace VCF{	

#define RECT_CLASSID		"ED88C096-26AB-11d4-B539-00C04F0196DA"

/*
*a Rect class represents the four coordinates of a 
*2 dimensional rectangle (left, top, right, and bottom). The 
*values are stored as double for maximum precision. 
*/
class FRAMEWORK_API Rect : public Object, public Persistable{
public:
	BEGIN_CLASSINFO(Rect, "VCF::Rect", "VCF::Object", RECT_CLASSID)	
	PROPERTY( double, "left", Rect::getLeft, Rect::setLeft, PROP_DOUBLE )
	PROPERTY( double, "top", Rect::getTop, Rect::setTop, PROP_DOUBLE )
	PROPERTY( double, "right", Rect::getRight, Rect::setRight, PROP_DOUBLE )
	PROPERTY( double, "bottom", Rect::getBottom, Rect::setBottom, PROP_DOUBLE )
	READONLY_PROPERTY( double, "width", Rect::getWidth, PROP_DOUBLE )
	READONLY_PROPERTY( double, "height", Rect::getHeight, PROP_DOUBLE )
	END_CLASSINFO(Rect)


    Rect( const double & left, const double & top, const double & right, const double & bottom );
	
	Rect( const Rect& rect );

	Rect();

	CREATE(Rect);

	CREATE_COPY(Rect);

	CREATE_4(Rect,const double&,const double&,const double&,const double&);

	
    double m_bottom;
    double m_right;
    double m_top;
    double m_left;

	/**
	*inflates the rectangle
	*@param double the amount to increase (or decrease if the value is negative)
	*the left and right coordinates
	*@param double the amount to increase (or decrease if the value is negative)
	*the top and bottom coordinates
	*/
    void inflate(const double & x, const double & y);

	/**
	*does the point lay within this rectangle's coordinates ?
	*@return true if the point is within the rectangle's coordinates
	*otherwise false
	*/
    bool containsPt( Point * point );

	/**
	*the width of the rectangle, or the value 
	*returned from abs(right - left)
	*/
    double getWidth();

	/**
	*the height of the rectangle, or the value 
	*returned from abs(bottom - top)
	*/
    double getHeight();

	/**
	*normalizes the rectangles coordinates so that the top
	*is the less than the bottom, and the left is less than
	*the right.
	*/
    void normalize();

	/**
	*does the specified rectangle fall inside the bound of this 
	*Rect instance ?
	*/
    bool containsRect( Rect* rect );

	bool operator == ( const Rect& rectToCompare )const;

	/**
	*sets the left, top, right, and bottom all at once
	*/
	void setRect( const double & left, const double & top, const double & right, const double & bottom );
	
	double getLeft(){
		return m_left;
	};

	void setLeft( const double& left ){
		m_left = left;
	};


	double getTop(){
		return m_top;
	};

	void setTop( const double& top ){
		m_top = top;
	};

	double getRight(){
		return m_right;
	};

	void setRight( const double& right ){
		m_right = right;
	};

	double getBottom(){
		return m_bottom;
	};

	void setBottom( const double& bottom ){
		m_bottom = bottom;
	};

	virtual String toString();

	/**
	*Write the object to the specified output stream
	*/
    virtual void saveToStream( OutputStream * stream );
	
	/**
	**Read the object from the specified input stream
	*/
    virtual void loadFromStream( InputStream * stream );

};

};

#endif //RECT_HH