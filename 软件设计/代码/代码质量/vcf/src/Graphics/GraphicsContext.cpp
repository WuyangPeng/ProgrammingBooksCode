/**
*Copyright (c) 2000-2001, Jim Crafton
*All rights reserved.
*Redistribution and use in source and binary forms, with or without
*modification, are permitted provided that the following conditions
*are met:
*	Redistributions of source code must retain the above copyright
*	notice, this list of conditions and the following disclaimer.
*
*	Redistributions in binary form must reproduce the above copyright
*	notice, this list of conditions and the following disclaimer in 
*	the documentation and/or other materials provided with the distribution.
*
*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
*AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
*A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS
*OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
*EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
*PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
*PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
*LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
*NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
*SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*NB: This software will not save the world.
*/

/* Generated by Together */

#include "GraphicsKit.h"


using namespace VCF;


GraphicsContext::GraphicsContext()
{
	init();
}

GraphicsContext::GraphicsContext( const unsigned long& width, const unsigned long& height )
{
	init();
	
	m_contextPeer = GraphicsToolkit::getDefaultGraphicsToolkit()->createContextPeer( width, height );
	if ( NULL == m_contextPeer ){
		//throw exception
	}

	m_contextPeer->setContext( this );
}

GraphicsContext::GraphicsContext( const long& contextID )
{
	init();
	m_contextPeer = GraphicsToolkit::getDefaultGraphicsToolkit()->createContextPeer( contextID );
	if ( NULL == m_contextPeer ){
		//throw exception
	}
	m_contextPeer->setContext( this );
}

GraphicsContext::~GraphicsContext()
{
	if ( NULL != m_contextPeer ){
		delete m_contextPeer;
	}
	m_contextPeer = NULL;

	if ( NULL != m_currentFill ){
		delete m_currentFill;
	}
	m_currentFill = NULL;

	if ( NULL != m_currentStroke ){
		delete m_currentStroke;
	}
	m_currentStroke = NULL;

	if ( NULL != m_currentFont ){
		delete m_currentFont;
	}
	m_currentFont = NULL;
}

void GraphicsContext::init()
{	
	m_contextPeer = NULL;
	m_currentFill = NULL;
	m_currentStroke = NULL;
	m_currentFont = NULL;
	
	m_currentFont = new Font();

	m_theta = 0.0;
	m_xScale = 1.0;
	m_yScale = 1.0;
	m_xTranslate = 0.0;
	m_yTranslate = 0.0;
	m_xShear = 0.0;
	m_yShear = 0.0;
	m_transformMatrix.identity();
}

void GraphicsContext::setRenderingHint(const String & hintName, const unsigned long & hintValue)
{
	m_renderingHints[hintName] = hintValue;
}

void GraphicsContext::setRenderingHints(const std::map<String, unsigned long> &renderingHints )
{

}

void GraphicsContext::setCurrentFont(Font * font)
{	
	m_currentFont->copy( font );
}

void GraphicsContext::setCurrentFill(Fill * fill)
{
	m_currentFill = fill;
	if ( NULL != m_currentFill ){
		m_currentFill->setContext( this );
	}
}

void GraphicsContext::setCurrentStroke(Stroke * stroke)
{
	m_currentStroke = stroke;
	if ( NULL != m_currentStroke ){
		m_currentStroke->setContext( this );
	}
}

void GraphicsContext::draw(Path * path)
{
	if ( NULL != m_currentFill ){
		m_currentFill->render( path );
	}
	if ( NULL != m_currentStroke ){
		m_currentStroke->render( path );
	}
}

void GraphicsContext::drawImage( const double& x, const double& y, Image * image)
{
	m_contextPeer->drawImage( x, y, image );
}

void GraphicsContext::drawImageWithState( const double& x, const double& y, Image * image, const bool& enabled )
{

}

void GraphicsContext::drawImageWithinBounds( Rect* bounds, Image* image )
{
	m_contextPeer->drawImageWithinBounds( bounds, image );
}

void GraphicsContext::drawPartialImage( const double& x, const double& y, Rect* imageBounds, Image* image )
{
	m_contextPeer->drawPartialImage( x, y, imageBounds, image );
}

void GraphicsContext::getCapabilities()
{

}

void GraphicsContext::drawString( const double& x, const double& y, const String& text )
{
	m_contextPeer->textAt( x, y, text );
}

void GraphicsContext::drawStringWithState( const double& x, const double& y, const String& text, const bool& enabled )
{
	Color* shadow = GraphicsToolkit::getDefaultGraphicsToolkit()->getSystemColor( SYSCOLOR_SHADOW );
	Color* hilight = GraphicsToolkit::getDefaultGraphicsToolkit()->getSystemColor( SYSCOLOR_HIGHLIGHT );	
	Color oldColor = * getColor();
	
	setColor( hilight );
	m_contextPeer->textAt( x+1, y+1, text );

	setColor( shadow );
	m_contextPeer->textAt( x, y, text );	
	//reset the original color
	setColor( &oldColor );
}

void GraphicsContext::drawStringAlongBaseline( const double& x, const double& y, const String& text )
{
	bool oldAlignment = m_contextPeer->isTextAlignedToBaseline();
	m_contextPeer->setTextAlignment( true );
	m_contextPeer->textAt( x, y, text );
	m_contextPeer->setTextAlignment( oldAlignment );
}

void GraphicsContext::setCurrentFontState(FontState * state)
{
	m_contextPeer->setCurrentFontState( state );
}

void GraphicsContext::textAt(const double & x, const double & y, const String & text)
{
	m_contextPeer->textAt( x, y, text );
}

void GraphicsContext::rectangle(const double & x1, const double & y1, const double & x2, const double & y2)
{
	m_contextPeer->rectangle( x1, y1, x2, y2 );
}

void GraphicsContext::circle(const double & x, const double & y, const double & radius)
{
	m_contextPeer->circle( x, y, radius );
}

void GraphicsContext::ellipse(const double & x1, const double & y1, const double & x2, const double & y2, const double & angle)
{
	m_contextPeer->ellipse( x1, y1, x2, y2, angle );
}

void GraphicsContext::setCurrentStrokeState(StrokeState * state)
{
	m_contextPeer->setCurrentStrokeState( state );
}

void GraphicsContext::setCurrentFillState(FillState * state)
{
	m_contextPeer->setCurrentFillState( state );
}

void GraphicsContext::polyline(std::vector < Point * > & pts)
{
	m_contextPeer->polyline( pts );
}

void GraphicsContext::curve(const double & x1, const double & y1, const double & x2, const double & y2,
                            const double & x3, const double & y3, const double & x4, const double & y4)
{
	m_contextPeer->curve( x1, y1, x2, y2, x3, y3, x4, y4 );
}

void GraphicsContext::lineTo(const double & x, const double & y)
{
	m_contextPeer->lineTo( x, y );
}

void GraphicsContext::moveTo(const double & x, const double & y)
{
	m_contextPeer->moveTo( x, y );
}

void GraphicsContext::fillPath()
{
	m_contextPeer->fillPath();
}

void GraphicsContext::strokePath()
{
	m_contextPeer->strokePath();
}

ContextPeer* GraphicsContext::getPeer()
{
	return m_contextPeer;
}

void GraphicsContext::setOrigin( const double& x, const double& y )
{
	m_contextPeer->setOrigin( x, y );
}

Point* GraphicsContext::getOrigin()
{
	return m_contextPeer->getOrigin();
}


void GraphicsContext::copyContext( const double& x, const double& y, GraphicsContext* context )
{
	ContextPeer* ctxPeer = context->getPeer();
	m_contextPeer->copyContext( x, y, ctxPeer );
}

void GraphicsContext::setCurrentTransform( Matrix2D* transform )
{
	m_transformMatrix = *transform;
}

Matrix2D* GraphicsContext::getCurrentTransform()
{
	compositeMatrices();
	return &m_transformMatrix;
}

void GraphicsContext::setRotation( const double& theta )
{
	m_theta = theta;
}

void GraphicsContext::setTranslation( const double transX, const double& transY )
{
	m_xTranslate = transX;
	m_yTranslate = transY;
}

void GraphicsContext::setShear( const double& shearX, const double& shearY )
{
	m_xShear = shearX;
	m_yShear = shearY;
}

void GraphicsContext::setScale( const double& scaleX, const double& scaleY )
{
	m_xScale = scaleX;
	m_yScale = scaleY;
}

void GraphicsContext::compositeMatrices()
{
	Matrix2D rot;
	rot.rotate( m_theta );
	Matrix2D trans;
	trans.translate( m_xTranslate, m_yTranslate );
	Matrix2D scale;
	scale.scale( m_xScale, m_yScale );
	Matrix2D shear;
	shear.shear( m_xShear, m_yShear );
	Matrix2D tmp;
	tmp.multiply( &rot, &trans );
	tmp.multiply( &tmp, &scale );
	tmp.multiply( &tmp, &shear );
	m_transformMatrix = tmp;
}

Font* GraphicsContext::getCurrentFont()
{
	return m_currentFont;
}

void GraphicsContext::setColor( Color* color )
{
	if ( NULL != color ){
		m_color.copy( color );
		FillState* fs = m_contextPeer->getCurrentFillState();
		fs->m_Color.copy( color );
		
		StrokeState* ss = m_contextPeer->getCurrentStrokeState();
		ss->m_Color.copy( color );
	}
}

Color* GraphicsContext::getColor()
{
	return &m_color;
}

void GraphicsContext::textBoundedBy( Rect* bounds, const String& text, const bool& wordWrap )
{	
	m_contextPeer->textBoundedBy( bounds, text, wordWrap );
}

bool GraphicsContext::isXORModeOn()
{
	return m_contextPeer->isXORModeOn();
}

void GraphicsContext::setXORModeOn( const bool& XORModeOn )
{
	m_contextPeer->setXORModeOn( XORModeOn );
}

double GraphicsContext::getTextWidth( const String& text )
{
	return m_contextPeer->getTextWidth( text );
}

double GraphicsContext::getTextHeight( const String& text )
{
	return m_contextPeer->getTextHeight( text );
}

