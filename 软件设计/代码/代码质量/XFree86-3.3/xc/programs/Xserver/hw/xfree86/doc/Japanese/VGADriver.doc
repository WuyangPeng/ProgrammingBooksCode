  1996 年 01 月 07 日 XFree86 へ (S)VGA ドライバを追加する方法
  Copyright (c) 1993, 1994 David E. Wexelblat
  <dwex@XFree86.org> 著
  岡本 一幸 Kazuyuki Okamoto <ikko-@pacific.rim.or.jp> 訳
  1.3 号 - 1994 年 5 月 29 日
  ____________________________________________________________

  Table of Contents:

  1.      序文

  2.      始めに

  3.      ディレクトリ構造

  4.      生成情報の設定

  5.      バンク切り替え機能

  6.      ドライバ自身について

  6.1.    複数のチップセットとオプション

  6.2.    データ構造

  6.3.    Ident() 関数

  6.4.    ClockSelect() 関数

  6.5.    Probe() 関数

  6.6.    EnterLeave() 関数

  6.7.    Restore() 関数

  6.8.    Save() 関数

  6.9.    Init() 関数

  6.10.   Adjust() 関数

  6.11.   ValidMode() 関数

  6.12.   SaveScreen() 関数

  6.13.   GetMode() 関数

  6.14.   FbInit() 関数

  7.      新サーバーの生成

  8.      デバッグ

  9.      アドバイス

  10.     高度な話題

  11.     参考文献

  12.     ベンダー連絡先情報
  ______________________________________________________________________

  1.  序文

  XFree86 に新しい SVGA チップセットのサポートを追加することはハードウェ
  アに密着したプログラミングについて学習したい人にとって手ごたえのある作
  業です。このような作業には危険が一杯です。特に、マシンがハングアップし
  てしまうようなことは日常茶飯事です。それでも最終的に、サーバーが立ち上
  がってうまく動いてくれた時は、底知れぬ満足感にひたれます。

  SVGA チップセット対応のドライバを追加することはサーバーの基本機能を変
  更するものではありません。ただ、256 色同時発色のカラーサーバーかモノク
  ロサーバーが出来るだけです。新しいハードウェア（例えばアクセラレータ
  チップ）を追加することは重要な仕事で、文書化出来るような定型的作業には
  程遠いものです。

  それにもかかわらず、ここで行うドライバを書くようなプログラミングは良い
  入門となります。アクセラレータチップセットを追加する最初の段階では
  SVGA の上位互換としてのドライバを追加するのが良いでしょう。該当する
  チップ対応の SVGA のドライバーを書くことは新しい機能を追加するときの安
  定した開発環境を構築することになります（実際、XFree86 2.0 対応に内部で
  開発された S3, Cirrus や WD のアクセタレータチップセットのドライバでは
  そうでした）。

  さあ、例題のソースを手にいれましょう。この文書に加えて、スタブドライバ
  を提供します。これは新しいドライバの徹底した骨組みとして提供するもので
  す。この文書が大きいからといって作業が過度に難しいと思わないでくださ
  い。殆どの作業を出来る限りこの文書に沿って進めるならば、今晩のうちに理
  論的にはこの文書を料理の本のように使い、最後には動くドライバが出来るで
  しょう。

  2.  始めに

  新しいドライバを作る最初の段階はそのチップセットに関する資料を集めるこ
  とです。わたしの集めたベンダーの連絡先情報の一覧をこの文書に入れていま
  す（完璧とは言えないものですのでこの一覧に無いもので知っているものがあ
  りましたら著者まで送ってください）。チップセットのデータブックを手に入
  れる必要があります。レジスタを直接操作するプログラミングがしたいとベン
  ダーの人と話す機会に確認して下さい。（そうしないと EE 形式のデータシー
  トを送付してくれません）。何かサンプルプログラムか開発者用のキット等に
  ついて問い合わせてください。著者が一般的な SVGA について詳しく学習した
  ときは、レジスタについて知りたい殆どの事がデータシートに一覧や記事にあ
  りました。

  VGA レジスタを直接操作するようなプログラミングに慣れていない場合は
  Richard Ferraro の必読書を入手して（是非読んで！）下さい（以降の「参考
  文献」を見てください）。サーバーで何が起っているかを理解する最良の方法
  はモノクロの ``generic'' サーバーの動作を調べ、Ferraro の本に書かれて
  いる情報と比較して下さい（本に少し間違いがあることに気付くでしょ
  う）。generic な VGA レジスタを扱う関数を ``vgaHW.c'' ファイルに見つけ
  ることが出来ます。

  generic なサーバーで何が起っているか理解したら、一つかそれ以上の既存の
  SVGA サーバーについて調べてください。サポートしている SVGA チップのデ
  ータブックを入手してプログラムを追いながら文書を調査してくださ
  い。generic な VGA から何が仕様を超えていて何が仕様に収まっているか良
  く理解したら、新しいチップについてデータブックからどんな情報を得ればよ
  いか分かるでしょう。この情報を収集したら、新しいドライバーに取りかかる
  準備が出来ました。

  3.  ディレクトリ構造

  ここではソースのディレクトリ構造の概要を説明します。書こうとしているド
  ライバに関連するディレクトリ／ファイルは既知とします。リンクキットの構
  造は以降で示します。

     xc/config/cf/

        site.def
           ローカルな構成のカスタマイズ

        xf86site.def
           XFree86 のローカルな構成のカスタマイズ

     xc/programs/Xserver/hw/xfree86/
        サーバーのソース

        common/
           全サーバーに共通なファイル (XF86Config のパラメータ解析/パー
           サ, I/O デバイスハンドラ等)

           xf86.h
              `ScrnInfoRec' データ構造を含む

           xf86_Option.h
              オプションフラグを含む

           compiler.h
              インラインアセンブラマクロとユーティリティ関数を含む

        os-support/
           OS サポート層

           assyntax.h
              マクロ化したアセンブラニモニックを含む

           xf86_OSlib.h
              OS がサポートする include, define と プロトタイプ

        LinkKit/

           site.def.LK
              リンクキットの site.def 用のテンプレート

        vga256/
           256 色 VGA サーバーのディレクトリ

           vga/
              generic な VGA を取り扱うプログラム

              vga.h
                 `vgaVideoChipRec' と `vgaHWRec' データ構造を含む

              vgaHW.c
                 generic な VGA レジスタを取り扱う関数 vgaHWInit(),
                 vgaHWSave() と vgaHWRestore()を含む。

           drivers/
              SVGA ドライバのサブディレクトリを含む。各々、ドライバ用
              Imakefile, .c ファイルとバンク切り替え関数用の .s ファイル
              を含む

        vga2/
           モノクロの vga サーバーのディレクトリ。vga256 にリンクする
           ファイルと条件コンパイルで使用する差分。

           drivers/
              SVGA ドライバのサブディレクトリ。`generic' な VGA ドライバ
              もここに配置する。

        vga16/
           16 色 vga サーバーのディレクトリ。vga256 にリンクする殆どの
           ファイルと条件コンパイルで使用する差分。

           drivers/
              SVGA ドライバのサブディレクトリ。

        VGADriverDoc/
           この文書とスタブドライバ。

  リンクキットは通常 /usr/X11R6/lib/Server に導入します。リンクキットは
  サーバーの再リンクを行うのに必要な全てのものが含まれています。新しいド
  ライバを書くのとサーバーのソースの導入なしに新しいサーバーを生成するの
  に必要です。

     Server/

        site.def
           ローカルな構成のカスタマイズ

        include/
           上記 `common' ディレクトリ下にある全ての include ファイル

        drivers/
           SVGA ドライバの全て

           vga2/
              SVGA ドライバのサブディレクトリ。

           vga16/
              SVGA ドライバのサブディレクトリ。

           vga256/
              SVGA ドライバのサブディレクトリ。

        VGADriverDoc/
           この文書とスタブドライバのディレクトリ。`vgaHW.c' はここにも
           コピーされ参照されます（リンクキットの一部としては生成しませ
           ん）。

  4.  生成情報の設定

  この節では新しいドライバ用設定を行なう為の周辺の構成変更と生成段階につ
  いて説明します。この段階ではソースから生成するかリンクキットから生成す
  るかにかかわらず同様で、ただファイルの配置が異なっているだけのことで
  す。以下に構成変更について説明します:

  1. ドライバのサブディレクトリとデータ構造を決定して下さい。単一のドラ
     イバ内にそのチップセットに関連する複数のドライバを実装することが現
     状のドライバに許されるならば（実際には奨励されています）、通常チッ
     プセットのバージョンよりはベンダー名称を使用するのが良いでしょう。
     昔の XFree86 のドライバはこの慣習を採用していなかったですが現在は殆
     どのドライバがドライバのインターフェースを柔軟且つ拡張可能になるよ
     うにこの慣習を使用していますのでベンダー名称を使いましょう。

     この文書では SuperDuper Chips というベンダーを例に取り挙げます。以
     降、ドライバの名称に `sdc' を用います。

  2. カラーサーバーをサポートするかモノクロサーバーをサポートするか又は
     両方サポートするのか決定してください。この文書では、カラーとモノク
     ロ両方のサーバーをサポートするように仮定しています。カラーサーバー
     だけをサポートしたいと思う場合はモノクロのサーバーを実現する段階を
     無視してください。モノクロサーバーだけをサポートしたい場合はカラー
     サーバーの段階で一覧にある可能なモノクロサーバーを実現させ、モノク
     ロサーバーの段階は無視してください。現存する殆どのドライバーはカラ
     ーのみか、両方のサーバーをサポートしていて、``generic'' なドライバ
     ーは（現在は）モノクロサーバーをサポートしています。

  3. ドライバーのディレクトリを作成してください:

  o  ソースから作業する場合は、次のディレクトリを作成してください:

        xc/programs/Xserver/hw/xfree86/vga256/drivers/sdc
        xc/programs/Xserver/hw/xfree86/vga16/drivers/sdc
        xc/programs/Xserver/hw/xfree86/vga2/drivers/sdc

  o  リンクキットから作業する場合は次のディレクトリを作成してください:

        /usr/X11R6/lib/Server/drivers/vga256/sdc
        /usr/X11R6/lib/Server/drivers/vga16/sdc
        /usr/X11R6/lib/Server/drivers/vga2/sdc

  4. ドライバーを生成する為の Imakefiel パラメタを設定しましょう:

  o  ソースから作業するなら:

     a. xc/config/cf/xfree86.cf を編集して `sdc' を `XF86Vga256Drivers',
        `XF86Vga16Drivers' と `XF86Vga2Drivers' の定義の一覧に追加してく
        ださい。一覧の `generic' の直前（例えば最後から二番目）に `sdc'
        を追加し `sdc' を他のドライバーの探査が不正に `sdc' チップセット
        を検知しないようにしてください。

     b. xc/config/cf/xf86site.def を編集してこのファイルにいくつかの項目
        を追加してください（これは標準値の設定の作業です）。

     c. xc/programs/Xserver/hw/xfree86/LinkKit/ にある site.def.LK ファ
        イルを編集してこのファイルにいくつかの項目を追加してください。こ
        れはリンクキットに含まれる `site.def' ファイルの雛型です。

  o  リンクキットから作業をするなら、/usr/X11R6/lib/Server/site.def を編
     集して`sdc' を `XF86Vga256Drivers', `XF86Vga16Drivers' と
     `XF86Vga2Drivers' の定義に最初に書いた様に追加してください。

  5. さて新しいディレクトリに雛型のファイルをコピーしましょう:

  o  ソースから作業するなら、`stub' ファイルを次のようにコピーしてくださ
     い（ディレクトリは xc/programs/Xserver の下です）:

     Imakefile.stub =>
        hw/xfree86/vga256/drivers/sdc/Imakefile

     stub_driver.c =>
        hw/xfree86/vga256/drivers/sdc/sdc_driver.c

     stub_bank.s =>
        hw/xfree86/vga256/drivers/sdc/sdc_bank.s

     Imakefile.stub =>
        hw/xfree86/vga16/drivers/sdc/Imakefile （そして Imakefile を編集
        してコメントに従って変更してください）。

     Imakefile.stub =>
        （そして Imakefile を編集してコメントに従って変更してくださ
        い）。

  o  リンクキットから作業するなら、`stub' ファイルを次のようにコピーして
     ください:

     Imakefile.stub =>
        /usr/X11R6/lib/Server/drivers/vga256/sdc/Imakefile

     stub_driver.c =>
        /usr/X11R6/lib/Server/drivers/vga256/sdc/sdc_driver.c

     stub_bank.s =>
        /usr/X11R6/lib/Server/drivers/vga256/sdc/sdc_bank.s

     Imakefile.stub =>
        /usr/X11R6/lib/Server/drivers/vga16/sdc/Imakefile （そして
        Imakefile を編集してコメントに従って変更してください）。

     Imakefile.stub =>
        /usr/X11R6/lib/Server/drivers/vga2/sdc/Imakefile （そして
        Imakefile を編集してコメントに従って変更してください）。

  6. たった今コピーした各々のファイルを編集して `stub' を `sdc'
     に、`STUB' を `SDC' に全て置き換えてください。

     必要な準備作業は以上です。これで実際のドライバを作成する作業が出来
     ます。

  5.  バンク切り替え機能

  普通の VGA メモリマップは 0xA0000 から始まる 64k です。64k より大きな
  メモリにアクセスするには、``バンク切り替え機能(bank switching)'' - 高
  位のアドレスビットをメモリのバンク選択に使うような操作に置き換える機能
  を実現しているSuperVGA チップセットが必要です。サイズと数のバンクは変
  化し、その名称はチップセットの資料に記載されています。チップセットはバ
  ンクレジスタ無しか一つか二つのバンクレジスタを持っています。バンクレジ
  スタなしの場合は generic な VGA *だけ* ですので、関係ありません。

  新しいチップセット（例えば Trident 8900CL, Cirrus製）はビデオメモリを
  リニアに割り当てる事が出来る事に注意してください。このやり方を使う場合
  はサーバーの性能を向上させますが、現在はサポートしていません。故に新し
  いチップセットのこの機能は使用出来ません。

  殆どの SVGA チップセットは二つのバンクレジスタを持っています。データを
  画面のある領域から他の領域に単純に 'mov' 命令で移動出来るので非常に望
  ましい構造です（どんなバンク構造も ``望ましい'' と呼んでいます）。二重
  化バンキング(dual-banking) は二つの方式があり、一方は読み込み専用バン
  クと書き込み専用バンクの二つのバンク操作で、もう一方は二つの書き込み／
  読み込み兼用窓です。最初の方式は全ての SVGA メモリ窓を読み込みと書き込
  み両方に使い、二つのバンクレジスタはどちらのバンクを実際に使うのか（例
  えばET3000, ET4000 では）決定するのに使用しています。二番目の方式では
  SVGA メモリ窓を読み込み／書き込み可能な二つのバンクに分けどちらかのバ
  ンクポインタが一つの窓を制御するようになっています。この場合一つの窓が
  読み込み操作を行うときは他の窓が書き込み操作を（例えば PVGA1/Western
  Digital, Cirrus では）行うようになります。

  単一のバンクレジスタを持っているチップセットは一つのバンクへの読み込み
  と書き込みの両方のアクセスを行います。画面の一部の情報を他の部分へコピ
  ーする事はデータを読み込み、蓄え、それから書き出すという手順が要求され
  るため困難です。幸運にも、サーバーは一つのバンクのチップセットと二つの
  バンクのチップセットの両方を扱え、その挙動を次に説明するドライバデータ
  構造の項目定義で決定します。

  ドライバには`sdc_bank.s' ファイル内の三つのアセンブラ言語で書いてある
  関数が必要です。これらの関数はバンク読み込み設定 - SDCSetRead(), バン
  ク書き込み - SDCSetWrite() と 両バンク設定 - SDCSetReadWrite() です。
  一つのバンクだけのチップセット用に三つ全ての関数の入り口点を同じ関数に
  宣言できるでしょう(``tvga8900'' ドライバを例として参照してください)。

  関数はかなり単純で - バンク番号を関数の %al レジスタへ渡し、関数はシフ
  トやビットマスク等行い正しい形式でバンク番号をレジスタヘ保存し、正しい
  I/O ポートへ書き込みます。二つのバンクが読み込み専用と書き込み専用に
  なっているチップセットの場合、一回づつ各々のバンクに、計二回
  SetReadWrite()関数を実行する必要があります。二つの独立な読み込み／書き
  込み窓になっているチップセットの場合、 SetReadWrite() 関数を
  SetWrite() 関数の代わりに同じバンクに実行するべきです。

  特別な注意として、これらの関数は ``assyntax.h'' ファイルに定義している
  マクロアセンブラの書式で書く必要があります。これは OS に関係なく正しい
  アセンブラコードを生成することを保証する為です。現在、このマクロ形式は
  USL, GNU と インテルのアセンブラの書式をサポートしています。

  以上がバンク機能に関する作業です。普通、チップセットの参考書がこのプロ
  グラムの例題を掲載していますが、そうでない場合でも他のドライバの例を用
  いれば想像するのは難しくはありません。

  6.  ドライバ自身について

  さて、本来の作業である殆どのドライバの機能を sdc_driver.c ファイルに書
  く段階に来ました。先ず、ドライバの主な機能の概要は次のとおり:

  1. サーバーのチップセット記述子のデータ構造を提供します。このデータ構
     造はドライバ関数へのポインタといくつかのデータ構造の初期値も含みま
     す。

  2. ドライバ固有のチップセットのレジスタのデータ構造を提供します。この
     データ構造には一般的な部分とドライバ固有の部分があります。チップ
     セットの初期状態を保存したり、他のモードにチップセットを変えるとき
     に初期化するのに用います。

  3. ドライバがサポートしているチップセットの一覧を呼び出せるような識別
     機能を提供します。

  4. 他のチップセットと異なるということを認識してドライバがそのチップ
     セットをサポートしインストールしてあれば正の応答をし、そうでなけれ
     ば負の応答をする探査機能を提供します。

  5. ボードで可能なドットクロックを選択する機能を提供します。

  6. ドライバに依存するデータ構造を保存、回復、初期化する機能を提供しま
     す。

  7. ビデオメモリ内にディスプレイの開始アドレスを設定する機能を提供しま
     す。これはサーバーに仮想スクリーンを実現します。

  8. VT 切り替えを行う機能を提供するでしょう。

  9. モードがチップセットの使用する各々のモードに一致するかチェックする
     機能を提供するでしょう。

  詳細にドライバーのファイルを追いかける前に、重要な情報がここにありま
  す:

  1. ドライバがカラーとモノクロサーバーの両方をサポートする場合、一つの
     ファイルに両方の事例が含まれていることに注意してください。これらは
     殆ど同じですが、MONOVGA を #define してある所で両者を区別することが
     出来ます。16 色サーバーをサポートする場合、XF86VGA16 の #define が
     有効になるようにプログラムに指定してください。殆どの場合、次を
     stub_driver.c ファイルの先頭近くに指定する事で充分です。

        #ifdef XF86VGA16
        #define MONOVGA
        #endif

  2. カラーサーバーは SVGA の 8-ビットパックトピクセルモードを使用しま
     す。モノクロと vga16 サーバーは VGA の 16-色モード（4 ビットプレー
     ン）を使用します。モノクロサーバーでは 1 プレーンだけ使用します。訳
     注 : パックトピクセル： 1 ドットのピクセル（画面上の点）を表現する
     のに、連続した 8 ビットを 4 つ並べて表わす方式。 4 ビットプレーン：
     1 ドットを表わすのに、それぞれの色毎にプレーンを持ち各プレーン上の
     連続しない 8 ビット 4 つを使って表わす方式。

  3. バンク切り替えを使わないように、モノクロサーバーを設定できます。こ
     れは表示領域のメモリをたった 64k に出来る事以外は特に魅力的ではあり
     ません。

     これらを踏まえて、所定の機能を制御するチップセットからレジスタを探
     す必要があります。特に、レジスタは以下を制御します:

  1. クロック選択ビット。低位の 2 ビットは標準の（殆どの SVGA チップセッ
     トが 1 若くは 2 ビット以上持っている）周辺機器出力レジス
     タ(Miscellaneous Output Register) の一部で、8 か 16 に分解したク
     ロックを使うように設定します。

  2. バンク選択。読み書きするバンク選択の制御を行うレジスタを SVGA チッ
     プセットは一つか二つ持っているでしょう。

  3. CRTC 機能拡張。標準的な VGA レジスタは大きな表示を行うのに十分な
     ビット数を持っていません。故に SVGA チップセットは拡張したビット数
     を持っています。

  4. インターレースモード。標準的な VGA はインターレース表示をサポートし
     ていません。故に SVGA チップセットはインターレースモードを制御する
     ビットを持っています。インターレースモード制御用の設定を行うレジス
     タを追加しているいくつかのチップセットがあります。

  5. 開始アドレス。標準的な VGA だけは表示用メモリの開始アドレスを指定す
     るのに 16 ビットのアドレスを使います。これは仮想スクリーン機能で使
     うスクリーンのサイズを制限します。SVGA チップセットは通常一つかそれ
     以上の拡張ビットを持っています。

  6. レジスタロック。殆どの SVGA チップセットはレジスタを最初に
     ``unlocked'' にしない限り拡張レジスタの更新を防止します。何か意図を
     持ってレジスタの保護を無効にしたい時に必要になります。

  7. その他の機能。例えば、いくつかのチップセットが拡張 VGA メモリを
     （IBM-標準の 265k を超えて）アクセスしたい時、正しいビットを設定す
     る必要があるでしょう。または全ての拡張レジスタの内容を読み取ると
     か、目に留まった重要な何かを見る等の他の機能があるでしょう。

  運がよければ、チップセットのベンダーのデータブックに様々な BIOS モード
  用のレジスタの設定の表が掲載されているでしょう。様々な BIOS モードでど
  んな操作が可能であるか学習することが出来ます。

  6.1.  複数のチップセットとオプション

  同じベンダーから出荷している複数のチップセットは単一のドライバでサポー
  ト可能で、実際魅力的です。複数のサポートしているチップセットがある場
  合、一連の対応する #define とドライバを識別する為の変数の `SDCchipset'
  を保持して下さい。Trident と PVGA1/WD を例題として見てください（Tseng
  ET3000 と ET4000は逆の意味での例題です。つまり複数のチップセットに対応
  したドライバインターフェースが開発される前に実現してしまいました。従っ
  てこの場合はもうフォロー出来ません。）。追加するドライバはこれらと異な
  るように作業をするときはバージョンを意識するだけで良いことに注意してく
  ださい。例えば、SDC ドライバが SDC-1a,SDC-1b と SDC-2 のチップセットを
  サポートしていると仮定して下さい。この -1a と-1b は本質的には同一です
  が、-2 とは異なります。追加するドライバが -1 と -2 のチップセットをサ
  ポートすれば、-1a と -1b の違いを意識しなくても良いでしょう。この事は
  エンドユーザの作業を簡単にします。

  ユーザにドライバの挙動を制御させるか、ユーザの介入無しにドライバを決定
  できない場合は、``option'' を使いましょう。SDC チップセットを使用して
  いるボードベンダーは 8 個か 16 個のクロックパラメータをオプションで与
  えてなさいと言うでしょう。チップセットの探査の結果から決定するしか方法
  は無いので XF86Config ファイル からユーザがオプションで挙動を選択でき
  るように提供しましょう。オプションは ``xf86_option.h'' ファイルに定義
  します。再利用可能なオプションが既にそこにあるかもしれません。再利用可
  能な場合は追加するドライバに使いましょう。再利用可能で無い場合は新たに
  #define を追加し、そのファイルに 文字列->シンボルの割り当てを表形式で
  定義します。オプションの使い方を理解するには ET4000, PVGA1/WD と
  Trident のドライバを見てください。

  6.2.  データ構造

  上記の説明から何が必要なのか理解したら、ドライバのデータ構造を記入する
  段階です。最初に `vgaSDCRec' の構造に取り掛かりましょう。このデータ構
  造は SVGA の状態情報を保持するドライバ特有のデータ構造です。このデータ
  構造の最初の項目は常に `vgaHWRec std' です。この項目は汎用 VGA の一部
  分の情報を保持します。それ以降に追加するドライバが操作するレジスタ毎に
  一つの `unsigned char' の領域を取ってください。これが最初のデータ構造
  の全てです。

  次に `SDC' 構造(`vgaVideoChipRec' 型) の初期化をしなければいけません。
  これは追加するドライバをサーバーに識別させるグローバルな構造体です。そ
  の名称はすべて大文字で `SDC' としなければいけません。つまり、追加する
  ドライバのあるディレクトリの名称と一致しなければなりません。この事はリ
  ンクキットの再構成を行う時に必要なディレクトリとグローバルなデータ構造
  の全てを確認することが必須です。

  この構造体の始めの部分はドライバ関数へのポインタを単に保持します。

  次は、チップセットがバンク切り替えをどうするかについての情報を初期化し
  ます。以降の領域は次のように記入しなければいけません:

  1. ChipMapSize - サーバーのアドレス空間に割り付けるメモリ量。ほぼ通常
     64k (0xA0000 から 0xAFFFF まで) です。いくつかのチップセットは 128k
     を使います (0xA0000 から 0xBFFFF まで)。追加するチップセットにオプ
     ションを付加すると、64k の窓を 128k の窓にして Hercules またはモノ
     クロ ディスプレイ アダプタカードで SVGA として使用出来ます。

  2. ChipSegmentSize - ChipMapSize の窓内のバンクの大きさ。これもまた通
     常 64k ですが、いくつかのチップセットは割り付けられた窓を読み込み部
     分と書き込み部分に分割します（例えば PVGA1/Western Digita チップ
     セット）。

  3. ChipSegmentShift - バンク番号をマスクするときのアドレスを右シフトす
     る際のビット数。これは ChipSegmentSize の 2 を底とした log になりま
     す。

  4. ChipSegmentMask - 与えられたバンクのアドレスをマスクオフするときの
     ビットマスク。これは (ChipSegmentSize-1) になります。

  5. ChipReadBottom,ChipReadTop - 読み込み操作を行ったときの割り付けられ
     た窓のアドレス。が、チップセットが分割された読み込みと書き込みの窓
     を持っている場合を除いて、通常はおのおの 0 と 64k です。

  6. ChipWriteBottom,ChipWriteTop - 書き込み操作において上記と同様です。

  7. ChipUse2Banks - 該当チップセットが一つ又は二つのバンクレジスタを
     持っているか、いないかに関わらないブーリアン値。これはスクリーンか
     らスクリーンへの操作の設定に適正に用いられます。

     さらに 3 個の領域を記入しましょう:

  1. ChipInterlaceType - VGA_NO_DIVIDE_VERT または VGA_DIVIDE_VERT のど
     ちらかになります。いくつかのチップセットはインタレースモード用に垂
     直方向の調整数値を 2 で割ったものを必要とします。そのため、この設定
     には注意してください。

  2. ChipOptionFlags - データ構造の初期化では通常 `{0,}' にします。これ
     はこのドライバで有効な オプション を含んだビット列です。探査関数の
     終了時に適正なビット列に初期化されます。

  3. ChipRounding - 256 色サーバー用に仮想スクリーンの幅をこの値の倍数に
     なるように丸めるのに用いるため設定します。この値は通常は 8 ですが、
     いくつかのチップセットでは 4 とか 16 になります。

  6.3.  Ident() 関数

  Ident() 関数は大変単純な関数です。サーバーがこの関数を NULL を帰すまで
  繰り返し呼び出したときに、組み込まれているドライバの一覧を出力しま
  す。Ident() 関数はサポートしているチップセットの名称を返します。この関
  数は各々の繰り返しで 0 から増加する数値を渡します。

  6.4.  ClockSelect() 関数

  ClockSelect() 関数はクロックの探査をするときに（例えば `Clocks' 行を
  XF86Config ファイルで指定しなかった場合）選択したドットクロックをパラ
  メタで受け取るのに用います。受け取った数値によって関数はチップセットの
  clock-select ビットを設定します。 (CLK_REG_SAVE, CLK_SAVE_RESTORE) の
  ような値は二つのダミーとして受け取る場合があります。CLK_REG_SAVE を受
  け取った時は、関数がクロック選択途中に変更したレジスタの写しが保存され
  ています。CLK_REG_RESTORE を受け取った時は、関数がレジスタを回復しまし
  た。クロック探査がレジスタの内容を破壊しなかったことを保証します。

  受け取ったインデックスの値が不正か、もしくはクロックが不正で設定出来な
  かった場合、この関数は FALSE を返します

  6.5.  Probe() 関数

  Probe() 関数はドライバの中で多分最も重要でかつ最も直感的で無い関数で
  しょう。Probe 関数は全てのチップセットに依存せずにチップセットを識別し
  なければなりません。XF86Config ファイルに `Chipset' 行を指定した時に、
  単純な文字列比較を行います。運がよければ、チップセットの認識機構(識
  別/バージョン レジスタ, 等)があって、それがデータブックに掲載されてい
  るでしょう。さもなければ、以下に述べるような何らかの手順によって認識し
  なければなりません。

  よくレジスタに特有のパターンや、一定の拡張レジスタを探して認識します。
  又はいくつかのボードやチップセットでは、必要な情報は一定の署名文字列を
  BIOSから読みだして獲得しています。既存の探査関数を勉強する事と参考文献
  を参照する事を強くお薦めします。追加する探査が非破壊で行われていること
  を確認して、レジスタを更新するならば、更新前に保存して、更新後に回復し
  なければいけません。

  チップセットが認識できたら、Probe() 関数はいくつかの他の初期化を行う必
  要があります。

  1. XF86Config ファイルに `VideoRam' パラメタを指定しない場合は、搭載し
     ているメモリ量を特定しなければいけません。

  2. XF86Config ファイルに `Clocks' パラメタを指定しない場合は、可能な
     ドットクロックの値を特定しなければいけません。vgaGetClocks() 関数を
     呼ぶことで、可能なクロックの値とClockSelect() へのポインタを受け取
     れます。

  3. サーバーの `vga256InfoRec' 構造体の `maxClock' 領域をチップセットで
     の可能な最大ドットクロックを (KHz 単位で) 指定することをお薦めしま
     す。探査時にここを記入しないと、標準値 (現在は 99MHz ) を使用しま
     す。

  4. サーバーの `vga256InfoRec' 構造体の `chipset' 領域を搭載している
     チップセットの名称で初期化しましょう。

  5. モノクロサーバーでドライバが使用されるならば、サーバーの
     `vga256InfoRec' 構造体の `bankedMono' 領域にモノクロドライバがバン
     ク切り替えをサポートしているかどうかを指定しなければいけません。

  6. 追加するサーバーが他のオプションをサポートする場合、
     `vgaVideoChipRec' 型の `ChipOptionFlags'構造体を OFLG_SET() マクロ
     を用いてオプションの使用許可を初期設定しましょう。

  6.6.  EnterLeave() 関数

  EnterLeave() 関数はサーバー上の仮想コンソールに入ったり出たりする度に
  呼ばれます(仮想コンソールの無い OS では、この関数はサーバーの開始時に
  呼ばれ、終了時にもう一度呼ばれます)。この関数の目的は I/O の権限を(OS
  が要求するように)譲渡したり剥奪したりする事にある為と ドライバが操作し
  なければならない``保護された''レジスタへのロック解除と再ロックアクセス
  をする為です。これは、とても小さな関数ですが以降のスタブドライバのコメ
  ントにあるように実現しました。

  6.7.  Restore() 関数

  Restore() 関数は保存されたビデオ状態を回復するのに用います。restore と
  いう名称は少し誤った名称で、この関数は保存された状態を回復する事とサー
  バーが新規に作成した状態を保存する事の両方に使用します。Restore() 関数
  は次の手続きをふむ必要があります:

  1. バンク 0 を選択し、新規状態の出力に先だって要求されたバンク 0 のそ
     の他の状態情報が設定済みである事を確認する。

  2. vgaHWRestore() を状態情報の汎用 VGA 部分を回復する為に呼ぶ。この関
     数は vgaHW.c ファイルの中にあります。

  3. 状態情報のチップセット特有部分を回復する。これは単純にレジスタに書
     き込むか、変更すべき適正なビットだけに read/modify/write 操作を行
     う。クロック選択ビットの扱いを如何に行うかについて、ドライバの例題
     の中のコメントに注意事項を書いたので確認してください。

  6.8.  Save() 関数

  Save() 関数はサーバー開始時に初期ビデオ状態情報を取り出すのに使用す
  る。Save() 関数は次の手続きをふむ必要があります:

  1. バンク 0 を選択したことを確認する。

  2. vgaHWSave() を状態情報の汎用 VGA 部分を取り出す為に呼ぶ。この関数は
     vgaHW.c ファイルの中にあります。

  3. 状態情報のチップセット特有部分を取り出す。

  6.9.  Init() 関数

  Init() 関数はドライバの中で (Probe() 関数の次に) 二番目に重要です。サ
  ーバーの中に定義された表示モード各々についてデータ構造を初期化します。
  この関数は SVGA チップセットに必要な状態に `vgaSDCRec' データ構造全体
  を初期化するのに使います。構造体の汎用 VGA 部分は (これも vgaHW.c 内に
  ある) vgaHWInit() を呼ぶことにより初期化します。

  汎用の部分を初期化したら、必要なら Init() 関数が汎用レジスタのいくつか
  の初期化を行います。正しい初期化によってその他全ての領域が埋められま
  す。初期化した特有のモードの情報は `mode' パラメタであ
  る`DisplayModeRec' 構造体へのポインタで受け取ります。

  レジスタの適正なビットの初期化の方法が分かっている場合はここで初期化し
  ましょう。Restore() 関数でしかそのビットを read/modify/write 出来ない
  事を確認してください。

  6.10.  Adjust() 関数

  Adjust() 関数は比較的根本的な関数です。仮想スクリーンのスクロールや表
  示解像度の変更によって、サーバーがビデオメモリの表示用領域の開始点を調
  整する必要のあるときはいつも呼ばれます。毎回、指定した座標に合わせて
  チップセットの開始アドレスを設定します。これを実現する方法の詳細はスタ
  ブドライバの中のコメントに従ってください。

  6.11.  ValidMode() 関数

  ValidMode() 関数は必須です。何故グラフィックモードが妥当で無いのか、
  チップセットに依存した理由を調査するのに使用します。 Probe() 実行後の
  プログラムのより上位のプログラムから呼ばれます。多くの場合、特別な調査
  は必要なくこの関数は通常、単に TRUE を返します。

  6.12.  SaveScreen() 関数

  SaveScreen() 関数は殆どのチップセットでは必要ありません。追加するドラ
  イバが同期リセットをチップセットで実行する場合、拡張レジスタを更新する
  のでこの関数が必要になります（データブックに詳細に記載があります）。こ
  の関数が必要*無い*とき、特に定義は必要無く、 vgaVideoChipRec 構造体型
  で初期化した `NoopDDA' を置きましょう（NoopDDA は汎用の空の関数で
  す）。

  この関数が*必要*ならば、比較的単純な次の作業を行ってください。二回呼び
  出すのですが、一回目はリセット前と二回目はリセット後に呼び出します。前
  者の場合は 引数にSS_START を渡し、後者では SS_FINISH を渡して下さい。
  毎回、SS_START で呼び出した場合はリセットによって影響のあるレジスタを
  格納し、SS_FINISH で呼び出した場合はそれを回復する必要があります。

  6.13.  GetMode() 関数

  GetMode() 関数は XFree86 1.3 迄は使っていませんし、これは
  vgaVideoChipRec 型で `NoopDDA' を初期化したものです。

  将来、いくつかの点でこの関数はサーバーのドライバライブラリを使うサーバ
  ー且つ／又はスタンドアローンのプログラムの対話型ビデオモード調節に使用
  可能になるでしょう。この関数は SVGA レジスタを読み込み現在のビデオモー
  ドの DisplayModeRec 構造体に書き込みます。

  6.14.  FbInit() 関数

  FbInit() 関数はアクセラレータグラフィックスをサポートするドライバに必
  須です。アクセラレータチップ固有のバージョンでは標準で cfb.banked 関数
  を置き換えて使用します。vga256LowlevFuncs は置き換え可能な関数の一覧を
  含む構造体です。この構造体は vga256.h で定義しています。FbInit() 関数
  の例は et4000, pvga1 とcirrus のドライバにあります。

  この関数が必要ない場合、単に定義をしないで、vgaVideoChipRec 型で初期化
  した `NoopDDA' を置いてください。

  7.  新サーバーの生成

  この設定作業は、ソースファイルからか、リンクキットからかによらずサーバ
  ーを生成する段階の作業を行います。

  o  ソースファイルから作業をしている場合は、次の手順で行って下さい:

     xc/programs/Xserver に移動して、 `make Makefile' と入力したら `make
     Makefiles depend all' と入力します。

  o  リンクキットから作業をしている場合は、次の手順で行ってください:

     1. /usr/X11R6/lib/Server へ移動して、 `./mkmf' と入力したら

     2. 同じディレクトリで、`make' と入力します。

     最初の生成の後でサーバーの再生成を行うならば（例えば追加するドライ
     バに変更してから）:

  o  ソースファイルから作業をしている場合は、次の手順で行って下さい:

     1. 適切な drivers/ 下の ディレクトリへ移動して（例えば
        xc/programs/Xserver/hw/xfree86/vga256/drivers）、そして `make'
        と入力してください。

     2. xc/programs/Xserver へ移動して、次を入力してください。 `make
        loadXF86_SVGA' (カラーサーバーへのリンク), `make loadXF86_VGA16'
        (16 色サーバーへのリンク) 又は `make loadXF86_Mono' (モノクロサ
        ーバーへのリンク)。

  o  リンクキットから作業を行っている場合は、次の手順で行って下さい:

     1. 適切なドライバのディレクトリへ移動して、そして `make' と入力して
        ください。

     2. /usr/X11R6/lib/server に移動して、次を入力してください。 `make
        loadXF86_SVGA' (カラーサーバーへのリンク), 又は `make
        loadXF86_VGA16' (16 色サーバーへのリンク) 又は `make
        loadXF86_Mono' (モノクロサーバーへのリンク)。

  8.  デバッグ

  残念ながら新しいドライバのデバッグは辛いものです。例えば SVGA チップ
  セットのプログラムが間違った場合マシンが固まってしまうでしょう。ディス
  プレイの表示が消えたりするので、もしかすると正常に戻すために再立ち上げ
  をする必要があるかもしれません。外部端末を繋ぐか、ネットワークからログ
  インすることを*強く*お勧めします。サーバーでデバッガが動作する場合に、
  唯一合理的な方法です。複数の VT を使いながらのデバッグは基本的に時間の
  無駄です。

  マシンが固まってしまう場合は、サーバーを起動する前に一つか二つの `同
  期'を取る事を思い出すことは*とても*良いと思います。加えて、デバッグを
  始める前に必要のないファイルシステムをアンマウント（必要のない fsck が
  実行されないように）しておきましょう。

  標準ではサーバーはデバッグ用のシンボルが付属していません。デバッグでき
  るようにしたサーバーは*とても*大きなものになります。ですがデバッグの為
  のサーバーを再構築することは簡単です。次の手順で行ってください:

  1. ドライバのディレクトリへ移動してください。

  2. Makefile を編集してください。 `CDEBUGFLAGS' の *二番目*の定義を探し
     てください。次のように修正してください。

                     CDEBUGFLAGS = -g -DNO_INLINE

  (これはデバッグ用シンボルを有効にし、シングルステップ実行時の悪夢を引
  き起こす関数のインライン展開を無効にします。)

  3. `sdc_driver.o' ファイルを消してください。

  4. 上記の手順に注目してサーバーを再構築してください。

     (又は、古い .o ファイルを消した後で Makefile を修正する代わりに、単
     に `make CDEBUGFLAGS="-g -DNO_INLINE"' を実行して上記の手順でサーバ
     ーを再構築してください。)

  これを行うことによってドライバの関数にブレークポイントを設定しシングル
  ステップ実行をサーバーで行うことが出来ます。ソースから作業を行い、SVGA
  プログラミングを学習し始めたばかりならば、vgaHW.c を再構築しデバッグす
  るのがちょうど良いでしょう。

  9.  アドバイス

  全ての利用可能な参考文献と存在するプログラムを調べて、何が起っているの
  か分かるようになるまでかなりストレスを感じます。ドライバを書き始め
  る*前に*調査を行って下さい。かなり頭痛を減らすことになります。可能なら
  ば、これから追加しようとするチップセットに似たチップセットのドライバを
  探しましょう。この例題から派生させてドライバを作成できるかもしれませ
  ん。

  デバッグ中は暗く思い詰めてはいけません。はじめのうち（私もまだそうで
  す）、多分問題を抱えているときは注意深く慎重にデバッグするので迅速に成
  果が上がります。それはチップセットについての理解を高め一日か二日の内に
  ドライバが書き上がりデバッグ出来ます。この種のプログラミングを学習し始
  めた人では一週間もあればより妥当な線でしょう。

  10.  高度な話題

  新しいチップセットは二つの高度な技術領域を取り組みました: それはプログ
  ラマブルクロックジェネレータとアクセラレータの各種特性(BitBlt, line
  drawing, HW カーソル) です。これらは新しい技術領域で、正式なインター
  フェースは未だ定義されていません。これらの新しい技術領域について作業し
  たい場合は、XFree86 チームと連絡を取って開発/ベータテストチームに参画
  してください。

  11.  参考文献

  o  Programmer's Guide to the EGA and VGA Cards, 3rd ed.
     Richard Ferraro
     Addison-Wesley, 1990
     ISBN 0-201-57025-4
     (これは SVGA プログラミングの必読書です。ちょっとエラーがあるので注
     意しましょう。第 3 版でもアクセラレータビデオカードに言及していま
     す。)

  o  vgadoc4.zip
     Finn Thoegersen
     (SVGA とその他のチップセットの資料を集めたものです。wuarchive を含
     む FTP から取り寄せ可能で殆どの MS-DOS/Windows で見ることが可能で
     す。DOS/BIOS に依存したものですが、探査関数を開発する時にとても有用
     です。)

  12.  ベンダー連絡先情報

     ATI Technologies (VGA-Wonder, Mach8, Mach32)
        33 Commerce Valley Drive East" Thornhill, Ontario
        Canada L3T 7N6
        (905) 882-2600 (sales)
        (905) 882-2626 (tech support)
        (905) 764-9404 (BBS)
        (905) 882-0546 (fax)

     Chips & Technologies
        ???

     Cirrus Logic (SVGA, Accelerators - CL-GD5426)
        3100 West Warren Ave.
        Fremont, CA  94538
        (510) 623-8300 (N. CA, USA)
        (49) 8152-40084 (Germany)
        (44) 0727-872424 (UK)

     Genoa Systems (GVGA)
        75 E. Trimble Road
        San Jose, CA 95131
        (408) 432-9090 (sales)
        (408) 432-8324 (tech support)

     Headland Technologies, Inc (Video-7 VGA 1024i, VRAM II)
        46221 Landing Parkway
        Fremont, CA  94538
        (415) 623-7857

     Oak Technology, Inc (OTI-067,OTI-077)
        139 Kifer Ct.
        Sunnyvale, CA 94086
        (408) 737-0888
        (408) 737-3838 (fax)

     S3 (911, 924, 801/805, 928, 864, 868, 964, 968, 764, 765)
        (408) 980-5400

     Trident Microsystems Inc (8800, 8900, 9000)
        205 Ravendale Dr
        Mountainside, CA 94043
        (415) 691-9211

     Tseng Labs Inc,
        6 Terry Drive
        Newtown, PA  18940
        (215) 968-0502

     Weitek (Power9000, 5186)
        1060 E. Arques Ave,
        Sunnyvale, CA  94086
        (408) 738-5765

     Western Digital
        (714) 932-4900

  XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/VGADriv.sgml,v 3.10 1996/10/23 13:10:05 dawes Exp

  $XConsortium: VGADriv.sgml /main/6 1996/01/10 11:12:02 kaleb $

  ______________________________________________________________________

  このファイルは xc/programs/Xserver/hw/xfree86/doc/sgml/VGADriv.sgml,v
  3.10 1996/10/23 13:10:05 を、 岡本  一幸 ( Kazuyuki Okamoto
  <ikko-@pacific.rim.or.jp> <mailto:ikko-@pacific.rim.or.jp> ) が
  XFree86 3.2 を日本でインストールする人向けに和訳したものです。ここがお
  かしいとか、ここはこうしたほうがいいといったご意見がありましたら、電子
  メールでお知らせ下さい。原文の著作権は XFree86 プロジェクト社にありま
  す。この和訳の著作権は XFree86 プロジェクト社と岡本 一幸にありますが、
  この和訳の不具合は私に、電子メールで送って下さい。

  XFree86: xc/programs/Xserver/hw/xfree86/doc/sgml/Japanese/VGADriv.sgml,v
  3.11 1996/12/09 12:35:25 dawes Exp

  ______________________________________________________________________

  [EOF]

