.TH ACE_DLList_Iterator 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_DLList_Iterator \- A double-linked list container class iterator. 
.SH SYNOPSIS
.br
.PP
\fC#include <Containers_T.h>\fR
.PP
Inherits \fBACE_Double_Linked_List_Iterator< ACE_DLList_Node >\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_DLList_Iterator\fR (\fBACE_DLList\fR<T> &l)"
.br
.ti -1c
.RI "void \fBreset\fR (\fBACE_DLList\fR<T> &l)"
.br
.ti -1c
.RI "int \fBadvance\fR (void)"
.br
.RI "\fIMove forward by one element in the set. Returns 0 when all the items in the set have been seen, else 1.\fR"
.ti -1c
.RI "int \fBnext\fR (T *&)"
.br
.RI "\fIPass back the <next_item> that hasn't been seen in the Stack. Returns 0 when all items have been seen, else 1.\fR"
.ti -1c
.RI "T* \fBnext\fR (void) const"
.br
.ti -1c
.RI "int \fBremove\fR (void)"
.br
.RI "\fIRemoves the current item (i.e., <next>) from the list. Note that DLList iterators do not support  directly (defined in its base class) and you will need to release the element returned by it.\fR"
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDelegates to \fBACE_Double_Linked_List_Iterator\fR.\fR"
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "\fBACE_DLList\fR<T>* \fBlist_\fR"
.br
.in -1c
.SS Friends

.in +1c
.ti -1c
.RI "class \fBACE_DLList< T >\fR"
.br
.ti -1c
.RI "class \fBACE_DLList_Node\fR"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class T>  template class ACE_DLList_Iterator
A double-linked list container class iterator.
.PP
.PP
 This implementation uses \fBACE_Double_Linked_List_Iterator\fR to perform the logic behind this container class. It delegates all of its calls to \fBACE_Double_Linked_List_Iterator\fR. 
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classT> ACE_DLList_Iterator<T>::ACE_DLList_Iterator<T> (\fBACE_DLList\fR< T >& l)
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classT> int ACE_DLList_Iterator<T>::advance (void)
.PP
Move forward by one element in the set. Returns 0 when all the items in the set have been seen, else 1.
.PP
Reimplemented from \fBACE_Double_Linked_List_Iterator\fR.
.SS template<classT> void ACE_DLList_Iterator<T>::dump (void) const
.PP
Delegates to \fBACE_Double_Linked_List_Iterator\fR.
.PP
Reimplemented from \fBACE_Double_Linked_List_Iterator\fR.
.SS template<classT> T * ACE_DLList_Iterator<T>::next (void) const
.PP
Delegates to \fBACE_Double_Linked_List_Iterator\fR, except that whereas the Double_Linked_List version of next returns the node, this next returns the contents of the node DEPRECATED 
.PP
Reimplemented from \fBACE_Double_Linked_List_Iterator_Base\fR.
.SS template<classT> int ACE_DLList_Iterator<T>::next (T *&)
.PP
Pass back the <next_item> that hasn't been seen in the Stack. Returns 0 when all items have been seen, else 1.
.PP
.SS template<classT> int ACE_DLList_Iterator<T>::remove (void)
.PP
Removes the current item (i.e., <next>) from the list. Note that DLList iterators do not support  directly (defined in its base class) and you will need to release the element returned by it.
.PP
.SS template<classT> void ACE_DLList_Iterator<T>::reset (\fBACE_DLList\fR< T >& l)
.PP
Retasks the iterator to iterate over a new Double_Linked_List. This allows clients to reuse an iterator without incurring the constructor overhead. If you do use this, be aware that if there are more than one reference to this iterator, the other "clients" may be very bothered when their iterator changes. @ Here be dragons. Comments? 
.SH FRIENDS AND RELATED FUNCTION DOCUMENTATION
.PP 
.SS template<classT> class \fBACE_DLList\fR\fC [friend]\fR
.PP
.SS template<classT> class ACE_DLList_Node\fC [friend]\fR
.PP
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classT> \fBACE_DLList\fR< T >* ACE_DLList_Iterator<T>::list_\fC [private]\fR
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.