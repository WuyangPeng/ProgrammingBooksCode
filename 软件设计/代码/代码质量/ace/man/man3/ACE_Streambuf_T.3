.TH ACE_Streambuf_T 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Streambuf_T \- 
.SH SYNOPSIS
.br
.PP
\fC#include <IOStream_T.h>\fR
.PP
Inherits \fBACE_Streambuf\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Streambuf_T\fR (\fBSTREAM\fR *peer, u_int streambuf_size = ACE_STREAMBUF_SIZE, int io_mode = ios::in | ios::out)"
.br
.ti -1c
.RI "virtual \fBssize_t\fR \fBsend\fR (char *buf, \fBssize_t\fR len)"
.br
.ti -1c
.RI "virtual \fBssize_t\fR \fBrecv\fR (char *buf, \fBssize_t\fR len, \fBACE_Time_Value\fR *tv = NULL)"
.br
.ti -1c
.RI "virtual \fBssize_t\fR \fBrecv\fR (char *buf, \fBssize_t\fR len, int flags, \fBACE_Time_Value\fR * tv = NULL)"
.br
.ti -1c
.RI "virtual \fBssize_t\fR \fBrecv_n\fR (char *buf, \fBssize_t\fR len, int flags = 0, \fBACE_Time_Value\fR *tv = NULL)"
.br
.in -1c
.SS Protected Methods

.in +1c
.ti -1c
.RI "virtual ACE_HANDLE \fBget_handle\fR (void)"
.br
.in -1c
.SS Protected Attributes

.in +1c
.ti -1c
.RI "\fBSTREAM\fR* \fBpeer_\fR"
.br
.RI "\fIThis will be our \fBACE_SOCK_Stream\fR or similar object.\fR"
.in -1c
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classSTREAM> ACE_Streambuf_T<\fBSTREAM\fR>::ACE_Streambuf_T<\fBSTREAM\fR> (\fBSTREAM\fR * peer, u_int streambuf_size = ACE_STREAMBUF_SIZE, int io_mode = ios::in | ios::out)
.PP
We will be given a \fBSTREAM\fR by the \fBiostream\fR object which creates us. See the \fBACE_IOStream\fR template for how that works. Like other \fBstreambuf\fR objects, we can be input-only, output-only or both. 
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classSTREAM> virtual ACE_HANDLE ACE_Streambuf_T<\fBSTREAM\fR>::get_handle (void)\fC [protected, virtual]\fR
.PP
Reimplemented from \fBACE_Streambuf\fR.
.SS template<classSTREAM> virtual \fBssize_t\fR ACE_Streambuf_T<\fBSTREAM\fR>::recv (char * buf, \fBssize_t\fR len, int flags, \fBACE_Time_Value\fR * tv = NULL)\fC [virtual]\fR
.PP
Reimplemented from \fBACE_Streambuf\fR.
.SS template<classSTREAM> virtual \fBssize_t\fR ACE_Streambuf_T<\fBSTREAM\fR>::recv (char * buf, \fBssize_t\fR len, \fBACE_Time_Value\fR * tv = NULL)\fC [virtual]\fR
.PP
Reimplemented from \fBACE_Streambuf\fR.
.SS template<classSTREAM> virtual \fBssize_t\fR ACE_Streambuf_T<\fBSTREAM\fR>::recv_n (char * buf, \fBssize_t\fR len, int flags = 0, \fBACE_Time_Value\fR * tv = NULL)\fC [virtual]\fR
.PP
Reimplemented from \fBACE_Streambuf\fR.
.SS template<classSTREAM> virtual \fBssize_t\fR ACE_Streambuf_T<\fBSTREAM\fR>::send (char * buf, \fBssize_t\fR len)\fC [virtual]\fR
.PP
Stream connections and "unconnected connections" (ie -- datagrams) need to work just a little differently. We derive custom Streambuf objects for them and provide these functions at that time. 
.PP
Reimplemented from \fBACE_Streambuf\fR.
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classSTREAM> \fBSTREAM\fR * ACE_Streambuf_T<\fBSTREAM\fR>::peer_\fC [protected]\fR
.PP
This will be our \fBACE_SOCK_Stream\fR or similar object.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.