.TH ACE_SString 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_SString \- A very Simple String  class. This is not a general-purpose string class, and you should probably consider using  is you don't understand why this class exists... 
.SH SYNOPSIS
.br
.PP
\fC#include <SString.h>\fR
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_SString\fR (\fBACE_Allocator\fR *alloc = 0)"
.br
.RI "\fIDefault constructor.\fR"
.ti -1c
.RI "\fBACE_SString\fR (const char *s, \fBACE_Allocator\fR *alloc = 0)"
.br
.RI "\fIConstructor that copies <s> into dynamically allocated memory.\fR"
.ti -1c
.RI "\fBACE_SString\fR (const char *s, size_t len, \fBACE_Allocator\fR *alloc = 0)"
.br
.RI "\fIConstructor that copies <len> chars of <s> into dynamically allocated memory (will NUL terminate the result).\fR"
.ti -1c
.RI "\fBACE_SString\fR (const ACE_SString &)"
.br
.RI "\fICopy constructor.\fR"
.ti -1c
.RI "\fBACE_SString\fR (char c, \fBACE_Allocator\fR *alloc = 0)"
.br
.RI "\fIConstructor that copies <c> into dynamically allocated memory.\fR"
.ti -1c
.RI "\fB~ACE_SString\fR (void)"
.br
.RI "\fIDefault dtor.\fR"
.ti -1c
.RI "char \fBoperator[]\fR (size_t slot) const"
.br
.RI "\fIReturn the <slot'th> character in the string (doesn't perform bounds checking).\fR"
.ti -1c
.RI "char& \fBoperator[]\fR (size_t slot)"
.br
.RI "\fIReturn the <slot'th> character by reference in the string (doesn't perform bounds checking).\fR"
.ti -1c
.RI "ACE_SString& \fBoperator=\fR (const ACE_SString &)"
.br
.RI "\fIAssignment operator(does copy memory).\fR"
.ti -1c
.RI "ACE_SString \fBsubstring\fR (size_t offset, \fBssize_t\fR length = -1) const"
.br
.ti -1c
.RI "ACE_SString \fBsubstr\fR (size_t offset, \fBssize_t\fR length = -1) const"
.br
.RI "\fISame as substring.\fR"
.ti -1c
.RI "u_long \fBhash\fR (void) const"
.br
.RI "\fIReturns a hash value for this string.\fR"
.ti -1c
.RI "size_t \fBlength\fR (void) const"
.br
.RI "\fIReturn the length of the string.\fR"
.ti -1c
.RI "void \fBrep\fR (char *s)"
.br
.RI "\fISet the underlying pointer. Since this does not copy memory or delete existing memory use with extreme caution!!!\fR"
.ti -1c
.RI "const char* \fBrep\fR (void) const"
.br
.RI "\fIGet the underlying pointer.\fR"
.ti -1c
.RI "const char* \fBfast_rep\fR (void) const"
.br
.RI "\fIGet the underlying pointer.\fR"
.ti -1c
.RI "const char* \fBc_str\fR (void) const"
.br
.RI "\fISame as STL String's <c_str> and <fast_rep>.\fR"
.ti -1c
.RI "int \fBstrstr\fR (const ACE_SString &s) const"
.br
.RI "\fIComparison operator that will match substrings. Returns the slot of the first location that matches, else -1.\fR"
.ti -1c
.RI "int \fBfind\fR (const ACE_SString &str, int pos = 0) const"
.br
.RI "\fIFind <str> starting at pos. Returns the slot of the first location that matches (will be >= pos), else npos.\fR"
.ti -1c
.RI "int \fBfind\fR (const char *s, int pos = 0) const"
.br
.RI "\fIFind <s> starting at pos. Returns the slot of the first location that matches (will be >= pos), else npos.\fR"
.ti -1c
.RI "int \fBfind\fR (char c, int pos = 0) const"
.br
.RI "\fIFind <c> starting at pos. Returns the slot of the first location that matches (will be >= pos), else npos.\fR"
.ti -1c
.RI "int \fBrfind\fR (char c, int pos = \fBnpos\fR) const"
.br
.RI "\fIFind <c> starting at pos (counting from the end). Returns the slot of the first location that matches, else npos.\fR"
.ti -1c
.RI "int \fBoperator==\fR (const ACE_SString &s) const"
.br
.RI "\fIEquality comparison operator(must match entire string).\fR"
.ti -1c
.RI "int \fBoperator<\fR (const ACE_SString &s) const"
.br
.RI "\fILess than comparison operator.\fR"
.ti -1c
.RI "int \fBoperator>\fR (const ACE_SString &s) const"
.br
.RI "\fIGreater than comparison operator.\fR"
.ti -1c
.RI "int \fBoperator!=\fR (const ACE_SString &s) const"
.br
.RI "\fIInequality comparison operator.\fR"
.ti -1c
.RI "int \fBcompare\fR (const ACE_SString &s) const"
.br
.RI "\fIPerforms a <strcmp>-style comparison.\fR"
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Static Public Attributes

.in +1c
.ti -1c
.RI "const int \fBnpos\fR"
.br
.RI "\fINo position constant.\fR"
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "\fBACE_Allocator\fR* \fBallocator_\fR"
.br
.RI "\fIPointer to a memory allocator.\fR"
.ti -1c
.RI "size_t \fBlen_\fR"
.br
.RI "\fILength of the ACE_SString (not counting the trailing '\\0').\fR"
.ti -1c
.RI "char* \fBrep_\fR"
.br
.RI "\fIPointer to data.\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 
A very Simple String  class. This is not a general-purpose string class, and you should probably consider using  is you don't understand why this class exists...
.PP
.PP
 This class is optimized for efficiency, so it doesn't provide any internal locking. CAUTION: This class is only intended for use with applications that understand how it works. In particular, its destructor does not deallocate its memory when it is destroyed... We need this class since the  requires an object that supports the operator == and operator !=. This class uses an  to allocate memory. The user can make this a persistant class by providing an  with a persistable memory pool. 
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS ACE_SString::ACE_SString (\fBACE_Allocator\fR * alloc = 0)
.PP
Default constructor.
.PP
.SS ACE_SString::ACE_SString (const char * s, \fBACE_Allocator\fR * alloc = 0)
.PP
Constructor that copies <s> into dynamically allocated memory.
.PP
.SS ACE_SString::ACE_SString (const char * s, size_t len, \fBACE_Allocator\fR * alloc = 0)
.PP
Constructor that copies <len> chars of <s> into dynamically allocated memory (will NUL terminate the result).
.PP
.SS ACE_SString::ACE_SString (const ACE_SString &)
.PP
Copy constructor.
.PP
.SS ACE_SString::ACE_SString (char c, \fBACE_Allocator\fR * alloc = 0)
.PP
Constructor that copies <c> into dynamically allocated memory.
.PP
.SS ACE_SString::~ACE_SString (void)
.PP
Default dtor.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS const char * ACE_SString::c_str (void) const
.PP
Same as STL String's <c_str> and <fast_rep>.
.PP
.SS int ACE_SString::compare (const ACE_SString & s) const
.PP
Performs a <strcmp>-style comparison.
.PP
.SS void ACE_SString::dump (void) const
.PP
Dump the state of an object.
.PP
.SS const char * ACE_SString::fast_rep (void) const
.PP
Get the underlying pointer.
.PP
.SS int ACE_SString::find (char c, int pos = 0) const
.PP
Find <c> starting at pos. Returns the slot of the first location that matches (will be >= pos), else npos.
.PP
.SS int ACE_SString::find (const char * s, int pos = 0) const
.PP
Find <s> starting at pos. Returns the slot of the first location that matches (will be >= pos), else npos.
.PP
.SS int ACE_SString::find (const ACE_SString & str, int pos = 0) const
.PP
Find <str> starting at pos. Returns the slot of the first location that matches (will be >= pos), else npos.
.PP
.SS u_long ACE_SString::hash (void) const
.PP
Returns a hash value for this string.
.PP
.SS size_t ACE_SString::length (void) const
.PP
Return the length of the string.
.PP
.SS int ACE_SString::operator!= (const ACE_SString & s) const
.PP
Inequality comparison operator.
.PP
.SS int ACE_SString::operator< (const ACE_SString & s) const
.PP
Less than comparison operator.
.PP
.SS ACE_SString & ACE_SString::operator= (const ACE_SString &)
.PP
Assignment operator(does copy memory).
.PP
.SS int ACE_SString::operator== (const ACE_SString & s) const
.PP
Equality comparison operator(must match entire string).
.PP
.SS int ACE_SString::operator> (const ACE_SString & s) const
.PP
Greater than comparison operator.
.PP
.SS char & ACE_SString::operator[] (size_t slot)
.PP
Return the <slot'th> character by reference in the string (doesn't perform bounds checking).
.PP
.SS char ACE_SString::operator[] (size_t slot) const
.PP
Return the <slot'th> character in the string (doesn't perform bounds checking).
.PP
.SS const char * ACE_SString::rep (void) const
.PP
Get the underlying pointer.
.PP
.SS void ACE_SString::rep (char * s)
.PP
Set the underlying pointer. Since this does not copy memory or delete existing memory use with extreme caution!!!
.PP
.SS int ACE_SString::rfind (char c, int pos = \fBnpos\fR) const
.PP
Find <c> starting at pos (counting from the end). Returns the slot of the first location that matches, else npos.
.PP
.SS int ACE_SString::strstr (const ACE_SString & s) const
.PP
Comparison operator that will match substrings. Returns the slot of the first location that matches, else -1.
.PP
.SS ACE_SString ACE_SString::substr (size_t offset, \fBssize_t\fR length = -1) const
.PP
Same as substring.
.PP
.SS ACE_SString ACE_SString::substring (size_t offset, \fBssize_t\fR length = -1) const
.PP
Return a substring given an offset and length, if length == -1 use rest of str return empty substring if offset or offset/length are invalid 
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS ACE_SString::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
.SS \fBACE_Allocator\fR * ACE_SString::allocator_\fC [private]\fR
.PP
Pointer to a memory allocator.
.PP
.SS size_t ACE_SString::len_\fC [private]\fR
.PP
Length of the ACE_SString (not counting the trailing '\\0').
.PP
.SS const int ACE_SString::npos\fC [static]\fR
.PP
No position constant.
.PP
.SS char * ACE_SString::rep_\fC [private]\fR
.PP
Pointer to data.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.