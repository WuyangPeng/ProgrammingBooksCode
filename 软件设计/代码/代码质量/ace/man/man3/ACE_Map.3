.TH ACE_Map 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Map \- Defines a map interface. 
.SH SYNOPSIS
.br
.PP
\fC#include <Map_T.h>\fR
.PP
Inherited by \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, \fBACE_Map_Impl\fR, and \fBACE_Map_Manager_Adapter\fR.
.PP
.SS Public Types

.in +1c
.ti -1c
.RI "typedef KEY \fBkey_type\fR"
.br
.ti -1c
.RI "typedef VALUE \fBmapped_type\fR"
.br
.ti -1c
.RI "typedef \fBACE_Reference_Pair\fR<const KEY, VALUE> \fBvalue_type\fR"
.br
.ti -1c
.RI "typedef \fBACE_Iterator\fR<\fBvalue_type\fR> \fBiterator\fR"
.br
.ti -1c
.RI "typedef \fBACE_Reverse_Iterator\fR<\fBvalue_type\fR> \fBreverse_iterator\fR"
.br
.ti -1c
.RI "typedef \fBACE_Iterator_Impl\fR<\fBvalue_type\fR> \fBiterator_implementation\fR"
.br
.ti -1c
.RI "typedef \fBACE_Reverse_Iterator_Impl\fR<\fBvalue_type\fR> \fBreverse_iterator_implementation\fR"
.br
.in -1c
.SS Public Methods

.in +1c
.ti -1c
.RI "virtual \fB~ACE_Map\fR (void)"
.br
.RI "\fIClose down and release dynamically allocated resources.\fR"
.ti -1c
.RI "virtual int \fBopen\fR (size_t length = ACE_DEFAULT_MAP_SIZE, \fBACE_Allocator\fR *alloc = 0) = 0"
.br
.RI "\fIInitialize a <Map> with size <length>.\fR"
.ti -1c
.RI "virtual int \fBclose\fR (void) = 0"
.br
.RI "\fIClose down a <Map> and release dynamically allocated resources.\fR"
.ti -1c
.RI "virtual int \fBbind\fR (const KEY &key, const VALUE &value) = 0"
.br
.ti -1c
.RI "virtual int \fBbind_modify_key\fR (const VALUE &value, KEY &key) = 0"
.br
.ti -1c
.RI "virtual int \fBcreate_key\fR (KEY &key) = 0"
.br
.ti -1c
.RI "virtual int \fBbind_create_key\fR (const VALUE &value, KEY &key) = 0"
.br
.ti -1c
.RI "virtual int \fBbind_create_key\fR (const VALUE &value) = 0"
.br
.ti -1c
.RI "virtual int \fBrecover_key\fR (const KEY &modified_key, KEY &original_key) = 0"
.br
.RI "\fIRecovers the original key potentially modified by the map during <bind_modify_key>.\fR"
.ti -1c
.RI "virtual int \fBrebind\fR (const KEY &key, const VALUE &value) = 0"
.br
.ti -1c
.RI "virtual int \fBrebind\fR (const KEY &key, const VALUE &value, VALUE &old_value) = 0"
.br
.ti -1c
.RI "virtual int \fBrebind\fR (const KEY &key, const VALUE &value, KEY &old_key, VALUE &old_value) = 0"
.br
.ti -1c
.RI "virtual int \fBtrybind\fR (const KEY &key, VALUE &value) = 0"
.br
.ti -1c
.RI "virtual int \fBfind\fR (const KEY &key, VALUE &value) = 0"
.br
.RI "\fILocate <value> associated with <key>.\fR"
.ti -1c
.RI "virtual int \fBfind\fR (const KEY &key) = 0"
.br
.RI "\fIIs <key> in the map?\fR"
.ti -1c
.RI "virtual int \fBunbind\fR (const KEY &key) = 0"
.br
.RI "\fIRemove <key> from the map.\fR"
.ti -1c
.RI "virtual int \fBunbind\fR (const KEY &key, VALUE &value) = 0"
.br
.RI "\fIRemove <key> from the map, and return the <value> associated with <key>.\fR"
.ti -1c
.RI "virtual size_t \fBcurrent_size\fR (void) const = 0"
.br
.RI "\fIReturn the current size of the map.\fR"
.ti -1c
.RI "virtual size_t \fBtotal_size\fR (void) const = 0"
.br
.RI "\fIReturn the total size of the map.\fR"
.ti -1c
.RI "virtual void \fBdump\fR (void) const = 0"
.br
.RI "\fIDump the state of an object.\fR"
.ti -1c
.RI "\fBiterator\fR \fBbegin\fR (void)"
.br
.RI "\fIReturn forward iterator.\fR"
.ti -1c
.RI "\fBiterator\fR \fBend\fR (void)"
.br
.ti -1c
.RI "\fBreverse_iterator\fR \fBrbegin\fR (void)"
.br
.RI "\fIReturn reverse iterator.\fR"
.ti -1c
.RI "\fBreverse_iterator\fR \fBrend\fR (void)"
.br
.in -1c
.SS Protected Methods

.in +1c
.ti -1c
.RI "\fBACE_Map\fR (void)"
.br
.ti -1c
.RI "virtual \fBACE_Iterator_Impl\fR<\fBACE_Reference_Pair\fR<const KEY, VALUE> >* \fBbegin_impl\fR (void) = 0"
.br
.RI "\fIReturn forward iterator.\fR"
.ti -1c
.RI "virtual \fBACE_Iterator_Impl\fR<\fBACE_Reference_Pair\fR<const KEY, VALUE> >* \fBend_impl\fR (void) = 0"
.br
.ti -1c
.RI "virtual \fBACE_Reverse_Iterator_Impl\fR<\fBACE_Reference_Pair\fR<const KEY, VALUE> >* \fBrbegin_impl\fR (void) = 0"
.br
.RI "\fIReturn reverse iterator.\fR"
.ti -1c
.RI "virtual \fBACE_Reverse_Iterator_Impl\fR<\fBACE_Reference_Pair\fR<const KEY, VALUE> >* \fBrend_impl\fR (void) = 0"
.br
.in -1c
.SS Private Methods

.in +1c
.ti -1c
.RI "void \fBoperator=\fR (const ACE_Map<KEY, VALUE> &)"
.br
.ti -1c
.RI "\fBACE_Map\fR (const ACE_Map<KEY, VALUE> &)"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class KEY, class VALUE>  template class ACE_Map
Defines a map interface.
.PP
.PP
 Implementation to be provided by subclasses. 
.PP
.SH MEMBER TYPEDEF DOCUMENTATION
.PP 
.SS template<classKEY, classVALUE> typedef \fBACE_Iterator\fR<\fBvalue_type\fR> ACE_Map<KEY, VALUE>::iterator
.PP
.SS template<classKEY, classVALUE> typedef \fBACE_Iterator_Impl\fR<\fBvalue_type\fR> ACE_Map<KEY, VALUE>::iterator_implementation
.PP
.SS template<classKEY, classVALUE> typedef KEY ACE_Map<KEY, VALUE>::key_type
.PP
.SS template<classKEY, classVALUE> typedef VALUE ACE_Map<KEY, VALUE>::mapped_type
.PP
.SS template<classKEY, classVALUE> typedef \fBACE_Reverse_Iterator\fR<\fBvalue_type\fR> ACE_Map<KEY, VALUE>::reverse_iterator
.PP
.SS template<classKEY, classVALUE> typedef \fBACE_Reverse_Iterator_Impl\fR<\fBvalue_type\fR> ACE_Map<KEY, VALUE>::reverse_iterator_implementation
.PP
.SS template<classKEY, classVALUE> typedef \fBACE_Reference_Pair\fR<const KEY, VALUE> ACE_Map<KEY, VALUE>::value_type
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classKEY, classVALUE> ACE_Map<KEY, VALUE>::~ACE_Map<KEY, VALUE> (void)\fC [virtual]\fR
.PP
Close down and release dynamically allocated resources.
.PP
.SS template<classKEY, classVALUE> ACE_Map<KEY, VALUE>::ACE_Map<KEY, VALUE> (void)\fC [protected]\fR
.PP
.SS template<classKEY, classVALUE> ACE_Map<KEY, VALUE>::ACE_Map<KEY, VALUE> (const ACE_Map< KEY,VALUE >&)\fC [private]\fR
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classKEY, classVALUE> \fBiterator\fR ACE_Map<KEY, VALUE>::begin (void)
.PP
Return forward iterator.
.PP
.SS template<classKEY, classVALUE> \fBACE_Iterator_Impl\fR< \fBACE_Reference_Pair\fR< const KEY,VALUE > >* ACE_Map<KEY, VALUE>::begin_impl (void)\fC [protected, pure virtual]\fR
.PP
Return forward iterator.
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> int ACE_Map<KEY, VALUE>::bind (const KEY & key, const VALUE & value)\fC [pure virtual]\fR
.PP
Add <key>/<value> pair to the map. If <key> is already in the map then no changes are made and 1 is returned. Returns 0 on a successful addition. This function fails for maps that do not allow user specified keys. <key> is an "in" parameter. 
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> int ACE_Map<KEY, VALUE>::bind_create_key (const VALUE & value)\fC [pure virtual]\fR
.PP
Add <value> to the map. The user does not care about the corresponding key produced by the Map. For maps that do not naturally produce keys, the map adapters will use the <KEY_GENERATOR> class to produce a key. However, the users are responsible for not jeopardizing this key production scheme by using user specified keys with keys produced by the key generator. 
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> int ACE_Map<KEY, VALUE>::bind_create_key (const VALUE & value, KEY & key)\fC [pure virtual]\fR
.PP
Add <value> to the map, and the corresponding key produced by the Map is returned through <key> which is an "out" parameter. For maps that do not naturally produce keys, the map adapters will use the <KEY_GENERATOR> class to produce a key. However, the users are responsible for not jeopardizing this key production scheme by using user specified keys with keys produced by the key generator. 
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> int ACE_Map<KEY, VALUE>::bind_modify_key (const VALUE & value, KEY & key)\fC [pure virtual]\fR
.PP
Add <key>/<value> pair to the map. <key> is an "inout" parameter and maybe modified/extended by the map to add additional information. To recover original key, call the <recover_key> method. 
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> int ACE_Map<KEY, VALUE>::close (void)\fC [pure virtual]\fR
.PP
Close down a <Map> and release dynamically allocated resources.
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> int ACE_Map<KEY, VALUE>::create_key (KEY & key)\fC [pure virtual]\fR
.PP
Produce a key and return it through <key> which is an "out" parameter. For maps that do not naturally produce keys, the map adapters will use the <KEY_GENERATOR> class to produce a key. However, the users are responsible for not jeopardizing this key production scheme by using user specified keys with keys produced by the key generator. 
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> size_t ACE_Map<KEY, VALUE>::current_size (void) const\fC [pure virtual]\fR
.PP
Return the current size of the map.
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> void ACE_Map<KEY, VALUE>::dump (void) const\fC [pure virtual]\fR
.PP
Dump the state of an object.
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> \fBiterator\fR ACE_Map<KEY, VALUE>::end (void)
.PP
.SS template<classKEY, classVALUE> virtual \fBACE_Iterator_Impl\fR<\fBACE_Reference_Pair\fR<const KEY, VALUE> >* ACE_Map<KEY, VALUE>::end_impl (void)\fC [protected, pure virtual]\fR
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> int ACE_Map<KEY, VALUE>::find (const KEY & key)\fC [pure virtual]\fR
.PP
Is <key> in the map?
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> int ACE_Map<KEY, VALUE>::find (const KEY & key, VALUE & value)\fC [pure virtual]\fR
.PP
Locate <value> associated with <key>.
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> int ACE_Map<KEY, VALUE>::open (size_t length = ACE_DEFAULT_MAP_SIZE, \fBACE_Allocator\fR * alloc = 0)\fC [pure virtual]\fR
.PP
Initialize a <Map> with size <length>.
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> void ACE_Map<KEY, VALUE>::operator= (const ACE_Map< KEY,VALUE >&)\fC [private]\fR
.PP
.SS template<classKEY, classVALUE> \fBreverse_iterator\fR ACE_Map<KEY, VALUE>::rbegin (void)
.PP
Return reverse iterator.
.PP
.SS template<classKEY, classVALUE> \fBACE_Reverse_Iterator_Impl\fR< \fBACE_Reference_Pair\fR< const KEY,VALUE > >* ACE_Map<KEY, VALUE>::rbegin_impl (void)\fC [protected, pure virtual]\fR
.PP
Return reverse iterator.
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> int ACE_Map<KEY, VALUE>::rebind (const KEY & key, const VALUE & value, KEY & old_key, VALUE & old_value)\fC [pure virtual]\fR
.PP
Reassociate <key> with <value>, storing the old key and value into the "out" parameters <old_key> and <old_value>. The function fails if <key> is not in the map for maps that do not allow user specified keys. However, for maps that allow user specified keys, if the key is not in the map, a new <key>/<value> association is created. 
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> int ACE_Map<KEY, VALUE>::rebind (const KEY & key, const VALUE & value, VALUE & old_value)\fC [pure virtual]\fR
.PP
Reassociate <key> with <value>, storing the old value into the "out" parameter <old_value>. The function fails if <key> is not in the map for maps that do not allow user specified keys. However, for maps that allow user specified keys, if the key is not in the map, a new <key>/<value> association is created. 
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> int ACE_Map<KEY, VALUE>::rebind (const KEY & key, const VALUE & value)\fC [pure virtual]\fR
.PP
Reassociate <key> with <value>. The function fails if <key> is not in the map for maps that do not allow user specified keys. However, for maps that allow user specified keys, if the key is not in the map, a new <key>/<value> association is created. 
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> int ACE_Map<KEY, VALUE>::recover_key (const KEY & modified_key, KEY & original_key)\fC [pure virtual]\fR
.PP
Recovers the original key potentially modified by the map during <bind_modify_key>.
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> \fBreverse_iterator\fR ACE_Map<KEY, VALUE>::rend (void)
.PP
.SS template<classKEY, classVALUE> virtual \fBACE_Reverse_Iterator_Impl\fR<\fBACE_Reference_Pair\fR<const KEY, VALUE> >* ACE_Map<KEY, VALUE>::rend_impl (void)\fC [protected, pure virtual]\fR
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> size_t ACE_Map<KEY, VALUE>::total_size (void) const\fC [pure virtual]\fR
.PP
Return the total size of the map.
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> int ACE_Map<KEY, VALUE>::trybind (const KEY & key, VALUE & value)\fC [pure virtual]\fR
.PP
Associate <key> with <value> if and only if <key> is not in the map. If <key> is already in the map, then the <value> parameter is overwritten with the existing value in the map. Returns 0 if a new <key>/<value> association is created. Returns 1 if an attempt is made to bind an existing entry. This function fails for maps that do not allow user specified keys. 
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> int ACE_Map<KEY, VALUE>::unbind (const KEY & key, VALUE & value)\fC [pure virtual]\fR
.PP
Remove <key> from the map, and return the <value> associated with <key>.
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.
.SS template<classKEY, classVALUE> int ACE_Map<KEY, VALUE>::unbind (const KEY & key)\fC [pure virtual]\fR
.PP
Remove <key> from the map.
.PP
Reimplemented in \fBACE_Map_Impl\fR, \fBACE_Active_Map_Manager_Adapter\fR, \fBACE_Hash_Map_Manager_Ex_Adapter\fR, and \fBACE_Map_Manager_Adapter\fR.

.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.