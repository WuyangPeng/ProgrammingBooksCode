.TH ACE_Message_Queue_Ex 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Message_Queue_Ex \- A threaded message queueing facility, modeled after the queueing facilities in System V STREAMs. 
.SH SYNOPSIS
.br
.PP
\fC#include <Message_Queue_T.h>\fR
.PP
.SS Public Types

.in +1c
.ti -1c
.RI "enum { \fBDEFUALT_PRIORITY\fR = 0 }"
.br
.in -1c
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Message_Queue_Ex\fR (size_t high_water_mark = ACE_Message_Queue_Base::DEFAULT_HWM, size_t low_water_mark = ACE_Message_Queue_Base::DEFAULT_LWM, \fBACE_Notification_Strategy\fR * = 0)"
.br
.ti -1c
.RI "virtual int \fBopen\fR (size_t hwm = ACE_Message_Queue_Base::DEFAULT_HWM, size_t lwm = ACE_Message_Queue_Base::DEFAULT_LWM, \fBACE_Notification_Strategy\fR * = 0)"
.br
.ti -1c
.RI "virtual int \fBclose\fR (void)"
.br
.RI "\fIClose down the message queue and release all resources.\fR"
.ti -1c
.RI "virtual \fB~ACE_Message_Queue_Ex\fR (void)"
.br
.RI "\fIClose down the message queue and release all resources.\fR"
.ti -1c
.RI "virtual int \fBpeek_dequeue_head\fR (ACE_MESSAGE_TYPE *&first_item, \fBACE_Time_Value\fR *timeout = 0)"
.br
.ti -1c
.RI "virtual int \fBenqueue_prio\fR (ACE_MESSAGE_TYPE *new_item, \fBACE_Time_Value\fR *timeout = 0)"
.br
.ti -1c
.RI "virtual int \fBenqueue\fR (ACE_MESSAGE_TYPE *new_item, \fBACE_Time_Value\fR *timeout = 0)"
.br
.ti -1c
.RI "virtual int \fBenqueue_tail\fR (ACE_MESSAGE_TYPE *new_item, \fBACE_Time_Value\fR *timeout = 0)"
.br
.ti -1c
.RI "virtual int \fBenqueue_head\fR (ACE_MESSAGE_TYPE *new_item, \fBACE_Time_Value\fR *timeout = 0)"
.br
.ti -1c
.RI "virtual int \fBdequeue\fR (ACE_MESSAGE_TYPE *&first_item, \fBACE_Time_Value\fR *timeout = 0)"
.br
.RI "\fIThis method is an alias for the following <dequeue_head> method.\fR"
.ti -1c
.RI "virtual int \fBdequeue_head\fR (ACE_MESSAGE_TYPE *&first_item, \fBACE_Time_Value\fR *timeout = 0)"
.br
.ti -1c
.RI "virtual int \fBis_full\fR (void)"
.br
.RI "\fITrue if queue is full, else false.\fR"
.ti -1c
.RI "virtual int \fBis_empty\fR (void)"
.br
.RI "\fITrue if queue is empty, else false.\fR"
.ti -1c
.RI "virtual size_t \fBmessage_bytes\fR (void)"
.br
.ti -1c
.RI "virtual size_t \fBmessage_length\fR (void)"
.br
.ti -1c
.RI "virtual size_t \fBmessage_count\fR (void)"
.br
.ti -1c
.RI "virtual void \fBmessage_bytes\fR (size_t new_size)"
.br
.ti -1c
.RI "virtual void \fBmessage_length\fR (size_t new_length)"
.br
.ti -1c
.RI "virtual size_t \fBhigh_water_mark\fR (void)"
.br
.ti -1c
.RI "virtual void \fBhigh_water_mark\fR (size_t hwm)"
.br
.ti -1c
.RI "virtual size_t \fBlow_water_mark\fR (void)"
.br
.ti -1c
.RI "virtual void \fBlow_water_mark\fR (size_t lwm)"
.br
.ti -1c
.RI "virtual int \fBdeactivate\fR (void)"
.br
.ti -1c
.RI "virtual int \fBactivate\fR (void)"
.br
.ti -1c
.RI "virtual int \fBdeactivated\fR (void)"
.br
.RI "\fIReturns true if <deactivated_> is enabled.\fR"
.ti -1c
.RI "virtual int \fBnotify\fR (void)"
.br
.ti -1c
.RI "virtual \fBACE_Notification_Strategy\fR* \fBnotification_strategy\fR (void)"
.br
.RI "\fIGet/set the notification strategy for the <Message_Queue>.\fR"
.ti -1c
.RI "virtual void \fBnotification_strategy\fR (\fBACE_Notification_Strategy\fR *s)"
.br
.ti -1c
.RI "virtual ACE_SYNCH_MUTEX_T& \fBlock\fR (void)"
.br
.RI "\fIReturns a reference to the lock used by the .\fR"
.ti -1c
.RI "virtual void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "\fBACE_Message_Queue\fR<ACE_SYNCH_USE> \fBqueue_\fR"
.br
.RI "\fIImplement this via an .\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class ACE_MESSAGE_TYPE, ACE_SYNCH_DECL>  template class ACE_Message_Queue_Ex
A threaded message queueing facility, modeled after the queueing facilities in System V STREAMs.
.PP
.PP
 An  is a strongly-typed version of the . If  is  then all operations are thread-safe. Otherwise, if it's  then there's no locking overhead. 
.PP
.SH MEMBER ENUMERATION DOCUMENTATION
.PP 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> anonymous enum
.PP
\fBEnumeration values:\fR
.in +1c
.TP
\fB\fIDEFUALT_PRIORITY\fR \fR
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, > (size_t high_water_mark = ACE_Message_Queue_Base::DEFAULT_HWM, size_t low_water_mark = ACE_Message_Queue_Base::DEFAULT_LWM, \fBACE_Notification_Strategy\fR * = 0)
.PP
Initialize an . The <high_water_mark> determines how many bytes can be stored in a queue before it's considered "full." Supplier threads must block until the queue is no longer full. The <low_water_mark> determines how many bytes must be in the queue before supplier threads are allowed to enqueue additional s. By default, the <high_water_mark> equals the <low_water_mark>, which means that suppliers will be able to enqueue new messages as soon as a consumer removes any message from the queue. Making the <low_water_mark> smaller than the <high_water_mark> forces consumers to drain more messages from the queue before suppliers can enqueue new messages, which can minimize the "silly window syndrome." 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::~ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, > (void)\fC [virtual]\fR
.PP
Close down the message queue and release all resources.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> int ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::activate (void)\fC [virtual]\fR
.PP
Reactivate the queue so that threads can enqueue and dequeue messages again. Returns WAS_INACTIVE if queue was inactive before the call and WAS_ACTIVE if queue was active before the call. 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> int ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::close (void)\fC [virtual]\fR
.PP
Close down the message queue and release all resources.
.PP
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> int ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::deactivate (void)\fC [virtual]\fR
.PP
Deactivate the queue and wakeup all threads waiting on the queue so they can continue. No messages are removed from the queue, however. Any other operations called until the queue is activated again will immediately return -1 with <errno> == ESHUTDOWN. Returns WAS_INACTIVE if queue was inactive before the call and WAS_ACTIVE if queue was active before the call. 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> int ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::deactivated (void)\fC [virtual]\fR
.PP
Returns true if <deactivated_> is enabled.
.PP
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> int ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::dequeue (ACE_MESSAGE_TYPE *& first_item, \fBACE_Time_Value\fR * timeout = 0)\fC [virtual]\fR
.PP
This method is an alias for the following <dequeue_head> method.
.PP
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> int ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::dequeue_head (ACE_MESSAGE_TYPE *& first_item, \fBACE_Time_Value\fR * timeout = 0)\fC [virtual]\fR
.PP
Dequeue and return the  at the head of the queue. Note that <timeout> uses <{absolute}> time rather than <{relative}> time. If the <timeout> elapses without receiving a message -1 is returned and <errno> is set to <EWOULDBLOCK>. If the queue is deactivated -1 is returned and <errno> is set to <ESHUTDOWN>. Otherwise, returns -1 on failure, else the number of items still on the queue. 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> void ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::dump (void) const\fC [virtual]\fR
.PP
Dump the state of an object.
.PP
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> int ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::enqueue (ACE_MESSAGE_TYPE * new_item, \fBACE_Time_Value\fR * timeout = 0)\fC [virtual]\fR
.PP
This is an alias for <enqueue_prio>. It's only here for backwards compatibility and will go away in a subsequent release. Please use <enqueue_prio> instead. Note that <timeout> uses <{absolute}> time rather than <{relative}> time. 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> int ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::enqueue_head (ACE_MESSAGE_TYPE * new_item, \fBACE_Time_Value\fR * timeout = 0)\fC [virtual]\fR
.PP
Enqueue an  at the head of the queue. Note that <timeout> uses <{absolute}> time rather than <{relative}> time. If the <timeout> elapses without receiving a message -1 is returned and <errno> is set to <EWOULDBLOCK>. If the queue is deactivated -1 is returned and <errno> is set to <ESHUTDOWN>. Otherwise, returns -1 on failure, else the number of items still on the queue. 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> int ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::enqueue_prio (ACE_MESSAGE_TYPE * new_item, \fBACE_Time_Value\fR * timeout = 0)\fC [virtual]\fR
.PP
Enqueue an  into the <Message_Queue> in accordance with its <msg_priority> (0 is lowest priority). FIFO order is maintained when messages of the same priority are inserted consecutively. Note that <timeout> uses <{absolute}> time rather than <{relative}> time. If the <timeout> elapses without receiving a message -1 is returned and <errno> is set to <EWOULDBLOCK>. If the queue is deactivated -1 is returned and <errno> is set to <ESHUTDOWN>. Otherwise, returns -1 on failure, else the number of items still on the queue. 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> int ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::enqueue_tail (ACE_MESSAGE_TYPE * new_item, \fBACE_Time_Value\fR * timeout = 0)\fC [virtual]\fR
.PP
Enqueue an  at the end of the queue. Note that <timeout> uses <{absolute}> time rather than <{relative}> time. If the <timeout> elapses without receiving a message -1 is returned and <errno> is set to <EWOULDBLOCK>. If the queue is deactivated -1 is returned and <errno> is set to <ESHUTDOWN>. Otherwise, returns -1 on failure, else the number of items still on the queue. 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> void ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::high_water_mark (size_t hwm)\fC [virtual]\fR
.PP
Set the high watermark, which determines how many bytes can be stored in a queue before it's considered "full." 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> size_t ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::high_water_mark (void)\fC [virtual]\fR
.PP
Get high watermark. 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> int ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::is_empty (void)\fC [virtual]\fR
.PP
True if queue is empty, else false.
.PP
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> int ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::is_full (void)\fC [virtual]\fR
.PP
True if queue is full, else false.
.PP
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> ACE_SYNCH_MUTEX_T & ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::lock (void)\fC [inline, virtual]\fR
.PP
Returns a reference to the lock used by the .
.PP
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> void ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::low_water_mark (size_t lwm)\fC [virtual]\fR
.PP
Set the low watermark, which determines how many bytes must be in the queue before supplier threads are allowed to enqueue additional s. 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> size_t ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::low_water_mark (void)\fC [virtual]\fR
.PP
Get low watermark. 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> void ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::message_bytes (size_t new_size)\fC [virtual]\fR
.PP
New value of the number of total bytes on the queue, i.e., sum of the message block sizes. 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> size_t ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::message_bytes (void)\fC [virtual]\fR
.PP
Number of total bytes on the queue, i.e., sum of the message block sizes. 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> size_t ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::message_count (void)\fC [virtual]\fR
.PP
Number of total messages on the queue. 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> void ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::message_length (size_t new_length)\fC [virtual]\fR
.PP
New value of the number of total length on the queue, i.e., sum of the message block lengths. 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> size_t ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::message_length (void)\fC [virtual]\fR
.PP
Number of total length on the queue, i.e., sum of the message block lengths. 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> virtual void ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::notification_strategy (\fBACE_Notification_Strategy\fR * s)\fC [virtual]\fR
.PP
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> \fBACE_Notification_Strategy\fR * ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::notification_strategy (void)\fC [virtual]\fR
.PP
Get/set the notification strategy for the <Message_Queue>.
.PP
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> int ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::notify (void)\fC [virtual]\fR
.PP
This hook is automatically invoked by <enqueue_head>, <enqueue_tail>, and <enqueue_prio> when a new item is inserted into the queue. Subclasses can override this method to perform specific notification strategies (e.g., signaling events for a <WFMO_Reactor>, notifying a <Reactor>, etc.). In a multi-threaded application with concurrent consumers, there is no guarantee that the queue will be still be non-empty by the time the notification occurs. 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> int ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::open (size_t hwm = ACE_Message_Queue_Base::DEFAULT_HWM, size_t lwm = ACE_Message_Queue_Base::DEFAULT_LWM, \fBACE_Notification_Strategy\fR * = 0)\fC [virtual]\fR
.PP
Initialize an . The <high_water_mark> determines how many bytes can be stored in a queue before it's considered "full." Supplier threads must block until the queue is no longer full. The <low_water_mark> determines how many bytes must be in the queue before supplier threads are allowed to enqueue additional s. By default, the <high_water_mark> equals the <low_water_mark>, which means that suppliers will be able to enqueue new messages as soon as a consumer removes any message from the queue. Making the <low_water_mark> smaller than the <high_water_mark> forces consumers to drain more messages from the queue before suppliers can enqueue new messages, which can minimize the "silly window syndrome." 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> int ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::peek_dequeue_head (ACE_MESSAGE_TYPE *& first_item, \fBACE_Time_Value\fR * timeout = 0)\fC [virtual]\fR
.PP
Retrieve the first  without removing it. Note that <timeout> uses <{absolute}> time rather than <{relative}> time. If the <timeout> elapses without receiving a message -1 is returned and <errno> is set to <EWOULDBLOCK>. If the queue is deactivated -1 is returned and <errno> is set to <ESHUTDOWN>. Otherwise, returns -1 on failure, else the number of items still on the queue. 
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
.SS template<classACE_MESSAGE_TYPE, ACE_SYNCH_DECL> \fBACE_Message_Queue\fR< ACE_SYNCH_USE > ACE_Message_Queue_Ex<ACE_MESSAGE_TYPE, >::queue_\fC [private]\fR
.PP
Implement this via an .
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.