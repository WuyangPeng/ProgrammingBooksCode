.TH ACE_SOCK_Dgram_Mcast 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_SOCK_Dgram_Mcast \- Defines the member functions for the \fBACE\fR socket wrapper for UDP/IP multicast. 
.SH SYNOPSIS
.br
.PP
\fC#include <SOCK_Dgram_Mcast.h>\fR
.PP
Inherits \fBACE_SOCK_Dgram\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_SOCK_Dgram_Mcast\fR (void)"
.br
.ti -1c
.RI "\fB~ACE_SOCK_Dgram_Mcast\fR (void)"
.br
.RI "\fIDefault dtor.\fR"
.ti -1c
.RI "int \fBsubscribe\fR (const \fBACE_INET_Addr\fR &mcast_addr, int reuse_addr = 1, const \fBACE_TCHAR\fR *net_if = 0, int protocol_family = PF_INET, int protocol = 0)"
.br
.ti -1c
.RI "int \fBunsubscribe\fR (const \fBACE_INET_Addr\fR &mcast_addr, const \fBACE_TCHAR\fR *net_if = 0, int protocol_family = PF_INET, int protocol = 0)"
.br
.ti -1c
.RI "int \fBunsubscribe\fR (void)"
.br
.RI "\fIUnsubscribe from a multicast group. Returns -1 if the call fails.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBsend\fR (const void *buf, size_t n, int flags = 0) const"
.br
.RI "\fISend <n> bytes in <buf>.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBsend\fR (const \fBiovec\fR iov[], size_t n, int flags = 0) const"
.br
.RI "\fISend <n> <iovecs>.\fR"
.ti -1c
.RI "int \fBset_option\fR (int option, char optval)"
.br
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Protected Methods

.in +1c
.ti -1c
.RI "int \fBmake_multicast_address\fR (const \fBACE_INET_Addr\fR &mcast_addr, const \fBACE_TCHAR\fR *net_if = ACE_LIB_TEXT ("le0"))"
.br
.RI "\fIInitialize the <multicast_address_> IP address.\fR"
.ti -1c
.RI "int \fBmake_multicast_address_i\fR (const \fBACE_INET_Addr\fR &mcast_addr, \fBip_mreq\fR& multicast_address, const \fBACE_TCHAR\fR *net_if = ACE_LIB_TEXT ("le0"))"
.br
.RI "\fIInitialize a multicast address. This method factors out common code called by <make_multicast_address> and <subscribe>.\fR"
.in -1c
.SS Protected Attributes

.in +1c
.ti -1c
.RI "\fBACE_INET_Addr\fR \fBmcast_addr_\fR"
.br
.RI "\fIA copy of the address that we use to <send> multicasts.\fR"
.ti -1c
.RI "\fBip_mreq\fR \fBmcast_request_if_\fR"
.br
.RI "\fIIP address of the interface upon which we're receiving multicasts.\fR"
.in -1c
.SS Private Methods

.in +1c
.ti -1c
.RI "int \fBopen\fR (const \fBACE_Addr\fR &mcast_addr, int protocol_family = PF_INET, int protocol = 0, int reuse_addr = 0)"
.br
.RI "\fINot publically visible.\fR"
.ti -1c
.RI "int \fBopen\fR (const \fBACE_Addr\fR &mcast_addr, const \fBACE_QoS_Params\fR &qos_params, int protocol_family = PF_INET, int protocol = 0, \fBACE_Protocol_Info\fR *protocolinfo = 0, \fBACE_SOCK_GROUP\fR g = 0, u_long flags = 0, int reuse_addr = 0)"
.br
.RI "\fINot publically visible.\fR"
.ti -1c
.RI "int \fBsubscribe_ifs\fR (const \fBACE_INET_Addr\fR &mcast_addr, const \fBACE_TCHAR\fR *net_if, int protocol_family, int protocol, int reuse_addr)"
.br
.RI "\fISubscribe to the multicast interface using BSD-style semantics (no QoS).\fR"
.ti -1c
.RI "int \fBunsubscribe_ifs\fR (const \fBACE_INET_Addr\fR &mcast_addr, const \fBACE_TCHAR\fR *net_if = 0, int protocol_family = PF_INET, int protocol = 0)"
.br
.RI "\fIUnsubscribe to multicast interfaces subscribed to previously by <subscribe_ifs>.\fR"
.ti -1c
.RI "\fBssize_t\fR \fBsend\fR (const void *buf, size_t n, const \fBACE_Addr\fR &addr, int flags = 0) const"
.br
.RI "\fISend an <n> byte <buf> to the datagram socket (uses <sendto(3)>).\fR"
.ti -1c
.RI "\fBssize_t\fR \fBsend\fR (const \fBiovec\fR iov[], size_t n, const \fBACE_Addr\fR &addr, int flags = 0) const"
.br
.RI "\fISend an <\fBiovec\fR> of size <n> to the datagram socket (uses <sendmsg(3)>).\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 
Defines the member functions for the \fBACE\fR socket wrapper for UDP/IP multicast.
.PP
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS ACE_SOCK_Dgram_Mcast::ACE_SOCK_Dgram_Mcast (void)
.PP
Note that there is no public <open> method. Therefore, this class cannot be used unless you <subscribe> to a multicast group. If you just want to send (and not listen) to a multicast group, use  or  instead. 
.SS ACE_SOCK_Dgram_Mcast::~ACE_SOCK_Dgram_Mcast (void)
.PP
Default dtor.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS void ACE_SOCK_Dgram_Mcast::dump (void) const
.PP
Dump the state of an object.
.PP
Reimplemented from \fBACE_SOCK_Dgram\fR.
.SS int ACE_SOCK_Dgram_Mcast::make_multicast_address (const \fBACE_INET_Addr\fR & mcast_addr, const \fBACE_TCHAR\fR * net_if = ACE_LIB_TEXT ("le0"))\fC [protected]\fR
.PP
Initialize the <multicast_address_> IP address.
.PP
.SS int ACE_SOCK_Dgram_Mcast::make_multicast_address_i (const \fBACE_INET_Addr\fR & mcast_addr, \fBip_mreq\fR & multicast_address, const \fBACE_TCHAR\fR * net_if = ACE_LIB_TEXT ("le0"))\fC [protected]\fR
.PP
Initialize a multicast address. This method factors out common code called by <make_multicast_address> and <subscribe>.
.PP
.SS int ACE_SOCK_Dgram_Mcast::open (const \fBACE_Addr\fR & mcast_addr, const \fBACE_QoS_Params\fR & qos_params, int protocol_family = PF_INET, int protocol = 0, \fBACE_Protocol_Info\fR * protocolinfo = 0, \fBACE_SOCK_GROUP\fR g = 0, u_long flags = 0, int reuse_addr = 0)\fC [private]\fR
.PP
Not publically visible.
.PP
.SS int ACE_SOCK_Dgram_Mcast::open (const \fBACE_Addr\fR & mcast_addr, int protocol_family = PF_INET, int protocol = 0, int reuse_addr = 0)\fC [private]\fR
.PP
Not publically visible.
.PP
Reimplemented from \fBACE_SOCK_Dgram\fR.
.SS \fBssize_t\fR ACE_SOCK_Dgram_Mcast::send (const \fBiovec\fR iov[], size_t n, const \fBACE_Addr\fR & addr, int flags = 0) const\fC [private]\fR
.PP
Send an <\fBiovec\fR> of size <n> to the datagram socket (uses <sendmsg(3)>).
.PP
Reimplemented from \fBACE_SOCK_Dgram\fR.
.SS \fBssize_t\fR ACE_SOCK_Dgram_Mcast::send (const void * buf, size_t n, const \fBACE_Addr\fR & addr, int flags = 0) const\fC [private]\fR
.PP
Send an <n> byte <buf> to the datagram socket (uses <sendto(3)>).
.PP
Reimplemented from \fBACE_SOCK_Dgram\fR.
.SS \fBssize_t\fR ACE_SOCK_Dgram_Mcast::send (const \fBiovec\fR iov[], size_t n, int flags = 0) const
.PP
Send <n> <iovecs>.
.PP
.SS \fBssize_t\fR ACE_SOCK_Dgram_Mcast::send (const void * buf, size_t n, int flags = 0) const
.PP
Send <n> bytes in <buf>.
.PP
.SS int ACE_SOCK_Dgram_Mcast::set_option (int option, char optval)
.PP
Set an ip option that takes a char as input, such as <IP_MULTICAST_LOOP> or <IP_MULTICAST_TTL>. This is just a more concise nice interface to a subset of possible  calls. Returns 0 on success, -1 on failure. 
.SS int ACE_SOCK_Dgram_Mcast::subscribe (const \fBACE_INET_Addr\fR & mcast_addr, int reuse_addr = 1, const \fBACE_TCHAR\fR * net_if = 0, int protocol_family = PF_INET, int protocol = 0)
.PP
This is a BSD-style method (i.e., no QoS) for joining a multicast group. The network interface device driver is instructed to accept datagrams with <mcast_addr> multicast addresses. If the socket has already been opened, <subscribe> closes the socket and opens a new socket bound to the <mcast_addr>.
.PP
The <net_if> interface is hardware specific, e.g., use "netstat -i" to find whether your interface is, such as "le0" or something else. If net_if == 0, <subscribe> uses the default mcast interface. Returns: -1 if the call fails.
.PP
Note that some platforms, such as pSoS, support only number, not names, for network interfaces. For these platforms, just give these numbers in alphanumeric form and <subscribe> will convert them into numbers via . 
.SS int ACE_SOCK_Dgram_Mcast::subscribe_ifs (const \fBACE_INET_Addr\fR & mcast_addr, const \fBACE_TCHAR\fR * net_if, int protocol_family, int protocol, int reuse_addr)\fC [private]\fR
.PP
Subscribe to the multicast interface using BSD-style semantics (no QoS).
.PP
.SS int ACE_SOCK_Dgram_Mcast::unsubscribe (void)
.PP
Unsubscribe from a multicast group. Returns -1 if the call fails.
.PP
.SS int ACE_SOCK_Dgram_Mcast::unsubscribe (const \fBACE_INET_Addr\fR & mcast_addr, const \fBACE_TCHAR\fR * net_if = 0, int protocol_family = PF_INET, int protocol = 0)
.PP
Leave a multicast group identified by <mcast_addr>. The <net_if> interface is hardware specific. Use something like "netstat -i" to find whether your interface is, such as "le0" or something else. If <net_if> == 0, <subscribe> uses the default mcast interface. Returns: -1 if the call fails.
.PP
Note that some platforms, such as pSoS, support only number, not names, for network interfaces. For these platforms, just give these numbers in alphanumeric form and <subscribe> will convert them into numbers via . 
.SS int ACE_SOCK_Dgram_Mcast::unsubscribe_ifs (const \fBACE_INET_Addr\fR & mcast_addr, const \fBACE_TCHAR\fR * net_if = 0, int protocol_family = PF_INET, int protocol = 0)\fC [private]\fR
.PP
Unsubscribe to multicast interfaces subscribed to previously by <subscribe_ifs>.
.PP
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS ACE_SOCK_Dgram_Mcast::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
Reimplemented from \fBACE_SOCK_Dgram\fR.
.SS \fBACE_INET_Addr\fR ACE_SOCK_Dgram_Mcast::mcast_addr_\fC [protected]\fR
.PP
A copy of the address that we use to <send> multicasts.
.PP
.SS \fBip_mreq\fR ACE_SOCK_Dgram_Mcast::mcast_request_if_\fC [protected]\fR
.PP
IP address of the interface upon which we're receiving multicasts.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.