.TH ACE_Bounded_Set 3 "5 Oct 2001" "ACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ACE_Bounded_Set \- Implement a simple unordered set of <T> with maximum set at creation time. 
.SH SYNOPSIS
.br
.PP
\fC#include <Containers_T.h>\fR
.PP
.SS Public Types

.in +1c
.ti -1c
.RI "typedef \fBACE_Bounded_Set_Iterator\fR<T> \fBITERATOR\fR"
.br
.ti -1c
.RI "enum { \fBDEFAULT_SIZE\fR = 10 }"
.br
.in -1c
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBACE_Bounded_Set\fR (void)"
.br
.RI "\fIConstructor.\fR"
.ti -1c
.RI "\fBACE_Bounded_Set\fR (size_t size)"
.br
.RI "\fIConstructor.\fR"
.ti -1c
.RI "\fBACE_Bounded_Set\fR (const ACE_Bounded_Set<T> &)"
.br
.RI "\fICopy constructor.\fR"
.ti -1c
.RI "void \fBoperator=\fR (const ACE_Bounded_Set<T> &)"
.br
.RI "\fIAssignment operator.\fR"
.ti -1c
.RI "\fB~ACE_Bounded_Set\fR (void)"
.br
.RI "\fIDestructor.\fR"
.ti -1c
.RI "int \fBis_empty\fR (void) const"
.br
.RI "\fIReturns 1 if the container is empty, otherwise returns 0.\fR"
.ti -1c
.RI "int \fBis_full\fR (void) const"
.br
.RI "\fIReturns 1 if the container is full, otherwise returns 0.\fR"
.ti -1c
.RI "int \fBinsert\fR (const T &new_item)"
.br
.ti -1c
.RI "int \fBremove\fR (const T &item)"
.br
.ti -1c
.RI "int \fBfind\fR (const T &item) const"
.br
.RI "\fIFinds if <item> occurs in the set. Returns 0 if finds, else -1.\fR"
.ti -1c
.RI "size_t \fBsize\fR (void) const"
.br
.RI "\fISize of the set.\fR"
.ti -1c
.RI "void \fBdump\fR (void) const"
.br
.RI "\fIDump the state of an object.\fR"
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "\fBACE_ALLOC_HOOK_DECLARE\fR"
.br
.RI "\fIDeclare the dynamic allocation hooks.\fR"
.in -1c
.SS Private Attributes

.in +1c
.ti -1c
.RI "\fBSearch_Structure\fR* \fBsearch_structure_\fR"
.br
.RI "\fIHolds the contents of the set.\fR"
.ti -1c
.RI "size_t \fBcur_size_\fR"
.br
.RI "\fICurrent size of the set.\fR"
.ti -1c
.RI "size_t \fBmax_size_\fR"
.br
.RI "\fIMaximum size of the set.\fR"
.in -1c
.SS Friends

.in +1c
.ti -1c
.RI "class \fBACE_Bounded_Set_Iterator< T >\fR"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 

.SS template<class T>  template class ACE_Bounded_Set
Implement a simple unordered set of <T> with maximum set at creation time.
.PP
.PP
 This implementation of an unordered set uses a Bounded array. This implementation does not allow duplicates... 
.PP
.SH MEMBER TYPEDEF DOCUMENTATION
.PP 
.SS template<classT> typedef \fBACE_Bounded_Set_Iterator\fR<T> ACE_Bounded_Set<T>::ITERATOR
.PP
.SH MEMBER ENUMERATION DOCUMENTATION
.PP 
.SS template<classT> anonymous enum
.PP
\fBEnumeration values:\fR
.in +1c
.TP
\fB\fIDEFAULT_SIZE\fR \fR
.SH CONSTRUCTOR & DESTRUCTOR DOCUMENTATION
.PP 
.SS template<classT> ACE_Bounded_Set<T>::ACE_Bounded_Set<T> (void)
.PP
Constructor.
.PP
.SS template<classT> ACE_Bounded_Set<T>::ACE_Bounded_Set<T> (size_t size)
.PP
Constructor.
.PP
.SS template<classT> ACE_Bounded_Set<T>::ACE_Bounded_Set<T> (const ACE_Bounded_Set< T >&)
.PP
Copy constructor.
.PP
.SS template<classT> ACE_Bounded_Set<T>::~ACE_Bounded_Set<T> (void)
.PP
Destructor.
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS template<classT> void ACE_Bounded_Set<T>::dump (void) const
.PP
Dump the state of an object.
.PP
.SS template<classT> int ACE_Bounded_Set<T>::find (const T & item) const
.PP
Finds if <item> occurs in the set. Returns 0 if finds, else -1.
.PP
.SS template<classT> int ACE_Bounded_Set<T>::insert (const T & new_item)
.PP
Insert <new_item> into the set (doesn't allow duplicates). Returns -1 if failures occur, 1 if item is already present, else 0. 
.SS template<classT> int ACE_Bounded_Set<T>::is_empty (void) const
.PP
Returns 1 if the container is empty, otherwise returns 0.
.PP
.SS template<classT> int ACE_Bounded_Set<T>::is_full (void) const
.PP
Returns 1 if the container is full, otherwise returns 0.
.PP
.SS template<classT> void ACE_Bounded_Set<T>::operator= (const ACE_Bounded_Set< T >&)
.PP
Assignment operator.
.PP
.SS template<classT> int ACE_Bounded_Set<T>::remove (const T & item)
.PP
Remove first occurrence of <item> from the set. Returns 0 if it removes the item, -1 if it can't find the item, and -1 if a failure occurs. 
.SS template<classT> size_t ACE_Bounded_Set<T>::size (void) const
.PP
Size of the set.
.PP
.SH FRIENDS AND RELATED FUNCTION DOCUMENTATION
.PP 
.SS template<classT> class \fBACE_Bounded_Set_Iterator\fR\fC [friend]\fR
.PP
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS template<classT> ACE_Bounded_Set<T>::ACE_ALLOC_HOOK_DECLARE
.PP
Declare the dynamic allocation hooks.
.PP
.SS template<classT> size_t ACE_Bounded_Set<T>::cur_size_\fC [private]\fR
.PP
Current size of the set.
.PP
.SS template<classT> size_t ACE_Bounded_Set<T>::max_size_\fC [private]\fR
.PP
Maximum size of the set.
.PP
.SS template<classT> \fBSearch_Structure\fR * ACE_Bounded_Set<T>::search_structure_\fC [private]\fR
.PP
Holds the contents of the set.
.PP


.SH AUTHOR
.PP 
Generated automatically by Doxygen for ACE from the source code.