<html>

<head>
<meta http-equiv="Content-Language" content="zh-cn">
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta name="GENERATOR" content="Microsoft FrontPage 12.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>第22章 薪水支付案例研究（第2部分）</title>
<link rel="stylesheet" type="text/css" href="../../../news.css">
<meta name="Microsoft Theme" content="nature 011">
<style type="text/css">
.style1 {
	font-family: FZKai-Z03;
	font-weight: bold;
}
.style6 {
	font-family: FZKai-Z03;
	font-weight: bold;
	color: #0000FF;
}
.style7 {
	font-size: large;
}
.style8 {
	font-family: FZKai-Z03;
	font-weight: bold;
	color: #0000FF;
	font-size: large;
}
.style10 {
	font-family: FZKai-Z03;
	text-align: center;
	font-size: medium;
}
.style12 {
	font-family: FZKai-Z03;
	text-indent: 0;
	text-align: center;
	margin-left: 12px;
	margin-right: 12px;
}
.style13 {
	text-align: center;
}
.style11 {
	font-family: FZKai-Z03;
	text-indent: 32px;
	text-align: left;
	margin-left: 12px;
	margin-right: 12px;
}
</style>
</head>

<body background="../../../nabkgnd.jpg" bgcolor="#FFFFFF" text="#000000" link="#993333" vlink="#333399" alink="#006633">

<div class="style13">

<p align="center" class="style1"><font size="7" color="#0000FF">敏捷软件开发：原则、模式与实践</font></p>
<p align="center" class="style8">Agile 
Software Development</p>
<p align="center" class="style6">&nbsp;<span class="style7">Principles, Patterns, and 
Practices</span></p>
<p align="center" class="style6">
<img src="../../../anabull1.gif" border="0" width="15" height="15"><span class="style10"><strong>第22章 
薪水支付案例研究（第2部分）</strong></span><img src="../../../anabull1.gif" border="0" width="15" height="15"></p>

<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.1 包结构和表示法 </strong></p>
<p class="style11">
当一个包位于包依赖关系层次结构更高层次时，它的发布率一定会增加。幸运地是，这是不正确的，并且面向对象设计的主要目标之一就是要避免这种症状。</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10">&nbsp;</p>
<p class="style12">
<strong>22.2 应用公共封闭原则（CCP） </strong></p>
<p class="style11">
大部分的可执行代码都在那些具有很少依赖者或者没有依赖者的包中。因为几乎没有包依赖于它们，所以称它们为不承担责任的。这些包的代码是非常灵活的；对它们的更改对项目中大部分其他的包不会造成影响。</p>
<p class="style11">
系统中最具通用性的包所包含的可执行代码的数量是最少的。这些包被很多包所依赖，却不依赖于任何其他的包。因为有很多包依赖于它们，所以称它们为承担责任的，并且因为它们不依赖于任何其他包，所以也称它们为无依赖性的。</p>
<p class="style11">
承担责任的代码的数量是非常少的。此外，这些少量的承担责任的代码同样也是无依赖性的，这意味着任何其他的模块都不会引起它的变化。在这个倒置的结构中，底部是高度无依赖性和承担责任的包含通用部分的包，顶部是高度有依赖性和不承担责任的包含细节的包，这种结构是面向对象设计的标志。&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.3 应用重用发布等价原则（REP） </strong></p>
<p class="style11">
很少会出现只重用包中单一类的情况。一个包中的类应该是内聚的。这意味着它们之间互相依赖，很难轻易、合理地把它们分开。</p>
<p class="style11">
我们在试图把类分组成包时，就有了另外一个可以使用的内聚标准：一个包中的类不仅要一同封闭，它们也应该一同重用。</p>
<p class="style11">
从简单的包开始在必要时再去增加包结构是最好的做法。在必要时，总是可以把包结构变得更精细。&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.4 耦合和封装 </strong></p>
<p class="style11">
如果一个包中的类被另一个包使用，那么该类必须要被引出。</p>
<p class="style11">
缺省情况下类都是被引出的，但是我们可以对包进行修饰以指示其中某些类是不应该被引出的。&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.5 度量 </strong></p>
<p class="style11">
无法控制的东西就无法管理，无法测量的东西就无法控制。要想成为高效的软件工程师或者软件管理者，必须要能够控制软件开发的实践。如果没有测量它，无论如何都无法控制它。&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.5.1 关系内聚性（H） </strong></p>
<p class="style11">
可以用包中每个类平均的内部关系数目作为包内聚性的一种表示方式。</p>
<p class="style11">
H&nbsp; = (R + 1) / N&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.5.2 输入耦合度（Cu） </strong></p>
<p class="style11">
一个包的输入耦合度可以用对该包的类有依赖的其他包中类的数目来表示。这些依赖关系是类关系，例如：继承和关联。&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.5.3 输出耦合度（Ce） </strong></p>
<p class="style11">
一个包的输出耦合度可以用被该包的类所依赖的其他包中类的数目来表示。像上面一样，这些依赖关系也是类关系。&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.5.4 抽象性或者通用性（A） </strong></p>
<p class="style11">
一个包的抽象性或者通用性可以用该包中抽象类的数目和该包中类的总数的比值来表示。该度量的取值范围是0到1。&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.5.5 不稳定性（I） </strong></p>
<p class="style11">
一个包的不稳定性可用输出耦合度和总耦合度的比值来表示。该度量的取值范围也是从0到1。&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.5.6 到主序列的距离（D） </strong></p>
<p class="style11">
理想的主序列是由A + I = 1所表示的线。D的计算公式可以计算任何特定的包到主序列的距离。它的范围是从0~0.7，越接近0越好。&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.5.7 到主序列的规范化距离（D'） </strong></p>
<p class="style11">
该度量把度量D的取值范围规范化为[0,1]。这样计算和解释起来也许会方便一些。值0表示包和主序列是重合的，值1表示包到主序列的距离最大。&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.6 度量薪水支付应用程序</strong>&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.7 对象工厂 </strong></p>
<p class="style11">
使用FACTORY模式可以显著地缓和这个问题。每个包都提供一个对象工厂，该工厂负责创建该包中所有的公有对象。&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.7.1 TransactionImplementation包的对象工厂</strong>&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.7.2 初始化对象工厂 </strong></p>
<p class="style11">
为了使用对象工厂去创建对象，抽象对象工厂的静态成员必须要被初始化为指向适当的具体对象工厂。这项工作必须要在任何使用者试图去使用对象工厂前完成。&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.7.3 重新思考内聚的边界 </strong></p>
<p class="style11">
基于操作的划分要比基于功能的划分重要。&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.8 最终的包结构</strong>&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p class="style12">
<strong>22.9 结论 </strong></p>
<p class="style11">
是否需要对包结构进行管理，取决于程序的规模以及开发团队的规模。即使小的团队，也需要对源代码进行划分，以便于开发人员间可以互不干扰。如果没有某种形式的划分结构，大程序就会变成晦涩难懂的源文件堆积。&nbsp;</p>
<p align="center"><img border="0" src="../../../anarule.gif" width="600" height="10"></p>
<p align="center"><b><font size="6" face="隶书"><img border="0" src="../../../anabull1.gif" width="15" height="15"></font></b><font color="#800080" face="华文彩云" size="5"><b><a href="第Ⅳ部分.htm"><font color="#ff00ff">返回</font></a></b></font><b><font size="6" face="隶书"><img border="0" src="../../../anabull1.gif" width="15" height="15"></font></b></p>

</div>

</body>

</html>
