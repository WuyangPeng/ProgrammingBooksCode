#include "Toolbox.h"#include "AICommon.h"		TWindow							tbWindow;	ai_World						MainWorld;	ai_Entity						entityList[kMaxEntities];		TBitmap							terrainBMP;	TBitmap							objectsBMP;	TBitmap							objectsMaskBMP;	TBitmap							offscreenBMP;	TRect								unitRect;	TRect								humanRect;	TRect								trollRect;	TRect								treeRect;	TRect								terrainRect[kMaxTiles];	TRect								screenRect;	TRect								destRect[kMaxRows][kMaxCols];	TBoolean						terrainBackup[kMaxRows][kMaxCols];	TBoolean	terrain[kMaxRows][kMaxCols]={		1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1	};// ----------------------------------------------------------------- //ai_Entity::ai_Entity()// ----------------------------------------------------------------- //{	int					i;		for (i=0;i<kMaxEntities;i++)		{			entityList[i].row=-1;			entityList[i].col=-1;			entityList[i].type=-1;			entityList[i].state=-1;			entityList[i].startRow=-1;			entityList[i].startCol=-1;			entityList[i].endRow=-1;			entityList[i].endCol=-1;			entityList[i].target=-1;			entityList[i].timeToMove=0;		}	entityList[0].New(kHuman,kPlayer,3,10,0,0);	entityList[1].New(kTroll,kPatrolling,12,10,18,8);		for (i=2;i<kMaxEntities;i++)		entityList[i].New(kTree,kStatic,tb_Rnd(0,kMaxRows-1),tb_Rnd(0,kMaxCols-1),0,0);		}// ----------------------------------------------------------------- //ai_Entity::~ai_Entity()// ----------------------------------------------------------------- //{}// ----------------------------------------------------------------- //void ai_Entity::ResetPatrol(void)// ----------------------------------------------------------------- //{		int			i;		state=kPatrolling;	startRow=2;	startCol=2;	endRow=18;	endCol=8;	row=startRow;	col=startCol;	pathPtr=0;	for (i=0;i<kMaxPathLength;i++)		{			pathRow[i]=-1;			pathCol[i]=-1;		}	pathRowTarget=-1;	pathColTarget=-1;}// ----------------------------------------------------------------- //void ai_Entity::StartChase(void)// ----------------------------------------------------------------- //{	int								i;		for (i=0;i<kMaxEntities;i++)		if (entityList[i].state==kPlayer)			{				state=kChasing;				target=i;			}				pathPtr=0;	for (i=0;i<kMaxPathLength;i++)		{			pathRow[i]=-1;			pathCol[i]=-1;		}	pathRowTarget=-1;	pathColTarget=-1;}// ----------------------------------------------------------------- //int ai_Entity::DistanceFrom(int t)// ----------------------------------------------------------------- //{	return (sqrt(((row-entityList[t].row) * (row-entityList[t].row)) + ((col-entityList[t].col) * (col-entityList[t].col))));	}// ----------------------------------------------------------------- //void ai_Entity::New(int theType, int theState, int theStartRow, int theStartCol, int theEndRow, int theEndCol)// ----------------------------------------------------------------- //{	int							i;		type=theType;	row=theStartRow;	col=theStartCol;	state=theState;	startRow=theStartRow;	startCol=theStartCol;	endRow=theEndRow;	endCol=theEndCol;	pathPtr=0;	for (i=0;i<kMaxPathLength;i++)		{			pathRow[i]=-1;			pathCol[i]=-1;		}	pathRowTarget=-1;	pathColTarget=-1;	if (state==kChasing)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				target=i;}// ----------------------------------------------------------------- //void ai_Entity::nextStepToTarget(int *nextRow, int *nextCol)// ----------------------------------------------------------------- //{	int	Ax=row;	int	Ay=col;	int	Bx=endRow;	int By=endCol;	int	step = 0;	int dX = abs(Bx-Ax);	int dY = abs(By-Ay);	int	Sx = Ax;	int	Sy = Ay;	int Xincr, Yincr;		if ((Ax==Bx) && (Ay==By))		{ 			*nextRow=Ax; 			*nextCol=Ay;			return;		}			if (Ax > Bx) { Xincr=-1; } else { Xincr=1; }	if (Ay > By) { Yincr=-1; } else { Yincr=1; }	if (dX >= dY)	{           		int dPr 	= dY<<1;		int dPru 	= dPr - (dX<<1);		int P 		= dPr - dX;		for (; dX>=0; dX--)		{     	if (step==1)     		{     			*nextRow=Ax;     			*nextCol=Ay;     			return;     		}      step++;			if (P > 0)			{ 				Ax+=Xincr;				Ay+=Yincr;				P+=dPru;			}			else			{				Ax+=Xincr;				P+=dPr;			}		}			}	else	{		int dPr 	= dX<<1;		int dPru 	= dPr - (dY<<1);		int P 		= dPr - dY;		for (; dY>=0; dY--)		{     	if (step==1)     		{     			*nextRow=Ax;     			*nextCol=Ay;     			return;     		}      step++;			if (P > 0)			{ 				Ax+=Xincr;				Ay+=Yincr;				P+=dPru;			}			else			{				Ay+=Yincr;				P+=dPr;			}		}			}			}// ----------------------------------------------------------------- //void ai_Entity::FollowPath(void)// ----------------------------------------------------------------- //{	int			i;	int			nextStep=-1;		for (i=0;i<(kMaxPathLength-1);i++)		if ((pathRow[i]==row) && (pathCol[i]==col))			{				nextStep=i+1;				break;			}	if (nextStep>0)		if ((pathRow[nextStep]>=0) && (pathCol[nextStep]>=0))			{				row=pathRow[nextStep];				col=pathCol[nextStep];			}			}// ----------------------------------------------------------------- //void ai_Entity::BuildPathToTarget(void)// ----------------------------------------------------------------- //	{	int nextCol=col;	int	nextRow=row;	int deltaRow=endRow-row;	int deltaCol=endCol-col;	int stepCol; 	int stepRow;	int currentStep;	int fraction;	for (currentStep=0;currentStep<kMaxPathLength;currentStep++)		{			pathRow[currentStep]=-1;			pathCol[currentStep]=-1;		}	currentStep=0;	pathRowTarget=endRow;	pathColTarget=endCol;  if (deltaRow < 0) stepRow=-1; else stepRow=1;  if (deltaCol < 0) stepCol=-1;	else stepCol=1;  deltaRow=abs(deltaRow*2);  deltaCol=abs(deltaCol*2);	pathRow[currentStep]=nextRow;	pathCol[currentStep]=nextCol;	currentStep++;	if (currentStep>=kMaxPathLength)		return;			if (deltaCol > deltaRow) 		{			fraction = deltaRow * 2 - deltaCol;			while (nextCol != endCol) 				{					if (fraction >= 0) 						{							nextRow += stepRow;							fraction = fraction - deltaCol;						}					nextCol = nextCol + stepCol;					fraction = fraction + deltaRow;					pathRow[currentStep]=nextRow;					pathCol[currentStep]=nextCol;					currentStep++;					if (currentStep>=kMaxPathLength)						return;			}	  } 	 else 	 {		fraction = deltaCol * 2 - deltaRow;		while (nextRow != endRow) 			{				if (fraction >= 0) 					{						nextCol = nextCol + stepCol;						fraction = fraction - deltaRow;					}				nextRow = nextRow + stepRow;				fraction = fraction + deltaCol;				pathRow[currentStep]=nextRow;				pathCol[currentStep]=nextCol;				currentStep++;				if (currentStep>=kMaxPathLength)					return;			}	  }	}     // ----------------------------------------------------------------- //void ai_Entity::ShowPath(void)// ----------------------------------------------------------------- //{	int	i;	for (i=0;i<kMaxPathLength;i++)		if ((pathRow[i]>=0) && (pathCol[i]>=0))      terrain[pathRow[i]][pathCol[i]]=kRed;	}// ----------------------------------------------------------------- //ai_World::ai_World()// ----------------------------------------------------------------- //{	TRect				r;	int					i;	int					j;		tb_InitializeToolbox();	showPath=false;		// offscreen buffer	tb_SetRect(&screenRect,0,0,720,480);	offscreenBMP=tb_CreateBitmap(&screenRect, -1, kScreenDepth);		// terrain graphics	terrainBMP=tb_CreateBitmap(&r, 128, kScreenDepth);	// terrain graphics	objectsBMP=tb_CreateBitmap(&r, 129, kScreenDepth);	objectsMaskBMP=tb_CreateBitmap(&r, 130, kScreenDepth);		tb_SetRect(&unitRect,1,1,49,63);	tb_SetRect(&humanRect,1,1,49,63);	tb_SetRect(&trollRect,50,1,98,63);	tb_SetRect(&treeRect,99,1,147,63);	tb_SetRect(&terrainRect[kGround],1,1,25,25);	tb_SetRect(&terrainRect[kWater],26,1,50,25);	tb_SetRect(&terrainRect[kBridge],51,1,75,25);	tb_SetRect(&terrainRect[kRed],76,1,100,25);	for (i=0;i<kMaxRows;i++)		for (j=0;j<kMaxCols;j++)			{				tb_SetRect(&destRect[i][j],(24*j),(24*i),(24*j)+25,(24*i)+25);				terrainBackup[i][j]=terrain[i][j];			}}// ----------------------------------------------------------------- //ai_World::~ai_World()// ----------------------------------------------------------------- //{}// ----------------------------------------------------------------- //void ai_World::UpdateWorld(void)// ----------------------------------------------------------------- //	{	int				i;	int				j;	int				newRow;	int				newCol;	int				tempRow;	int				tempCol;	int				showRowStart;	int				showColStart;	int				showRowEnd;	int				showColEnd;			for (i=0;i<kMaxRows;i++)		for (j=0;j<kMaxCols;j++)			terrain[i][j]=terrainBackup[i][j];	if (showPath) // show the paths		for (i=0;i<kMaxEntities;i++)			if ((entityList[i].state==kPatrolling)	|| (entityList[i].state==kPatrollingChasing) || (entityList[i].state==kChasing)) // only show paths for patrolling and chasing				{					if ((entityList[i].state==kPatrolling)	|| (entityList[i].state==kPatrollingChasing))// entity is patrolling						{							showRowStart=entityList[i].startRow;							showColStart=entityList[i].startCol;							showRowEnd=entityList[i].endRow;							showColEnd=entityList[i].endCol;						}					if (entityList[i].state==kChasing)	// entity is chasing						{							showRowStart=entityList[i].row;							showColStart=entityList[i].col;							showRowEnd=entityList[entityList[i].target].row;							showColEnd=entityList[entityList[i].target].col;						}					for (i=0;i<kMaxEntities;i++)						entityList[i].ShowPath();				}	// move entities	for (i=0;i<kMaxEntities;i++)		{					if (entityList[i].state==kPatrollingChasing)// entity is patrolling/chasing				for (j=0;j<kMaxEntities;j++)					if (entityList[j].state==kPlayer)						if (entityList[i].DistanceFrom(j)<=kChaseDistance)							entityList[i].StartChase();			if ((entityList[i].state==kPatrolling)	|| (entityList[i].state==kPatrollingChasing))// entity is patrolling				if (TickCount()>entityList[i].timeToMove)					{							entityList[i].timeToMove=TickCount()+kEntitySpeed;						entityList[i].nextStepToTarget(&newRow,&newCol);						entityList[i].row=newRow;						entityList[i].col=newCol;						if ((entityList[i].endRow==newRow) && (entityList[i].endCol==newCol)) // reached destination							{								tempRow = entityList[i].endRow;								tempCol = entityList[i].endCol;																entityList[i].endRow=entityList[i].startRow;								entityList[i].endCol=entityList[i].startCol;															entityList[i].startRow=tempRow;								entityList[i].startCol=tempCol;							}					}					if (entityList[i].state==kChasing)	// entity is chasing				if (TickCount()>entityList[i].timeToMove)					{							entityList[i].timeToMove=TickCount()+kEntitySpeed;												entityList[i].endRow=entityList[entityList[i].target].row;						entityList[i].endCol=entityList[entityList[i].target].col;											if (!((entityList[i].pathRowTarget==entityList[entityList[i].target].row) && (entityList[i].pathColTarget==entityList[entityList[i].target].col)))							entityList[i].BuildPathToTarget();						entityList[i].FollowPath();											}		}	Redraw();	}// ----------------------------------------------------------------- //void ai_World::KeyDown(int key)// ----------------------------------------------------------------- //	{	int							i;		if (key==kUpKey)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				if (TickCount()>entityList[i].timeToMove)					if (entityList[i].row>0)						{							entityList[i].row--;							entityList[i].timeToMove=TickCount()+kPlayerSpeed;						}							if (key==kDownKey)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				if (entityList[i].row<(kMaxRows-1))					if (TickCount()>entityList[i].timeToMove)						{							entityList[i].row++;							entityList[i].timeToMove=TickCount()+kPlayerSpeed;						}	if (key==kLeftKey)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				if (entityList[i].col>0)					if (TickCount()>entityList[i].timeToMove)						{							entityList[i].col--;							entityList[i].timeToMove=TickCount()+kPlayerSpeed;						}	if (key==kRightKey)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				if (entityList[i].col<(kMaxCols-1))					if (TickCount()>entityList[i].timeToMove)						{							entityList[i].col++;							entityList[i].timeToMove=TickCount()+kPlayerSpeed;						}}// ----------------------------------------------------------------- //void ai_World::Redraw(void)// ----------------------------------------------------------------- //	{	int					i;	int					j;	TRect				objectDest;		// draw terrain	for (i=0;i<kMaxRows;i++)		for (j=0;j<kMaxCols;j++)			tb_CopyBitmap(terrainBMP,offscreenBMP,&terrainRect[terrain[i][j]],&destRect[i][j],false);	for (i=0;i<kMaxEntities;i++)		{					if (entityList[i].type==kHuman)	// draw human				{					objectDest=unitRect;					tb_OffsetRect(&objectDest,destRect[entityList[i].row][entityList[i].col].left-14,destRect[entityList[i].row][entityList[i].col].top-42);					tb_CopyMaskBitmap(objectsBMP,objectsMaskBMP,offscreenBMP,&humanRect,&humanRect,&objectDest);				}			if (entityList[i].type==kTroll)	// draw troll				{					objectDest=unitRect;					tb_OffsetRect(&objectDest,destRect[entityList[i].row][entityList[i].col].left-14,destRect[entityList[i].row][entityList[i].col].top-42);					tb_CopyMaskBitmap(objectsBMP,objectsMaskBMP,offscreenBMP,&trollRect,&trollRect,&objectDest);				}			if (entityList[i].type==kTree)	// draw troll				{					objectDest=unitRect;					tb_OffsetRect(&objectDest,destRect[entityList[i].row][entityList[i].col].left-14,destRect[entityList[i].row][entityList[i].col].top-42);					tb_CopyMaskBitmap(objectsBMP,objectsMaskBMP,offscreenBMP,&treeRect,&treeRect,&objectDest);				}						}		tb_CopyBitmap(offscreenBMP,tbWindow,&screenRect,&screenRect,false);}