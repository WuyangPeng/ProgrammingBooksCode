#include "Toolbox.h"#include "AICommon.h"		TWindow							tbWindow;	ai_World						MainWorld;	ai_Entity						entityList[kMaxEntities];		TBitmap							terrainBMP;	TBitmap							objectsBMP;	TBitmap							objectsMaskBMP;	TBitmap							offscreenBMP;	TRect								unitRect;	TRect								humanRect;	TRect								trollRect;	TRect								treeRect;	TRect								terrainRect[kMaxTiles];	TRect								screenRect;	TRect								destRect[kMaxRows][kMaxCols];	TBoolean						terrainBackup[kMaxRows][kMaxCols];	TBoolean	terrain[kMaxRows][kMaxCols]={		2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,		2,1,1,1,1,1,2,1,1,1,2,1,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1,1,1,2,		2,1,1,1,1,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,1,2,		2,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1,1,1,2,		2,2,2,1,2,2,2,1,1,1,2,1,1,1,2,2,2,1,2,2,2,2,2,1,2,2,1,1,1,2,		2,1,1,1,1,1,2,1,1,1,2,1,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1,1,1,2,		2,1,1,1,1,1,2,2,2,2,2,2,1,2,2,1,1,1,1,1,2,1,1,1,1,2,2,1,2,2,		2,1,1,1,1,1,2,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,1,2,		2,1,1,1,1,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,		2,2,2,1,2,2,2,1,1,1,2,1,1,1,1,1,1,1,1,1,2,1,1,1,1,2,1,1,1,2,		2,1,1,1,1,1,2,1,1,1,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1,2,1,1,1,2,		2,1,1,1,1,1,2,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,		2,1,1,1,1,1,1,1,1,1,2,2,1,2,2,1,1,1,1,1,2,1,1,1,1,2,1,1,1,2,		2,2,2,2,2,2,2,2,1,2,2,1,1,1,2,1,1,1,1,1,2,2,2,2,2,2,1,1,1,2,		2,1,1,1,2,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,1,2,		2,1,1,1,2,1,1,1,1,1,1,1,1,1,2,2,2,2,1,2,2,1,1,1,1,2,1,1,1,2,		2,1,1,1,1,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,		2,1,1,1,2,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1,1,1,2,		2,1,1,1,2,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1,1,1,2,		2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,	};// ----------------------------------------------------------------- //ai_Entity::ai_Entity()// ----------------------------------------------------------------- //{	int					i;	int					j;	int					r;	int					c;		for (i=0;i<kMaxEntities;i++)		{			entityList[i].row=-1;			entityList[i].col=-1;			entityList[i].type=-1;			entityList[i].state=-1;			entityList[i].startRow=-1;			entityList[i].startCol=-1;			entityList[i].endRow=-1;			entityList[i].endCol=-1;			entityList[i].target=-1;			entityList[i].timeToMove=0;			entityList[i].direction=4;		}	entityList[0].New(kHuman,kPlayer,2,10,0,0);	entityList[1].New(kTroll,kPatrolling,1,1,18,8);			}// ----------------------------------------------------------------- //ai_Entity::~ai_Entity()// ----------------------------------------------------------------- //{}// ----------------------------------------------------------------- //void ai_Entity::New(int theType, int theState, int theStartRow, int theStartCol, int theEndRow, int theEndCol)// ----------------------------------------------------------------- //{	int							i;		type=theType;	row=theStartRow;	col=theStartCol;	state=theState;	startRow=theStartRow;	startCol=theStartCol;	endRow=theEndRow;	endCol=theEndCol;	pathPtr=0;	for (i=0;i<kMaxPathLength;i++)		{			pathRow[i]=-1;			pathCol[i]=-1;		}	pathRowTarget=-1;	pathColTarget=-1;	for (i=0;i<kMaxTrailLength;i++)		{			trailRow[i]=-1;			trailCol[i]=-1;		}	if (state==kChasing)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				target=i;}// ----------------------------------------------------------------- //ai_World::ai_World()// ----------------------------------------------------------------- //{	TRect				r;	int					i;	int					j;		tb_InitializeToolbox();	showPath=false;		// offscreen buffer	tb_SetRect(&screenRect,0,0,720,480);	offscreenBMP=tb_CreateBitmap(&screenRect, -1, kScreenDepth);		// terrain graphics	terrainBMP=tb_CreateBitmap(&r, 128, kScreenDepth);	// terrain graphics	objectsBMP=tb_CreateBitmap(&r, 129, kScreenDepth);	objectsMaskBMP=tb_CreateBitmap(&r, 130, kScreenDepth);		tb_SetRect(&unitRect,1,1,49,63);	tb_SetRect(&humanRect,1,1,49,63);	tb_SetRect(&trollRect,50,1,98,63);	tb_SetRect(&treeRect,99,1,147,63);	for (i=kGround;i<=kCrump15;i++)		tb_SetRect(&terrainRect[i],1+(25*(i-1)),1,(25*(i-1))+25,25);	for (i=0;i<kMaxRows;i++)		for (j=0;j<kMaxCols;j++)			{				tb_SetRect(&destRect[i][j],(24*j),(24*i),(24*j)+25,(24*i)+25);				terrainBackup[i][j]=terrain[i][j];			}}// ----------------------------------------------------------------- //ai_World::~ai_World()// ----------------------------------------------------------------- //{}// ----------------------------------------------------------------- //void ai_World::SimpleShowPath(int Ax, int Ay, int Bx, int By, int *nextRow, int *nextCol)// ----------------------------------------------------------------- //{	if (Ax<Bx)		Ax++;	else if (Ax>Bx)		Ax--;	if (Ay<By)		Ay++;	else if (Ay>By)		Ay--;	*nextRow=Ax;	*nextCol=Ay;}// ----------------------------------------------------------------- //void ai_World::UpdateWorld(void)// ----------------------------------------------------------------- //	{	int				i;	int				j;	int				newRow;	int				newCol;	int				tempRow;	int				tempCol;	int				showRowStart;	int				showColStart;	int				showRowEnd;	int				showColEnd;	int				r;	int				c;	int				foundCrump;	int				terrainAnalysis[9];	int				maxTerrain=0;	int				maxIndex=0;	for (i=0;i<kMaxRows;i++)		for (j=0;j<kMaxCols;j++)			terrain[i][j]=terrainBackup[i][j];	// move entities	for (i=0;i<kMaxEntities;i++)		{			if ((entityList[i].state==kPatrolling))// entity is patrolling				if (TickCount()>entityList[i].timeToMove)					{							entityList[i].timeToMove=TickCount()+kEntitySpeed;						r=entityList[i].row;						c=entityList[i].col;						if (entityList[i].direction==4) // moving right							{								if (terrain[r-1][c]==1)									{										entityList[i].row--;										entityList[i].direction=2;									}								else if (terrain[r][c+1]==1)									{										entityList[i].col++;										entityList[i].direction=4;									}								else if (terrain[r+1][c]==1)									{										entityList[i].row++;										entityList[i].direction=6;									}								else if (terrain[r][c-1]==1)									{										entityList[i].col--;										entityList[i].direction=8;									}							}														else if (entityList[i].direction==6) // moving down							{								if (terrain[r][c+1]==1) // left									{										entityList[i].col++;										entityList[i].direction=4;									}								else if (terrain[r+1][c]==1) // straight									{										entityList[i].row++;										entityList[i].direction=6;									}								else if (terrain[r][c-1]==1) // right									{										entityList[i].col--;										entityList[i].direction=8;									}								else if (terrain[r-1][c]==1) // back									{										entityList[i].row--;										entityList[i].direction=2;									}							}						else if (entityList[i].direction==8) // moving left							{								if (terrain[r+1][c]==1) // left									{										entityList[i].row++;										entityList[i].direction=6;									}								else if (terrain[r][c-1]==1) // straight									{										entityList[i].col--;										entityList[i].direction=8;									}								else if (terrain[r-1][c]==1) // right									{										entityList[i].row--;										entityList[i].direction=2;									}								else if (terrain[r][c+1]==1) // back									{										entityList[i].col++;										entityList[i].direction=4;									}							}						else if (entityList[i].direction==2) // moving up							{								if (terrain[r][c-1]==1) // left									{										entityList[i].col--;										entityList[i].direction=8;									}								else if (terrain[r-1][c]==1) // straight									{										entityList[i].row--;										entityList[i].direction=2;									}								else if (terrain[r][c+1]==1) // right									{										entityList[i].col++;										entityList[i].direction=4;									}								else if (terrain[r+1][c]==1) // back									{										entityList[i].row++;										entityList[i].direction=6;									}							}						if (entityList[i].row<0)							entityList[i].row=0;						if (entityList[i].col<0)							entityList[i].col=0;						if (entityList[i].row>=kMaxRows)							entityList[i].row=kMaxRows-1;						if (entityList[i].col>=kMaxCols)							entityList[i].col=kMaxCols-1;					}		}	Redraw();	}// ----------------------------------------------------------------- //void ai_World::DropBreadCrump(void)// ----------------------------------------------------------------- //	{	int				i;		for (i=kMaxTrailLength-1;i>0;i--)		{			entityList[0].trailRow[i]=entityList[0].trailRow[i-1];			entityList[0].trailCol[i]=entityList[0].trailCol[i-1];		}	entityList[0].trailRow[0]=entityList[0].row;	entityList[0].trailCol[0]=entityList[0].col;			}// ----------------------------------------------------------------- //void ai_World::KeyDown(int key)// ----------------------------------------------------------------- //	{	int							i;		if (key==kUpKey)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				if (TickCount()>entityList[i].timeToMove)					if (entityList[i].row>0)						{							entityList[i].row--;							entityList[i].timeToMove=TickCount()+kPlayerSpeed;							DropBreadCrump();						}							if (key==kDownKey)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				if (entityList[i].row<(kMaxRows-1))					if (TickCount()>entityList[i].timeToMove)						{							entityList[i].row++;							entityList[i].timeToMove=TickCount()+kPlayerSpeed;							DropBreadCrump();						}	if (key==kLeftKey)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				if (entityList[i].col>0)					if (TickCount()>entityList[i].timeToMove)						{							entityList[i].col--;							entityList[i].timeToMove=TickCount()+kPlayerSpeed;							DropBreadCrump();						}	if (key==kRightKey)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				if (entityList[i].col<(kMaxCols-1))					if (TickCount()>entityList[i].timeToMove)						{							entityList[i].col++;							entityList[i].timeToMove=TickCount()+kPlayerSpeed;							DropBreadCrump();						}}// ----------------------------------------------------------------- //void ai_World::Redraw(void)// ----------------------------------------------------------------- //	{	int					i;	int					j;	TRect				objectDest;		// draw terrain	for (i=0;i<kMaxRows;i++)		for (j=0;j<kMaxCols;j++)			tb_CopyBitmap(terrainBMP,offscreenBMP,&terrainRect[terrain[i][j]],&destRect[i][j],false);	for (i=0;i<kMaxEntities;i++)		{					if (entityList[i].type==kHuman)	// draw human				{					objectDest=unitRect;					tb_OffsetRect(&objectDest,destRect[entityList[i].row][entityList[i].col].left-14,destRect[entityList[i].row][entityList[i].col].top-42);					tb_CopyMaskBitmap(objectsBMP,objectsMaskBMP,offscreenBMP,&humanRect,&humanRect,&objectDest);				}			if (entityList[i].type==kTroll)	// draw troll				{					objectDest=unitRect;					tb_OffsetRect(&objectDest,destRect[entityList[i].row][entityList[i].col].left-14,destRect[entityList[i].row][entityList[i].col].top-42);					tb_CopyMaskBitmap(objectsBMP,objectsMaskBMP,offscreenBMP,&trollRect,&trollRect,&objectDest);				}			if (entityList[i].type==kTree)	// draw troll				{					objectDest=unitRect;					tb_OffsetRect(&objectDest,destRect[entityList[i].row][entityList[i].col].left-14,destRect[entityList[i].row][entityList[i].col].top-42);					tb_CopyMaskBitmap(objectsBMP,objectsMaskBMP,offscreenBMP,&treeRect,&treeRect,&objectDest);				}						}		tb_CopyBitmap(offscreenBMP,tbWindow,&screenRect,&screenRect,false);}