#include "Toolbox.h"#include "Keys.h"#include "Remap.h"//#include "Async Sound.h"//#include "Globals.h"#include <InternetConfig.h>//---------------------------------------------------------------------------extern Boolean		applicationSuspended;TRect							gwRect[MaxGWorlds];TBoolean					gwFree[MaxGWorlds];RGBColor					gwBackColor[MaxGWorlds];PicHandle					PHandle;TBoolean					RgnFree[MaxRegions+1];CCrsrHandle				cur[MaxCursors];TBoolean					curID[MaxCursors];TBoolean					MenuFree[10];TRect							screenBounds;RGBColor    			myRed;RGBColor					myWhite;RGBColor    			myBlack;RGBColor					gwForeColor[MaxGWorlds];RGBColor					winForeColor[MaxGWorlds];RGBColor					winBackColor[MaxGWorlds];CGrafPtr 					tbsavedPort;GDHandle 					tbsavedDevice;GWorldPtr					gw[MaxGWorlds];WindowPtr					win[MaxWindows];TBoolean					winFree[MaxWindows];short							previousCursor=-1;// ----------------------------------------------------------------- //void tb_SetCursor(short id)// ----------------------------------------------------------------- //{	int			i;				if (id==0) 		{			InitCursor();			previousCursor=0;			return;		}		for (i=0;i<MaxCursors;i++)		if (curID[i]==id)			if (cur[i]!=nil) 				{					SetCCursor(cur[i]);					previousCursor=id;					return;				}					for (i=0;i<MaxCursors;i++)		if (curID[i]==0)			{				cur[i]=GetCCursor(id);				if (cur[i]!=nil)					{						curID[i]=id;						SetCCursor(cur[i]);						previousCursor=id;					}				return;			}	previousCursor=-1;}// ----------------------------------------------------------------- //void tb_SetForeColor(TBitmap dstBitmap, short red, short green, short blue)// ----------------------------------------------------------------- //{	if (dstBitmap>4999)		{			winForeColor[dstBitmap-5000].red=red;			winForeColor[dstBitmap-5000].green=green;			winForeColor[dstBitmap-5000].blue=blue;		}	else		{			gwForeColor[dstBitmap].red=red;			gwForeColor[dstBitmap].green=green;			gwForeColor[dstBitmap].blue=blue;		}}// ----------------------------------------------------------------- //void tb_Line(TBitmap dstBitmap, int h1, int v1, int h2, int v2, int width)// ----------------------------------------------------------------- //{	GetGWorld(&tbsavedPort, &tbsavedDevice);			if (dstBitmap>4999)		{			SetPortWindowPort(win[dstBitmap-5000]);			RGBForeColor(&winForeColor[dstBitmap-5000]);			RGBBackColor(&winBackColor[dstBitmap-5000]);			PenSize(width,width);			MoveTo(h1,v1);			LineTo(h2,v2);						RGBForeColor(&myBlack);			RGBBackColor(&myWhite);					}	else		{			SetGWorld(gw[dstBitmap], nil);			RGBForeColor(&gwForeColor[dstBitmap]);			RGBBackColor(&gwBackColor[dstBitmap]);						PenSize(width,width);			MoveTo(h1,v1);			LineTo(h2,v2);						RGBForeColor(&myBlack);			RGBBackColor(&myWhite);		}	SetGWorld(tbsavedPort, tbsavedDevice);			return;}// ----------------------------------------------------------------- //void tb_DrawPictureToBitmap(TBitmap dstBitmap, int Picture, int h, int v, TRect *r)// ----------------------------------------------------------------- //{  CGrafPtr              thePort;	SetRect(r, 0, 0, 0, 0);			PHandle = GetPicture(Picture);	if (PHandle != nil)		{			HLock((Handle)PHandle);			r->right = r->left + ((**(PHandle)).picFrame.right - (**(PHandle)).picFrame.left);			r->bottom = r->top + ((**(PHandle)).picFrame.bottom - (**(PHandle)).picFrame.top);			OffsetRect(r, h, v);			if (dstBitmap>4999)				{					GetGWorld(&tbsavedPort, &tbsavedDevice);							SetPortWindowPort(win[dstBitmap-5000]);					DrawPicture(PHandle, r);					SetGWorld(tbsavedPort, tbsavedDevice);								thePort = GetWindowPort(win[dstBitmap-5000]);					if (QDIsPortBuffered(thePort))					{					  RgnHandle theRgn;					  theRgn = NewRgn();					  SetRectRgn(theRgn, r->left, r->top, r->right, r->bottom);					  QDFlushPortBuffer(thePort, theRgn);					  DisposeRgn(theRgn);					}				}			else				{					GetGWorld(&tbsavedPort, &tbsavedDevice);							SetGWorld(gw[dstBitmap], nil);					DrawPicture(PHandle, r);					SetGWorld(tbsavedPort, tbsavedDevice);					}			HUnlock((Handle)PHandle);			ReleaseResource((Handle)PHandle);							}	return;}// ----------------------------------------------------------------- //void tb_CtoPStr255(char *str,unsigned char str2[])// ----------------------------------------------------------------- //{	int		len=0;	int		i;		for(i = 0; i < 255; i++)		if (str[i]=='\0')			{				len=i;				break;			}		str2[0] = len;		for(i = 1; i <= len; i++)		str2[i] = str[i-1];					}// ----------------------------------------------------------------- //void tb_DisplayError(char errMess[kStringLength])// ----------------------------------------------------------------- //{		DialogPtr						d;		short								itemHit=0;		Str255							s;		GetGWorld(&tbsavedPort, &tbsavedDevice);		tb_CtoPStr255(errMess,s);		SysBeep(0);	  tb_SetCursor(0);		d = GetNewDialog(128, nil, (WindowPtr)-1L);		SetPortWindowPort(GetDialogWindow(d));				ShowWindow(GetDialogWindow(d));		ParamText(s,"\p","\p","\p");		while (itemHit!=1)			ModalDialog(nil, &itemHit);		SetGWorld(tbsavedPort, tbsavedDevice);								DisposeDialog(d);		//tb_Halt();	}   // ----------------------------------------------------------------- //int tb_SetWindowPtr(WindowPtr w)// ----------------------------------------------------------------- //{	int					i;	int					found=-1;	for (i=0; i<MaxWindows; i++)		if (winFree[i])			{				found=i;				break;			}	if (found==-1) return (WindowError);		winFree[found]=false;	win[found]=w;	return (found+5000);}// ----------------------------------------------------------------- //int tb_DoDialog(int id)// ----------------------------------------------------------------- //	{	DialogPtr				Dialog;	short						itemHit=0;	ControlRef			defaultButton;	GetPort(&(GrafPtr)tbsavedPort);	tb_SetCursor(0);	Dialog = GetNewDialog(id, nil, (WindowPtr)-1L);	if (Dialog!=NULL)		{			GetDialogItemAsControl(Dialog,1,&defaultButton);			SetWindowDefaultButton(GetDialogWindow(Dialog),defaultButton);			SetPortWindowPort(GetDialogWindow(Dialog));					ShowWindow(GetDialogWindow(Dialog));			while (itemHit<1)				{					ModalDialog(myGenericFilter, &itemHit);					SelectWindow(GetDialogWindow(Dialog));				}			SetGWorld(tbsavedPort, tbsavedDevice);									DisposeDialog(Dialog);			return (itemHit);		}	SetPortWindowPort(GetWindowFromPort(tbsavedPort));	return (itemHit);		 }// ----------------------------------------------------------------- //int tb_GetWindowMatch(WindowPtr wp) // Ignore this function.  It is Mac specific.// ----------------------------------------------------------------- //{		int			i;				for (i=0;i<MaxWindows;i++)			if (wp==win[i])	return (i+5000);					return (-1);}// ----------------------------------------------------------------- //void tb_FlushMouseEvents(void)// ----------------------------------------------------------------- //{	FlushEvents(mDownMask + mUpMask, 0);	}// ----------------------------------------------------------------- //void tb_CloseToolbox(void)// ----------------------------------------------------------------- //{	int				i;			for (i=0; i<MaxGWorlds; i++)		if (gwFree[i]==false)		{			if (gw[i]!=nil)				{					DisposeGWorld(gw[i]);					gw[i]=nil;					gwFree[i]=true;				}		}}// ----------------------------------------------------------------- //int tb_Rnd (int min, int max)// ----------------------------------------------------------------- //{	return (((abs(Random())%(max-min+1))+min));		 }// ----------------------------------------------------------------- //void tb_InitializeToolbox(void)// ----------------------------------------------------------------- //{	int					i;	BitMap 			screenBits;		tb_SetCursor(0);	GetQDGlobalsScreenBits(&screenBits);	screenBounds = screenBits.bounds;	  myWhite.red=65535;  myWhite.green=65535;  myWhite.blue=65535;  myBlack.red=0;  myBlack.green=0;  myBlack.blue=0;  myRed.red=49152;  myRed.green=0;  myRed.blue=0;		for (i=0; i<MaxGWorlds; i++)		{			gwFree[i]=true;			gwForeColor[i].red=0;			gwForeColor[i].green=0;			gwForeColor[i].blue=0;			gwBackColor[i].red=65535;			gwBackColor[i].green=65535;			gwBackColor[i].blue=65535;		}	for (i=0; i<MaxWindows; i++)		{			winFree[i]=true;			winForeColor[i].red=0;			winForeColor[i].green=0;			winForeColor[i].blue=0;			winBackColor[i].red=65535;			winBackColor[i].green=65535;			winBackColor[i].blue=65535;					}	MenuFree[0]=false;	for (i=1; i<10; i++)		{			MenuFree[i]=true;		}	for (i=0; i<MaxCursors; i++)		{			curID[i]=0;		}	for (i=0; i<MaxRegions; i++)		{			RgnFree[i]=true;		}}// ----------------------------------------------------------------- //int tb_CreateBitmap(TRect *r, int Picture, int Depth)// ----------------------------------------------------------------- //{	int					i;	int					found=-1;	TRect				t;  OSErr       Error;  	for (i=0; i<MaxGWorlds; i++)		if (gwFree[i]==true)			{				found=i;				break;			}		if (found==-1) return (GWorldError);				if (Picture>0)		{			PHandle = GetPicture(Picture);			SetRect(r, 0, 0, 0, 0);			if (PHandle != nil)				{					HLock((Handle)PHandle);					r->right = r->left + ((**(PHandle)).picFrame.right - (**(PHandle)).picFrame.left);					r->bottom =r->top + ((**(PHandle)).picFrame.bottom - (**(PHandle)).picFrame.top);					Error = NewGWorld(&gw[found], Depth, r, nil, nil, 0);					gwRect[found]=*r;					if (Error != noErr)						{							#if (Debug==true)								tb_DisplayError("tb_CreateBitmap:  Unable to create GWorld.");							#endif							return (GWorldError);						}					GetGWorld(&tbsavedPort, &tbsavedDevice);					LockPixels( GetGWorldPixMap( gw[found] ) );					SetGWorld(gw[found], nil);					RGBForeColor(&myBlack);					RGBBackColor(&myWhite);					PaintRect(r);					DrawPicture(PHandle, r);					HUnlock((Handle)PHandle);					ReleaseResource((Handle)PHandle);					RGBForeColor(&myBlack);					RGBBackColor(&myWhite);					gwForeColor[found].red=0;					gwForeColor[found].green=0;					gwForeColor[found].blue=0;					gwBackColor[found].red=65535;					gwBackColor[found].green=65535;					gwBackColor[found].blue=65535;										SetGWorld(tbsavedPort, tbsavedDevice);											}			else				{					SysBeep(0);					#if (Debug==true)						tb_DisplayError("tb_CreateBitmap:  Nil picture.");					#endif				}		}	else 		{			t=*r;			OffsetRect(&t, -t.left, -t.top);			Error = NewGWorld(&gw[found], Depth, &t, NULL, NULL, 0);			gwRect[found]=t;			GetGWorld(&tbsavedPort, &tbsavedDevice);			LockPixels( GetGWorldPixMap( gw[found] ) );			SetGWorld(gw[found], nil);			RGBForeColor(&myBlack);			RGBBackColor(&myWhite);			PaintRect(&t);			gwForeColor[found].red=0;			gwForeColor[found].green=0;			gwForeColor[found].blue=0;			gwBackColor[found].red=65535;			gwBackColor[found].green=65535;			gwBackColor[found].blue=65535;			SetGWorld(tbsavedPort, tbsavedDevice);			}	gwFree[found]=false;		return (found);}// ----------------------------------------------------------------- //TBoolean tb_IsKeyDown (short KeyCode)// ----------------------------------------------------------------- //{	KeyMap		myKeyMap;	short			byteIndex;	char			theByte, theBit;	char			*thePointer;		if (applicationSuspended)		return (false);			GetKeys(myKeyMap);	byteIndex = KeyCode >> 3;	thePointer =(char*)&myKeyMap[0];	theByte = *(char*)(thePointer + byteIndex);	theBit = 1L << (KeyCode & 7);	return ((theByte & theBit) != 0);	}// ----------------------------------------------------------------- //void tb_CopyBitmap(TBitmap srcBitmap, TBitmap dstBitmap, TRect *srcRect, TRect *dstRect, TBoolean Transparent)// ----------------------------------------------------------------- //{	CGrafPtr              thePort;		GetGWorld(&tbsavedPort, &tbsavedDevice);	if (dstBitmap>4999)		{			SetPortWindowPort(win[dstBitmap-5000]);			RGBForeColor(&myBlack);			RGBBackColor(&myWhite);			CopyBits( GetPortBitMapForCopyBits( gw[srcBitmap] ), GetPortBitMapForCopyBits(GetWindowPort( win[dstBitmap-5000] )), srcRect, dstRect, srcCopy, NULL );		      thePort = GetWindowPort(win[dstBitmap-5000]);			if (QDIsPortBuffered(thePort))				{				  RgnHandle theRgn;				  theRgn = NewRgn();				  SetRectRgn(theRgn, dstRect->left, dstRect->top, dstRect->right, dstRect->bottom);				  QDFlushPortBuffer(thePort, theRgn);				  DisposeRgn(theRgn);				}		}	else		{			SetGWorld(gw[dstBitmap], nil);			RGBForeColor(&myBlack);			RGBBackColor(&myWhite);								if (Transparent)				{					RGBBackColor(&gwBackColor[dstBitmap]);										CopyBits( GetPortBitMapForCopyBits( gw[srcBitmap] ), GetPortBitMapForCopyBits( gw[dstBitmap] ), srcRect, dstRect, transparent, NULL );				}			else				CopyBits( GetPortBitMapForCopyBits( gw[srcBitmap] ), GetPortBitMapForCopyBits( gw[dstBitmap] ), srcRect, dstRect, srcCopy, NULL );		}	SetGWorld(tbsavedPort, tbsavedDevice);			}// ----------------------------------------------------------------- //void tb_CopyMaskBitmap(TBitmap srcBitmap, TBitmap maskBitmap, TBitmap dstBitmap, TRect *srcRect, TRect *maskRect, TRect *dstRect)// ----------------------------------------------------------------- //{	CGrafPtr              thePort;	if (dstBitmap>4999)		{			GetGWorld(&tbsavedPort, &tbsavedDevice);			SetPortWindowPort(win[dstBitmap-5000]);			RGBForeColor(&myBlack);			RGBBackColor(&myWhite);			CopyMask(GetPortBitMapForCopyBits(gw[srcBitmap]),GetPortBitMapForCopyBits(gw[maskBitmap]),GetPortBitMapForCopyBits(GetWindowPort( win[dstBitmap-5000] )),srcRect,maskRect,dstRect);						          	thePort = GetWindowPort(win[dstBitmap-5000]);			if (QDIsPortBuffered(thePort))				{				  RgnHandle theRgn;				  theRgn = NewRgn();				  SetRectRgn(theRgn, dstRect->left, dstRect->top, dstRect->right, dstRect->bottom);				  QDFlushPortBuffer(thePort, theRgn);				  DisposeRgn(theRgn);				}			SetGWorld(tbsavedPort, tbsavedDevice);					}	else		{		  if ((dstBitmap)>=MaxGWorlds)    return; 		  if (gwFree[dstBitmap])         return;			GetGWorld(&tbsavedPort, &tbsavedDevice);			SetGWorld(gw[dstBitmap], nil);			RGBForeColor(&myBlack);			RGBBackColor(&myWhite);								CopyMask(GetPortBitMapForCopyBits(gw[srcBitmap]),GetPortBitMapForCopyBits(gw[maskBitmap]),GetPortBitMapForCopyBits(gw[dstBitmap]),srcRect,maskRect,dstRect);												SetGWorld(tbsavedPort, tbsavedDevice);					}}