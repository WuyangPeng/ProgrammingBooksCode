#include "Toolbox.h"#include "AICommon.h"		TWindow							tbWindow;	ai_World						MainWorld;	ai_Entity						entityList[kMaxEntities];		TBitmap							terrainBMP;	TBitmap							objectsBMP;	TBitmap							objectsMaskBMP;	TBitmap							offscreenBMP;	TRect								unitRect;	TRect								humanRect;	TRect								trollRect;	TRect								treeRect;	TRect								terrainRect[kMaxTiles];	TRect								screenRect;	TRect								destRect[kMaxRows][kMaxCols];	TBoolean						terrainBackup[kMaxRows][kMaxCols];	TBoolean	terrain[kMaxRows][kMaxCols]={		1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1	};// ----------------------------------------------------------------- //ai_Entity::ai_Entity()// ----------------------------------------------------------------- //{	int								i;	unsigned long			randomSeed;		GetDateTime(&randomSeed);  SetQDGlobalsRandomSeed(randomSeed);	for (i=0;i<kMaxEntities;i++)		{			entityList[i].row=-1;			entityList[i].col=-1;			entityList[i].type=-1;			entityList[i].state=-1;			entityList[i].startRow=-1;			entityList[i].startCol=-1;			entityList[i].endRow=-1;			entityList[i].endCol=-1;			entityList[i].target=-1;			entityList[i].timeToMove=0;		}		entityList[0].New(kHuman,kPlayer,3,10,0,0);	entityList[1].New(kTroll,kPatternMovement,4,2,0,0);	entityList[1].InitializePathArrays();		entityList[1].BuildPathSegment(4, 2, 4, 11);	entityList[1].BuildPathSegment(4, 11, 2, 24);	entityList[1].BuildPathSegment(2, 24, 13, 27);	entityList[1].BuildPathSegment(13, 27, 16, 24);	entityList[1].BuildPathSegment(16, 24, 13, 17);	entityList[1].BuildPathSegment(13, 17, 13, 13);	entityList[1].BuildPathSegment(13, 13, 17, 5);	entityList[1].BuildPathSegment(17, 5, 4, 2);	entityList[1].NormalizePattern();	entityList[1].patternRowOffset=5;	entityList[1].patternColOffset=2;	entityList[1].row=entityList[1].pathRow[0]+entityList[1].patternRowOffset;	entityList[1].col=entityList[1].pathCol[0]+entityList[1].patternColOffset;		}// ----------------------------------------------------------------- //ai_Entity::~ai_Entity()// ----------------------------------------------------------------- //{}// ----------------------------------------------------------------- //void ai_Entity::New(int theType, int theState, int theStartRow, int theStartCol, int theEndRow, int theEndCol)// ----------------------------------------------------------------- //{	int							i;		type=theType;	row=theStartRow;	col=theStartCol;	state=theState;	startRow=theStartRow;	startCol=theStartCol;	endRow=theEndRow;	endCol=theEndCol;	nextStep=0;	for (i=0;i<kMaxPathLength;i++)		{			pathRow[i]=-1;			pathCol[i]=-1;		}	pathRowTarget=-1;	pathColTarget=-1;	if (state==kChasing)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				target=i;}// ----------------------------------------------------------------- //void ai_Entity::FollowPattern(void)// ----------------------------------------------------------------- //{		if (nextStep>=0)		if ((pathRow[nextStep]+patternRowOffset>=0) && (pathCol[nextStep]+patternColOffset>=0))			{				row=pathRow[nextStep]+patternRowOffset;				col=pathCol[nextStep]+patternColOffset;				nextStep++;				if (nextStep>=kMaxPathLength)					nextStep=0;				if (nextStep>=pathSize)					nextStep=0;			}			}// ----------------------------------------------------------------- //void ai_Entity::InitializePathArrays(void)// ----------------------------------------------------------------- //{  int i;  nextStep=0;  for (i=0;i<kMaxPathLength;i++)    {      pathRow[i]=-1;      pathCol[i]=-1;    }}// ----------------------------------------------------------------- //void ai_Entity::NormalizePattern(void)// ----------------------------------------------------------------- //{   int i;   int rowOrigin=pathRow[0];   int colOrigin=pathCol[0];      for (i=0;i<kMaxPathLength;i++)   	if ((pathRow[i]==-1) && (pathCol[i]==-1))   		{   			pathSize=i-1;   			break;			}			   for (i=0;i<=pathSize;i++)      {         pathRow[i]=pathRow[i]-rowOrigin;         pathCol[i]=pathCol[i]-colOrigin;      }}// ----------------------------------------------------------------- //void ai_Entity::BuildPathSegment(int startingRow, int startingCol, int endingRow, int endingCol)// ----------------------------------------------------------------- //{	int	nextRow=startingRow;	int nextCol=startingCol;	int deltaRow=endingRow-startingRow;	int deltaCol=endingCol-startingCol;	int stepRow;	int stepCol; 	int currentStep;	int fraction;	int	i;		for (i=0;i<kMaxPathLength;i++)		if ((pathRow[i]==-1) && (pathCol[i]==-1))			{				currentStep=i;				break;			}  if (deltaRow < 0) stepRow=-1; else stepRow=1;  if (deltaCol < 0) stepCol=-1;	else stepCol=1;  deltaRow=abs(deltaRow*2);  deltaCol=abs(deltaCol*2);	pathRow[currentStep]=nextRow;	pathCol[currentStep]=nextCol;	currentStep++;	if (currentStep>=kMaxPathLength)		return;			if (deltaCol > deltaRow) 		{			fraction = deltaRow * 2 - deltaCol;			while (nextCol != endingCol) 				{					if (fraction >= 0) 						{							nextRow += stepRow;							fraction = fraction - deltaCol;						}					nextCol = nextCol + stepCol;					fraction = fraction + deltaRow;					pathRow[currentStep]=nextRow;					pathCol[currentStep]=nextCol;					currentStep++;					if (currentStep>=kMaxPathLength)						return;			}	  } 	 else 	 {		fraction = deltaCol * 2 - deltaRow;		while (nextRow != endingRow) 			{				if (fraction >= 0) 					{						nextCol = nextCol + stepCol;						fraction = fraction - deltaRow;					}				nextRow = nextRow + stepRow;				fraction = fraction + deltaCol;				pathRow[currentStep]=nextRow;				pathCol[currentStep]=nextCol;				currentStep++;				if (currentStep>=kMaxPathLength)					return;			}	  }	}     // ----------------------------------------------------------------- //void ai_Entity::ShowPath(void)// ----------------------------------------------------------------- //{	int	i;	for (i=0;i<=pathSize;i++)      terrain[pathRow[i]+patternRowOffset][pathCol[i]+patternColOffset]=kRed;	}// ----------------------------------------------------------------- //ai_World::ai_World()// ----------------------------------------------------------------- //{	TRect				r;	int					i;	int					j;		tb_InitializeToolbox();	showPath=false;		// offscreen buffer	tb_SetRect(&screenRect,0,0,720,480);	offscreenBMP=tb_CreateBitmap(&screenRect, -1, kScreenDepth);		// terrain graphics	terrainBMP=tb_CreateBitmap(&r, 128, kScreenDepth);	// terrain graphics	objectsBMP=tb_CreateBitmap(&r, 129, kScreenDepth);	objectsMaskBMP=tb_CreateBitmap(&r, 130, kScreenDepth);		tb_SetRect(&unitRect,1,1,49,63);	tb_SetRect(&humanRect,1,1,49,63);	tb_SetRect(&trollRect,50,1,98,63);	tb_SetRect(&treeRect,99,1,147,63);	tb_SetRect(&terrainRect[kGround],1,1,25,25);	tb_SetRect(&terrainRect[kWater],26,1,50,25);	tb_SetRect(&terrainRect[kBridge],51,1,75,25);	tb_SetRect(&terrainRect[kRed],76,1,100,25);	for (i=0;i<kMaxRows;i++)		for (j=0;j<kMaxCols;j++)			{				tb_SetRect(&destRect[i][j],(24*j),(24*i),(24*j)+25,(24*i)+25);				terrainBackup[i][j]=terrain[i][j];			}}// ----------------------------------------------------------------- //ai_World::~ai_World()// ----------------------------------------------------------------- //{}// ----------------------------------------------------------------- //void ai_World::UpdateWorld(void)// ----------------------------------------------------------------- //	{	int				i;	int				j;			for (i=0;i<kMaxRows;i++)		for (j=0;j<kMaxCols;j++)			terrain[i][j]=terrainBackup[i][j];		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPatternMovement) // only show paths for pattern movement				{						entityList[1].ShowPath();				}	// move entities	for (i=0;i<kMaxEntities;i++)		{					if (entityList[i].state==kPatternMovement)				if (TickCount()>entityList[i].timeToMove)					{							entityList[i].timeToMove=TickCount()+kEntitySpeed;						entityList[i].FollowPattern();					}		}	Redraw();	}// ----------------------------------------------------------------- //void ai_World::KeyDown(int key)// ----------------------------------------------------------------- //	{	int							i;		if (key==kUpKey)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				if (TickCount()>entityList[i].timeToMove)					if (entityList[i].row>0)						{							entityList[i].row--;							entityList[i].timeToMove=TickCount()+kPlayerSpeed;						}							if (key==kDownKey)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				if (entityList[i].row<(kMaxRows-1))					if (TickCount()>entityList[i].timeToMove)						{							entityList[i].row++;							entityList[i].timeToMove=TickCount()+kPlayerSpeed;						}	if (key==kLeftKey)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				if (entityList[i].col>0)					if (TickCount()>entityList[i].timeToMove)						{							entityList[i].col--;							entityList[i].timeToMove=TickCount()+kPlayerSpeed;						}	if (key==kRightKey)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				if (entityList[i].col<(kMaxCols-1))					if (TickCount()>entityList[i].timeToMove)						{							entityList[i].col++;							entityList[i].timeToMove=TickCount()+kPlayerSpeed;						}}// ----------------------------------------------------------------- //void ai_World::Redraw(void)// ----------------------------------------------------------------- //	{	int					i;	int					j;	TRect				objectDest;		// draw terrain	for (i=0;i<kMaxRows;i++)		for (j=0;j<kMaxCols;j++)			tb_CopyBitmap(terrainBMP,offscreenBMP,&terrainRect[terrain[i][j]],&destRect[i][j],false);	for (i=0;i<kMaxEntities;i++)		{					if (entityList[i].type==kHuman)	// draw human				{					objectDest=unitRect;					tb_OffsetRect(&objectDest,destRect[entityList[i].row][entityList[i].col].left-14,destRect[entityList[i].row][entityList[i].col].top-42);					tb_CopyMaskBitmap(objectsBMP,objectsMaskBMP,offscreenBMP,&humanRect,&humanRect,&objectDest);				}			if (entityList[i].type==kTroll)	// draw troll				{					objectDest=unitRect;					tb_OffsetRect(&objectDest,destRect[entityList[i].row][entityList[i].col].left-14,destRect[entityList[i].row][entityList[i].col].top-42);					tb_CopyMaskBitmap(objectsBMP,objectsMaskBMP,offscreenBMP,&trollRect,&trollRect,&objectDest);				}			if (entityList[i].type==kTree)	// draw troll				{					objectDest=unitRect;					tb_OffsetRect(&objectDest,destRect[entityList[i].row][entityList[i].col].left-14,destRect[entityList[i].row][entityList[i].col].top-42);					tb_CopyMaskBitmap(objectsBMP,objectsMaskBMP,offscreenBMP,&treeRect,&treeRect,&objectDest);				}						}			tb_CopyBitmap(offscreenBMP,tbWindow,&screenRect,&screenRect,false);}