#include "Toolbox.h"GWorldPtr					gw[MaxGWorlds];TBoolean					gwFree[MaxGWorlds];TRect							gwRect[MaxGWorlds];RGBColor					gwForeColor[MaxGWorlds];RGBColor					gwBackColor[MaxGWorlds];WindowPtr					win[MaxWindows];TBoolean					winFree[MaxWindows];TRect							winRect[MaxWindows];RGBColor					winForeColor[MaxGWorlds];RGBColor					winBackColor[MaxGWorlds];RGBColor					myWhite;RGBColor    			myBlack;PicHandle					PHandle;CGrafPtr 					tbsavedPort;GDHandle 					tbsavedDevice;// ----------------------------------------------------------------- //int tb_CreateBitmap(TRect *r, int Picture, int Depth)// ----------------------------------------------------------------- //{	int					i;	int					found=-1;	TRect				t;  OSErr       Error;  	for (i=0; i<MaxGWorlds; i++)		if (gwFree[i]==true)			{				found=i;				break;			}		if (found==-1) return (-1);				if (Picture>0)		{			PHandle = GetPicture(Picture);			SetRect(r, 0, 0, 0, 0);			if (PHandle != nil)				{					HLock((Handle)PHandle);					r->right = r->left + ((**(PHandle)).picFrame.right - (**(PHandle)).picFrame.left);					r->bottom =r->top + ((**(PHandle)).picFrame.bottom - (**(PHandle)).picFrame.top);					Error = NewGWorld(&gw[found], Depth, r, nil, nil, 0);					gwRect[found]=*r;					if (Error != noErr)						{							return (-1);						}					GetGWorld(&tbsavedPort, &tbsavedDevice);					LockPixels( GetGWorldPixMap( gw[found] ) );					SetGWorld(gw[found], nil);					RGBForeColor(&myBlack);					RGBBackColor(&myWhite);					PaintRect(r);					DrawPicture(PHandle, r);					HUnlock((Handle)PHandle);					ReleaseResource((Handle)PHandle);					RGBForeColor(&myBlack);					RGBBackColor(&myWhite);					gwForeColor[found].red=0;					gwForeColor[found].green=0;					gwForeColor[found].blue=0;					gwBackColor[found].red=65535;					gwBackColor[found].green=65535;					gwBackColor[found].blue=65535;										SetGWorld(tbsavedPort, tbsavedDevice);											}			else				{					SysBeep(0);				}		}	else 		{			t=*r;			OffsetRect(&t, -t.left, -t.top);			Error = NewGWorld(&gw[found], Depth, &t, NULL, NULL, 0);			gwRect[found]=t;			GetGWorld(&tbsavedPort, &tbsavedDevice);			LockPixels( GetGWorldPixMap( gw[found] ) );			SetGWorld(gw[found], nil);			RGBForeColor(&myBlack);			RGBBackColor(&myWhite);			PaintRect(&t);			gwForeColor[found].red=0;			gwForeColor[found].green=0;			gwForeColor[found].blue=0;			gwBackColor[found].red=65535;			gwBackColor[found].green=65535;			gwBackColor[found].blue=65535;			SetGWorld(tbsavedPort, tbsavedDevice);			}	gwFree[found]=false;		return (found);}// ----------------------------------------------------------------- //void tb_InitializeToolbox(void)// ----------------------------------------------------------------- //{	int					i;	  myWhite.red=65535;  myWhite.green=65535;  myWhite.blue=65535;  myBlack.red=0;  myBlack.green=0;  myBlack.blue=0;		for (i=0; i<MaxGWorlds; i++)		{			gwFree[i]=true;			gwForeColor[i].red=0;			gwForeColor[i].green=0;			gwForeColor[i].blue=0;			gwBackColor[i].red=65535;			gwBackColor[i].green=65535;			gwBackColor[i].blue=65535;		}	for (i=0; i<MaxWindows; i++)		{			winFree[i]=true;			winForeColor[i].red=0;			winForeColor[i].green=0;			winForeColor[i].blue=0;			winBackColor[i].red=65535;			winBackColor[i].green=65535;			winBackColor[i].blue=65535;					}}// ----------------------------------------------------------------- //void tb_CloseToolbox(void)// ----------------------------------------------------------------- //{	int				i;			for (i=0; i<MaxGWorlds; i++)		if (gwFree[i]==false)		{			if (gw[i]!=nil)				{					DisposeGWorld(gw[i]);					gw[i]=nil;					gwFree[i]=true;				}		}}// ----------------------------------------------------------------- //int tb_GetWindowMatch(WindowPtr wp)// ----------------------------------------------------------------- //{		int			i;				for (i=0;i<MaxWindows;i++)			if (wp==win[i])	return (i+5000);					return (-1);}// ----------------------------------------------------------------- //int tb_DoDialog(int id)// ----------------------------------------------------------------- //	{	DialogPtr				Dialog;	short						itemHit=0;	ControlRef			defaultButton;	GetPort(&(GrafPtr)tbsavedPort);	InitCursor();	Dialog = GetNewDialog(id, nil, (WindowPtr)-1L);	if (Dialog!=NULL)		{			GetDialogItemAsControl(Dialog,1,&defaultButton);			SetWindowDefaultButton(GetDialogWindow(Dialog),defaultButton);			SetPortWindowPort(GetDialogWindow(Dialog));					ShowWindow(GetDialogWindow(Dialog));			while (itemHit<1)				{					ModalDialog(nil, &itemHit);					SelectWindow(GetDialogWindow(Dialog));				}			SetGWorld(tbsavedPort, tbsavedDevice);									DisposeDialog(Dialog);			return (itemHit);		}	SetPortWindowPort(GetWindowFromPort(tbsavedPort));	return (itemHit);		 }// ----------------------------------------------------------------- //void tb_CopyMaskBitmap(TBitmap srcBitmap, TBitmap maskBitmap, TBitmap dstBitmap, TRect *srcRect, TRect *maskRect, TRect *dstRect)// ----------------------------------------------------------------- //{	CGrafPtr              thePort;	if (dstBitmap>4999)		{			GetGWorld(&tbsavedPort, &tbsavedDevice);			SetPortWindowPort(win[dstBitmap-5000]);			RGBForeColor(&myBlack);			RGBBackColor(&myWhite);			CopyMask(GetPortBitMapForCopyBits(gw[srcBitmap]),GetPortBitMapForCopyBits(gw[maskBitmap]),GetPortBitMapForCopyBits(GetWindowPort( win[dstBitmap-5000] )),srcRect,maskRect,dstRect);						          	thePort = GetWindowPort(win[dstBitmap-5000]);			if (QDIsPortBuffered(thePort))				{				  RgnHandle theRgn;				  theRgn = NewRgn();				  SetRectRgn(theRgn, dstRect->left, dstRect->top, dstRect->right, dstRect->bottom);				  QDFlushPortBuffer(thePort, theRgn);				  DisposeRgn(theRgn);				}			SetGWorld(tbsavedPort, tbsavedDevice);					}	else		{		  if ((dstBitmap)>=MaxGWorlds)    return; 		  if (gwFree[dstBitmap])         return;			GetGWorld(&tbsavedPort, &tbsavedDevice);			SetGWorld(gw[dstBitmap], nil);			RGBForeColor(&myBlack);			RGBBackColor(&myWhite);								CopyMask(GetPortBitMapForCopyBits(gw[srcBitmap]),GetPortBitMapForCopyBits(gw[maskBitmap]),GetPortBitMapForCopyBits(gw[dstBitmap]),srcRect,maskRect,dstRect);												SetGWorld(tbsavedPort, tbsavedDevice);					}}// ----------------------------------------------------------------- //void tb_CopyBitmap(TBitmap srcBitmap, TBitmap dstBitmap, TRect *srcRect, TRect *dstRect, TBoolean Transparent)// ----------------------------------------------------------------- //{	CGrafPtr              thePort;		GetGWorld(&tbsavedPort, &tbsavedDevice);	if (dstBitmap>4999)		{			SetPortWindowPort(win[dstBitmap-5000]);			RGBForeColor(&myBlack);			RGBBackColor(&myWhite);			CopyBits( GetPortBitMapForCopyBits( gw[srcBitmap] ), GetPortBitMapForCopyBits(GetWindowPort( win[dstBitmap-5000] )), srcRect, dstRect, srcCopy, NULL );		      thePort = GetWindowPort(win[dstBitmap-5000]);			if (QDIsPortBuffered(thePort))				{				  RgnHandle theRgn;				  theRgn = NewRgn();				  SetRectRgn(theRgn, dstRect->left, dstRect->top, dstRect->right, dstRect->bottom);				  QDFlushPortBuffer(thePort, theRgn);				  DisposeRgn(theRgn);				}		}	else		{			SetGWorld(gw[dstBitmap], nil);			RGBForeColor(&myBlack);			RGBBackColor(&myWhite);								if (Transparent)				{					RGBBackColor(&gwBackColor[dstBitmap]);										CopyBits( GetPortBitMapForCopyBits( gw[srcBitmap] ), GetPortBitMapForCopyBits( gw[dstBitmap] ), srcRect, dstRect, transparent, NULL );				}			else				CopyBits( GetPortBitMapForCopyBits( gw[srcBitmap] ), GetPortBitMapForCopyBits( gw[dstBitmap] ), srcRect, dstRect, srcCopy, NULL );		}	SetGWorld(tbsavedPort, tbsavedDevice);			}// ----------------------------------------------------------------- //int tb_Rnd (int min, int max)// ----------------------------------------------------------------- //{	int			n;		n=(Random())%(max-min+1);	n=abs((double)n)+min;		return (n);		 }// ----------------------------------------------------------------- //TBoolean tb_IsKeyDown (short KeyCode)// ----------------------------------------------------------------- //{	KeyMap		myKeyMap;	short			byteIndex;	char			theByte, theBit;	char			*thePointer;				GetKeys(myKeyMap);	byteIndex = KeyCode >> 3;	thePointer =(char*)&myKeyMap[0];	theByte = *(char*)(thePointer + byteIndex);	theBit = 1L << (KeyCode & 7);	return ((theByte & theBit) != 0);	}// ----------------------------------------------------------------- //void tb_FlushMouseEvents(void)// ----------------------------------------------------------------- //{	FlushEvents(mDownMask + mUpMask, 0);	}// ----------------------------------------------------------------- //int tb_SetWindowPtr(WindowPtr w)// ----------------------------------------------------------------- //{	int					i;	int					found=-1;	for (i=0; i<MaxWindows; i++)		if (winFree[i])			{				found=i;				break;			}	if (found==-1) return (-1);		winFree[found]=false;	win[found]=w;	return (found+5000);}