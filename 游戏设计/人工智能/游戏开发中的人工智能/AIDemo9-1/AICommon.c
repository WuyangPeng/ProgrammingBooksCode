#include "Toolbox.h"#include "AICommon.h"		TWindow							tbWindow;	ai_World						MainWorld;	ai_Entity						entityList[kMaxEntities];		TBitmap							terrainBMP;	TBitmap							objectsBMP;	TBitmap							objectsMaskBMP;	TBitmap							offscreenBMP;	TRect								unitRect;	TRect								redAntRect;	TRect								blackAntRect;	TRect								terrainRect[kMaxTiles];	TRect								screenRect;	TRect								destRect[kMaxRows][kMaxCols];	int									terrainBackup[kMaxRows][kMaxCols];		int									terrain[kMaxRows][kMaxCols];	TBoolean						pause=false;	// ----------------------------------------------------------------- //ai_Entity::ai_Entity()// ----------------------------------------------------------------- //{	unsigned long			randomSeed;	int								i;		GetDateTime(&randomSeed);  SetQDGlobalsRandomSeed(randomSeed);	for (i=0;i<kMaxEntities;i++)		{			entityList[i].row=0;			entityList[i].col=0;			entityList[i].type=0;			entityList[i].state=0;			entityList[i].timeToMove=TickCount()+tb_Rnd(0,120);		}	entityList[0].New(kRedAnt,kForage,5,5);	entityList[1].New(kRedAnt,kForage,8,5);		entityList[2].New(kBlackAnt,kForage,5,36);	entityList[3].New(kBlackAnt,kForage,8,36);	}// ----------------------------------------------------------------- //ai_Entity::~ai_Entity()// ----------------------------------------------------------------- //{}// ----------------------------------------------------------------- //void ai_Entity::Forage(void)// ----------------------------------------------------------------- //{	int			rowMove;	int			colMove;	int			newRow;	int			newCol;	int			foodRow;	int			foodCol;	int			poisonRow;	int			poisonCol;	if (TickCount()<timeToMove)		return;	rowMove=tb_Rnd(0,2)-1;	colMove=tb_Rnd(0,2)-1;	newRow=row+rowMove;	newCol=col+colMove;	if (newRow<1) return;	if (newCol<1) return;	if (newRow>=kMaxRows-1) return;	if (newCol>=kMaxCols-1) return;	if ((terrain[newRow][newCol]==kGround) || (terrain[newRow][newCol]==kWater))		{			row=newRow;			col=newCol;		}	if (terrain[newRow][newCol]==kFood)		{			row=newRow;			col=newCol;			terrain[row][col]=kGround;			state=kGoHome;			do {				foodRow=tb_Rnd(2,kMaxRows)-3;				foodCol=tb_Rnd(2,kMaxCols)-3;			} while (terrain[foodRow][foodCol]!=kGround);			terrain[foodRow][foodCol]=kFood;		}	if (terrain[newRow][newCol]==kPoison)		{			row=newRow;			col=newCol;			terrain[row][col]=kGround;			state=kDead;			do {			poisonRow=tb_Rnd(2,kMaxRows)-3;			poisonCol=tb_Rnd(2,kMaxCols)-3;			} while (terrain[poisonRow][poisonCol]!=kGround);			terrain[poisonRow][poisonCol]=kPoison;		}	timeToMove=TickCount()+0;}// ----------------------------------------------------------------- //void ai_Entity::Dead(void)// ----------------------------------------------------------------- //{  if (TickCount()<timeToMove)     return;	type=0;	row=0;	col=0;	state=0;  timeToMove=TickCount()+0;}// ----------------------------------------------------------------- //void ai_Entity::Thirsty(void)// ----------------------------------------------------------------- //{	int			rowMove;	int			colMove;	int			newRow;	int			newCol;	int			foodRow;	int			foodCol;	int			poisonRow;	int			poisonCol;	if (TickCount()<timeToMove)	   return;	rowMove=tb_Rnd(0,2)-1;	colMove=tb_Rnd(0,2)-1;	newRow=row+rowMove;	newCol=col+colMove;	if (newRow<1) return;	if (newCol<1) return;	if (newRow>=kMaxRows-1) return;	if (newCol>=kMaxCols-1) return;	if ((terrain[newRow][newCol]==kGround) || (terrain[newRow][newCol]==kFood))		{			row=newRow;			col=newCol;		}	if (terrain[newRow][newCol]==kWater)		{			row=newRow;			col=newCol;			terrain[row][col]=kGround;			state=kForage;			do {				foodRow=tb_Rnd(2,kMaxRows)-3;				foodCol=tb_Rnd(2,kMaxCols)-3;			} while (terrain[foodRow][foodCol]!=kGround);			terrain[foodRow][foodCol]=kWater;		}	if (terrain[newRow][newCol]==kPoison)		{			row=newRow;			col=newCol;			terrain[row][col]=kGround;			state=kDead;			do {				poisonRow=tb_Rnd(2,kMaxRows)-3;				poisonCol=tb_Rnd(2,kMaxCols)-3;			} while (terrain[poisonRow][poisonCol]!=kGround);			terrain[poisonRow][poisonCol]=kPoison;		}	timeToMove=TickCount()+0;}// ----------------------------------------------------------------- //void ai_Entity::GoHome(void)// ----------------------------------------------------------------- //{	int			rowMove;	int			colMove;	int			newRow;	int			newCol;	int			homeRow;	int			homeCol;	int			i;	int			poisonRow;	int			poisonCol;	if (TickCount()<timeToMove)		return;	if (type==kRedAnt)		{			homeRow=kRedHomeRow;			homeCol=kRedHomeCol;		}	else		{			homeRow=kBlackHomeRow;			homeCol=kBlackHomeCol;		}	if (row<homeRow)		rowMove=1;	else if (row>homeRow)		rowMove=-1;	else		rowMove=0;	if (col<homeCol)		colMove=1;	else if (col>homeCol)		colMove=-1;	else		colMove=0;	newRow=row+rowMove;	newCol=col+colMove;	if (newRow<1) return;	if (newCol<1) return;	if (newRow>=kMaxRows-1) return;	if (newCol>=kMaxCols-1) return;	if (terrain[newRow][newCol]!=kPoison)		{			row=newRow;			col=newCol;		}	else		{			row=newRow;			col=newCol;			terrain[row][col]=kGround;			state=kDead;			do {				poisonRow=tb_Rnd(2,kMaxRows)-3;				poisonCol=tb_Rnd(2,kMaxCols)-3;			} while (terrain[poisonRow][poisonCol]!=kGround);			terrain[poisonRow][poisonCol]=kPoison;		}	if ((newRow==homeRow) && (newCol==homeCol))		{			row=newRow;			col=newCol;			state=kThirsty;			for (i=0;i<kMaxEntities;i++)			if (entityList[i].type==0)				{					entityList[i].row=homeRow;					entityList[i].col=homeCol;					entityList[i].type=type;					entityList[i].state=kForage;					entityList[i].timeToMove=TickCount()+tb_Rnd(0,120);					break;				}		}	timeToMove=TickCount()+0;}// ----------------------------------------------------------------- //int ai_Entity::DistanceFrom(int t)// ----------------------------------------------------------------- //{	return (sqrt(((row-entityList[t].row) * (row-entityList[t].row)) + ((col-entityList[t].col) * (col-entityList[t].col))));	}// ----------------------------------------------------------------- //void ai_Entity::New(int theType, int theState, int theRow, int theCol)// ----------------------------------------------------------------- //{		type=theType;	row=theRow;	col=theCol;	state=theState;}// ----------------------------------------------------------------- //ai_World::ai_World()// ----------------------------------------------------------------- //{	TRect							r;	int								i;	int								j;	unsigned long			randomSeed;		tb_InitializeToolbox();		GetDateTime(&randomSeed);  SetQDGlobalsRandomSeed(randomSeed);		tb_SetRect(&screenRect,0,0,1008,768);	offscreenBMP=tb_CreateBitmap(&screenRect, -1, kScreenDepth);		terrainBMP=tb_CreateBitmap(&r, 128, kScreenDepth);	objectsBMP=tb_CreateBitmap(&r, 129, kScreenDepth);	objectsMaskBMP=tb_CreateBitmap(&r, 130, kScreenDepth);		tb_SetRect(&unitRect,1,1,63,44);	tb_SetRect(&redAntRect,1,1,63,44);	tb_SetRect(&blackAntRect,65,1,127,44);	tb_SetRect(&terrainRect[kGround],1,1,25,25);	tb_SetRect(&terrainRect[kWater],26,1,50,25);	tb_SetRect(&terrainRect[kBlackHome],51,1,75,25);	tb_SetRect(&terrainRect[kRedHome],76,1,100,25);	tb_SetRect(&terrainRect[kPoison],101,1,125,25);	tb_SetRect(&terrainRect[kFood],126,1,150,25);	for (i=0;i<kMaxRows;i++)		for (j=0;j<kMaxCols;j++)			{				tb_SetRect(&destRect[i][j],(24*j),(24*i),(24*j)+25,(24*i)+25);				terrain[i][j]=1;			}	terrain[kRedHomeRow][kRedHomeCol]=kRedHome;	terrain[kBlackHomeRow][kBlackHomeCol]=kBlackHome;		for (i=0;i<kMaxWater;i++)		terrain[tb_Rnd(2,kMaxRows)-3][tb_Rnd(2,kMaxCols)-3]=kWater;	for (i=0;i<kMaxPoison;i++)		terrain[tb_Rnd(2,kMaxRows)-3][tb_Rnd(2,kMaxCols)-3]=kPoison;	for (i=0;i<kMaxFood;i++)		terrain[tb_Rnd(2,kMaxRows)-3][tb_Rnd(2,kMaxCols)-3]=kFood;		for (i=0;i<kMaxRows;i++)		for (j=0;j<kMaxCols;j++)			terrainBackup[i][j]=terrain[i][j];}// ----------------------------------------------------------------- //ai_World::~ai_World()// ----------------------------------------------------------------- //{}// ----------------------------------------------------------------- //void ai_World::UpdateWorld(void)// ----------------------------------------------------------------- //	{	int				i;			if (tb_IsKeyDown(SpaceBar))		{			if (pause)				pause=false;			else				pause=true;			while (tb_IsKeyDown(SpaceBar));		}			if (pause)		return;		for (i=0;i<kMaxEntities;i++)		{				switch (entityList[i].state)				{					case kForage:						entityList[i].Forage();						break;					case kGoHome:						entityList[i].GoHome();						break;					case kThirsty:						entityList[i].Thirsty();						break;					case kDead:						entityList[i].Dead();						break;				}		}	Redraw();	}// ----------------------------------------------------------------- //void ai_World::Redraw(void)// ----------------------------------------------------------------- //	{	int					i;	int					j;	TRect				objectDest;		for (i=0;i<kMaxRows;i++)		for (j=0;j<kMaxCols;j++)			tb_CopyBitmap(terrainBMP,offscreenBMP,&terrainRect[terrain[i][j]],&destRect[i][j],false);	for (i=0;i<kMaxEntities;i++)		{			if (entityList[i].type==kRedAnt)				{					objectDest=unitRect;					tb_OffsetRect(&objectDest,destRect[entityList[i].row][entityList[i].col].left-14,destRect[entityList[i].row][entityList[i].col].top-42);					tb_CopyMaskBitmap(objectsBMP,objectsMaskBMP,offscreenBMP,&redAntRect,&redAntRect,&objectDest);				}			if (entityList[i].type==kBlackAnt)				{					objectDest=unitRect;					tb_OffsetRect(&objectDest,destRect[entityList[i].row][entityList[i].col].left-14,destRect[entityList[i].row][entityList[i].col].top-42);					tb_CopyMaskBitmap(objectsBMP,objectsMaskBMP,offscreenBMP,&blackAntRect,&blackAntRect,&objectDest);				}				}			tb_CopyBitmap(offscreenBMP,tbWindow,&screenRect,&screenRect,false);}