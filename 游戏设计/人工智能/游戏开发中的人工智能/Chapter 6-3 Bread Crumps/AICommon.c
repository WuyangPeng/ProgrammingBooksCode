#include "Toolbox.h"#include "AICommon.h"		TWindow							tbWindow;	ai_World						MainWorld;	ai_Entity						entityList[kMaxEntities];		TBitmap							terrainBMP;	TBitmap							objectsBMP;	TBitmap							objectsMaskBMP;	TBitmap							offscreenBMP;	TRect								unitRect;	TRect								humanRect;	TRect								trollRect;	TRect								treeRect;	TRect								terrainRect[kMaxTiles];	TRect								screenRect;	TRect								destRect[kMaxRows][kMaxCols];	TBoolean						terrainBackup[kMaxRows][kMaxCols];	TBoolean	terrain[kMaxRows][kMaxCols]={		1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1	};// ----------------------------------------------------------------- //ai_Entity::ai_Entity()// ----------------------------------------------------------------- //{	int					i;		for (i=0;i<kMaxEntities;i++)		{			entityList[i].row=-1;			entityList[i].col=-1;			entityList[i].type=-1;			entityList[i].state=-1;			entityList[i].startRow=-1;			entityList[i].startCol=-1;			entityList[i].endRow=-1;			entityList[i].endCol=-1;			entityList[i].target=-1;			entityList[i].timeToMove=0;		}	entityList[0].New(kHuman,kPlayer,3,10,0,0);	entityList[1].New(kTroll,kPatrolling,12,10,18,8);		for (i=2;i<kMaxEntities;i++)		entityList[i].New(kTree,kStatic,tb_Rnd(0,kMaxRows-1),tb_Rnd(0,kMaxCols-1),0,0);		}// ----------------------------------------------------------------- //ai_Entity::~ai_Entity()// ----------------------------------------------------------------- //{}// ----------------------------------------------------------------- //void ai_Entity::New(int theType, int theState, int theStartRow, int theStartCol, int theEndRow, int theEndCol)// ----------------------------------------------------------------- //{	int							i;		type=theType;	row=theStartRow;	col=theStartCol;	state=theState;	startRow=theStartRow;	startCol=theStartCol;	endRow=theEndRow;	endCol=theEndCol;	pathPtr=0;	for (i=0;i<kMaxPathLength;i++)		{			pathRow[i]=-1;			pathCol[i]=-1;		}	pathRowTarget=-1;	pathColTarget=-1;	for (i=0;i<kMaxTrailLength;i++)		{			trailRow[i]=-1;			trailCol[i]=-1;		}	if (state==kChasing)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				target=i;}// ----------------------------------------------------------------- //ai_World::ai_World()// ----------------------------------------------------------------- //{	TRect				r;	int					i;	int					j;		tb_InitializeToolbox();		// offscreen buffer	tb_SetRect(&screenRect,0,0,720,480);	offscreenBMP=tb_CreateBitmap(&screenRect, -1, kScreenDepth);		// terrain graphics	terrainBMP=tb_CreateBitmap(&r, 128, kScreenDepth);	// terrain graphics	objectsBMP=tb_CreateBitmap(&r, 129, kScreenDepth);	objectsMaskBMP=tb_CreateBitmap(&r, 130, kScreenDepth);		tb_SetRect(&unitRect,1,1,49,63);	tb_SetRect(&humanRect,1,1,49,63);	tb_SetRect(&trollRect,50,1,98,63);	tb_SetRect(&treeRect,99,1,147,63);	for (i=kGround;i<=kCrump15;i++)		tb_SetRect(&terrainRect[i],1+(25*(i-1)),1,(25*(i-1))+25,25);	for (i=0;i<kMaxRows;i++)		for (j=0;j<kMaxCols;j++)			{				tb_SetRect(&destRect[i][j],(24*j),(24*i),(24*j)+25,(24*i)+25);				terrainBackup[i][j]=terrain[i][j];			}}// ----------------------------------------------------------------- //ai_World::~ai_World()// ----------------------------------------------------------------- //{}// ----------------------------------------------------------------- //void ai_World::UpdateWorld(void)// ----------------------------------------------------------------- //	{	int				i;	int				j;	int				r;	int				c;	int				foundCrump;		for (i=0;i<kMaxRows;i++)		for (j=0;j<kMaxCols;j++)			terrain[i][j]=terrainBackup[i][j];	for (i=0;i<kMaxTrailLength;i++)		if ((entityList[0].trailRow[i]>=0) && (entityList[0].trailCol[i]>=0))  		terrain[entityList[0].trailRow[i]][entityList[0].trailCol[i]]=kCrump1+i;	// move entities	for (i=0;i<kMaxEntities;i++)		{			if ((entityList[i].state==kPatrolling))// entity is patrolling				if (TickCount()>entityList[i].timeToMove)					{							entityList[i].timeToMove=TickCount()+kEntitySpeed;						r=entityList[i].row;						c=entityList[i].col;						foundCrump=-1;						for (j=0;j<kMaxTrailLength;j++)							{								if ((r==entityList[0].trailRow[j]) && (c==entityList[0].trailCol[j]))									{										foundCrump=j;										break;									}								if ((r-1==entityList[0].trailRow[j]) && (c-1==entityList[0].trailCol[j]))									{										foundCrump=j;										break;									}								if ((r-1==entityList[0].trailRow[j]) && (c==entityList[0].trailCol[j]))									{										foundCrump=j;										break;									}								if ((r-1==entityList[0].trailRow[j]) && (c+1==entityList[0].trailCol[j]))									{										foundCrump=j;										break;									}								if ((r==entityList[0].trailRow[j]) && (c-1==entityList[0].trailCol[j]))									{										foundCrump=j;										break;									}								if ((r==entityList[0].trailRow[j]) && (c+1==entityList[0].trailCol[j]))									{										foundCrump=j;										break;									}								if ((r+1==entityList[0].trailRow[j]) && (c-1==entityList[0].trailCol[j]))									{										foundCrump=j;										break;									}								if ((r+1==entityList[0].trailRow[j]) && (c==entityList[0].trailCol[j]))									{										foundCrump=j;										break;									}								if ((r+1==entityList[0].trailRow[j]) && (c+1==entityList[0].trailCol[j]))									{										foundCrump=j;										break;									}							}						if (foundCrump>=0)							{								entityList[i].row=entityList[0].trailRow[foundCrump];								entityList[i].col=entityList[0].trailCol[foundCrump];							}						else							{								entityList[i].row=entityList[i].row+tb_Rnd(0,2)-1;								entityList[i].col=entityList[i].col+tb_Rnd(0,2)-1;							}													if (entityList[i].row<0)							entityList[i].row=0;						if (entityList[i].col<0)							entityList[i].col=0;						if (entityList[i].row>=kMaxRows)							entityList[i].row=kMaxRows-1;						if (entityList[i].col>=kMaxCols)							entityList[i].col=kMaxCols-1;					}		}	Redraw();	}// ----------------------------------------------------------------- //void ai_World::DropBreadCrump(void)// ----------------------------------------------------------------- //	{	int				i;		for (i=kMaxTrailLength-1;i>0;i--)		{			entityList[0].trailRow[i]=entityList[0].trailRow[i-1];			entityList[0].trailCol[i]=entityList[0].trailCol[i-1];		}	entityList[0].trailRow[0]=entityList[0].row;	entityList[0].trailCol[0]=entityList[0].col;			}// ----------------------------------------------------------------- //void ai_World::KeyDown(int key)// ----------------------------------------------------------------- //	{	int							i;		if (key==kUpKey)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				if (TickCount()>entityList[i].timeToMove)					if (entityList[i].row>0)						{							entityList[i].row--;							entityList[i].timeToMove=TickCount()+kPlayerSpeed;							DropBreadCrump();						}							if (key==kDownKey)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				if (entityList[i].row<(kMaxRows-1))					if (TickCount()>entityList[i].timeToMove)						{							entityList[i].row++;							entityList[i].timeToMove=TickCount()+kPlayerSpeed;							DropBreadCrump();						}	if (key==kLeftKey)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				if (entityList[i].col>0)					if (TickCount()>entityList[i].timeToMove)						{							entityList[i].col--;							entityList[i].timeToMove=TickCount()+kPlayerSpeed;							DropBreadCrump();						}	if (key==kRightKey)		for (i=0;i<kMaxEntities;i++)			if (entityList[i].state==kPlayer)				if (entityList[i].col<(kMaxCols-1))					if (TickCount()>entityList[i].timeToMove)						{							entityList[i].col++;							entityList[i].timeToMove=TickCount()+kPlayerSpeed;							DropBreadCrump();						}}// ----------------------------------------------------------------- //void ai_World::Redraw(void)// ----------------------------------------------------------------- //	{	int					i;	int					j;	TRect				objectDest;		// draw terrain	for (i=0;i<kMaxRows;i++)		for (j=0;j<kMaxCols;j++)			tb_CopyBitmap(terrainBMP,offscreenBMP,&terrainRect[terrain[i][j]],&destRect[i][j],false);	for (i=0;i<kMaxEntities;i++)		{					if (entityList[i].type==kHuman)	// draw human				{					objectDest=unitRect;					tb_OffsetRect(&objectDest,destRect[entityList[i].row][entityList[i].col].left-14,destRect[entityList[i].row][entityList[i].col].top-42);					tb_CopyMaskBitmap(objectsBMP,objectsMaskBMP,offscreenBMP,&humanRect,&humanRect,&objectDest);				}			if (entityList[i].type==kTroll)	// draw troll				{					objectDest=unitRect;					tb_OffsetRect(&objectDest,destRect[entityList[i].row][entityList[i].col].left-14,destRect[entityList[i].row][entityList[i].col].top-42);					tb_CopyMaskBitmap(objectsBMP,objectsMaskBMP,offscreenBMP,&trollRect,&trollRect,&objectDest);				}			if (entityList[i].type==kTree)	// draw tree				{					objectDest=unitRect;					tb_OffsetRect(&objectDest,destRect[entityList[i].row][entityList[i].col].left-14,destRect[entityList[i].row][entityList[i].col].top-42);					tb_CopyMaskBitmap(objectsBMP,objectsMaskBMP,offscreenBMP,&treeRect,&treeRect,&objectDest);				}						}		tb_CopyBitmap(offscreenBMP,tbWindow,&screenRect,&screenRect,false);}