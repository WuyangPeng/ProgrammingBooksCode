// T3DLIB10.CPP - New rasterizers, perspective correct, flat, gouraud, light mapping
// alpha blending...

// I N C L U D E S ///////////////////////////////////////////////////////////

#define DEBUG_ON

#define WIN32_LEAN_AND_MEAN  

#include <windows.h>   // include important windows stuff
#include <windowsx.h> 
#include <mmsystem.h>
#include <objbase.h>
#include <iostream.h> // include important C/C++ stuff
#include <conio.h>
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <math.h>
#include <io.h>
#include <fcntl.h>
#include <direct.h>
#include <wchar.h>
#include <limits.h>
#include <float.h>
#include <search.h>

#include <ddraw.h>      // needed for defs in T3DLIB1.H 
#include "T3DLIB1.H"
#include "T3DLIB4.H"
#include "T3DLIB5.H"
#include "T3DLIB6.H"
#include "T3DLIB7.H"
#include "T3DLIB8.H"
#include "T3DLIB9.H"
#include "T3DLIB10.H"


// DEFINES //////////////////////////////////////////////////////////////////



// GLOBALS //////////////////////////////////////////////////////////////////

// this table contains each possible RGB value multiplied by some scaler
USHORT rgb_alpha_table[NUM_ALPHA_LEVELS][65536];  

int screen_backbuffer_enable = 1; // used to enable/disable a backbuffer
                                  // with full screen displays, and instead
                                  // use pure memory since its faster than
                                  // reading from a dd backbuffer for alpha 
                                  // blending operations

// FUNCTIONS ////////////////////////////////////////////////////////////////

void Draw_Triangle_2DZB2_16(POLYF4DV2_PTR face,   // ptr to face
                           UCHAR *_dest_buffer,   // pointer to video buffer
                           int mem_pitch,         // bytes per line, 320, 640 etc.
                           UCHAR *_zbuffer,       // pointer to z-buffer
                           int zpitch)            // bytes per line of zbuffer
{
// this function draws a flat shaded polygon with zbuffering

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    z,
    dz,
    xi,yi,              // the current interpolated x,y
	zi,                 // the current interpolated z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
    dzdyl,   
	zl,
	dzdyr,
	zr;

int x0,y0,tz0,    // cached vertices
	x1,y1,tz1,
	x2,y2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

USHORT color;    // polygon color

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);


// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;


// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

tz0 = (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

tz1 = (int)(face->tvlist[v1].z+0.5);
            
x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

tz2 = (int)(face->tvlist[v2].z+0.5);

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// extract constant color
color = face->lit_color[0];

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dzdyl = ((tz2 - tz0) << FIXP16_SHIFT)/dy; 

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dzdyr = ((tz2 - tz1) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		zl = (tz0 << FIXP16_SHIFT);
		zr = (tz1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		zl = (tz0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v,w interpolants
		zi = zl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel assume 5.6.5
    		   screen_ptr[xi] = color;

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,w,z
			zi+=dz;
			} // end for xi

		// interpolate z,x along right and left edge
		xl+=dxdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel 5.6.5
               screen_ptr[xi] = color;

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if


			// interpolate z
			zi+=dz;
			} // end for xi

		// interpolate x,z along right and left edge
		xl+=dxdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;  
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;  
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		zl = (tz0 << FIXP16_SHIFT);

		zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for z interpolants
		zi = zl + FIXP16_ROUND_UP;
	
		// compute z interpolants
		if ((dx = (xend - xstart))>0)
			{
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel assume 5.6.5
               screen_ptr[xi] = color;

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate z
			zi+=dz;
			} // end for xi

		// interpolate z,x along right and left edge
		xl+=dxdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;  

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w,z interpolants
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel assume 5.6.5
    		   screen_ptr[xi] = color;

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate z
			zi+=dz;
			} // end for xi

		// interpolate x,z along right and left edge
		xl+=dxdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			zr+=dzdyr;
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Triangle_2DZB2_16

///////////////////////////////////////////////////////////////////////////////

void Draw_Textured_TriangleZB2_16(POLYF4DV2_PTR face,  // ptr to face
                              UCHAR *_dest_buffer,  // pointer to video buffer
                              int mem_pitch,        // bytes per line, 320, 640 etc.
                              UCHAR *_zbuffer,       // pointer to z-buffer
                              int zpitch)          // bytes per line of zbuffer
{
// this function draws a textured triangle in 16-bit mode

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;                       

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = (int)(face->tvlist[v0].u0);
tv0 = (int)(face->tvlist[v0].v0);
tz0 = (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = (int)(face->tvlist[v1].u0);
tv1 = (int)(face->tvlist[v1].v0);
tz1 = (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = (int)(face->tvlist[v2].u0);
tv2 = (int)(face->tvlist[v2].v0);
tz2 = (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz2 - tz0) << FIXP16_SHIFT)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << FIXP16_SHIFT)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		zr = (tz1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
		
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_TriangleZB2_16

///////////////////////////////////////////////////////////////////////////////

void Draw_Textured_Bilerp_TriangleZB_16(POLYF4DV2_PTR face,  // ptr to face
                              UCHAR *_dest_buffer,  // pointer to video buffer
                              int mem_pitch,        // bytes per line, 320, 640 etc.
                              UCHAR *_zbuffer,       // pointer to z-buffer
                              int zpitch)          // bytes per line of zbuffer
{
// this function draws a textured triangle in 16-bit mode with bilerp 

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;                       

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// compute actual size of texture and store it
int texture_size = face->texture->width-1;

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = (int)(face->tvlist[v0].u0);
tv0 = (int)(face->tvlist[v0].v0);
tz0 = (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = (int)(face->tvlist[v1].u0);
tv1 = (int)(face->tvlist[v1].v0);
tz1 = (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = (int)(face->tvlist[v2].u0);
tv2 = (int)(face->tvlist[v2].v0);
tz2 = (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz2 - tz0) << FIXP16_SHIFT)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << FIXP16_SHIFT)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		zr = (tz1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
		
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
           // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
               // compute integral values of u,v
               int uint = ui >> FIXP16_SHIFT;
               int vint = vi >> FIXP16_SHIFT;

               int uint_pls_1 = uint+1;
               if (uint_pls_1 > texture_size) uint_pls_1 = texture_size;

               int vint_pls_1 = vint+1;
               if (vint_pls_1 > texture_size) vint_pls_1 = texture_size;

 			   int textel00 = textmap[(uint+0)     + ((vint+0) << texture_shift2)];
 			   int textel10 = textmap[(uint_pls_1) + ((vint+0) << texture_shift2)];
 			   int textel01 = textmap[(uint+0)     + ((vint_pls_1) << texture_shift2)];
 			   int textel11 = textmap[(uint_pls_1) + ((vint_pls_1) << texture_shift2)];

               // extract rgb components
               int r_textel00  = ((textel00 >> 11)       ); 
               int g_textel00  = ((textel00 >> 5)  & 0x3f); 
               int b_textel00  =  (textel00        & 0x1f);

               int r_textel10  = ((textel10 >> 11)       ); 
               int g_textel10  = ((textel10 >> 5)  & 0x3f); 
               int b_textel10  =  (textel10        & 0x1f);

               int r_textel01  = ((textel01 >> 11)       ); 
               int g_textel01  = ((textel01 >> 5)  & 0x3f); 
               int b_textel01  =  (textel01        & 0x1f);

               int r_textel11  = ((textel11 >> 11)       ); 
               int g_textel11  = ((textel11 >> 5)  & 0x3f); 
               int b_textel11  =  (textel11        & 0x1f);

               // compute fractional components of u,v in fixed 24.8 point format
               int dtu = (ui & (0xffff)) >> 8;
               int dtv = (vi & (0xffff)) >> 8;
 
               int one_minus_dtu = (1 << 8) - dtu;
               int one_minus_dtv = (1 << 8) - dtv;

               // each interpolant has 3 terms, (du), (dv), textel, however
               // the (du) and (dv) terms repeat during each computation of
               // r_textel, g_textel, and b_textel, so we can compute them once
               int one_minus_dtu_x_one_minus_dtv = (one_minus_dtu) * (one_minus_dtv);
               int dtu_x_one_minus_dtv           = (dtu)           * (one_minus_dtv);
               int dtu_x_dtv                     = (dtu)           * (dtv);
               int one_minus_dtu_x_dtv           = (one_minus_dtu) * (dtv);

               // now we are ready to sample the texture 
               int r_textel = one_minus_dtu_x_one_minus_dtv * r_textel00 + 
                              dtu_x_one_minus_dtv           * r_textel10 +
                              dtu_x_dtv                     * r_textel11 +
                              one_minus_dtu_x_dtv           * r_textel01;

               int g_textel = one_minus_dtu_x_one_minus_dtv * g_textel00 + 
                              dtu_x_one_minus_dtv           * g_textel10 +
                              dtu_x_dtv                     * g_textel11 +
                              one_minus_dtu_x_dtv           * g_textel01;

               int b_textel = one_minus_dtu_x_one_minus_dtv * b_textel00 + 
                              dtu_x_one_minus_dtv           * b_textel10 +
                              dtu_x_dtv                     * b_textel11 +
                              one_minus_dtu_x_dtv           * b_textel01;

               // write textel
               screen_ptr[xi] = ((r_textel >> 16) << 11) + ((g_textel >> 16) << 5) + (b_textel >> 16);

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
           // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
               // compute integral values of u,v
               int uint = ui >> FIXP16_SHIFT;
               int vint = vi >> FIXP16_SHIFT;

               int uint_pls_1 = uint+1;
               if (uint_pls_1 > texture_size) uint_pls_1 = texture_size;

               int vint_pls_1 = vint+1;
               if (vint_pls_1 > texture_size) vint_pls_1 = texture_size;

 			   int textel00 = textmap[(uint+0)     + ((vint+0) << texture_shift2)];
 			   int textel10 = textmap[(uint_pls_1) + ((vint+0) << texture_shift2)];
 			   int textel01 = textmap[(uint+0)     + ((vint_pls_1) << texture_shift2)];
 			   int textel11 = textmap[(uint_pls_1) + ((vint_pls_1) << texture_shift2)];

               // extract rgb components
               int r_textel00  = ((textel00 >> 11)       ); 
               int g_textel00  = ((textel00 >> 5)  & 0x3f); 
               int b_textel00  =  (textel00        & 0x1f);

               int r_textel10  = ((textel10 >> 11)       ); 
               int g_textel10  = ((textel10 >> 5)  & 0x3f); 
               int b_textel10  =  (textel10        & 0x1f);

               int r_textel01  = ((textel01 >> 11)       ); 
               int g_textel01  = ((textel01 >> 5)  & 0x3f); 
               int b_textel01  =  (textel01        & 0x1f);

               int r_textel11  = ((textel11 >> 11)       ); 
               int g_textel11  = ((textel11 >> 5)  & 0x3f); 
               int b_textel11  =  (textel11        & 0x1f);

               // compute fractional components of u,v in fixed 24.8 point format
               int dtu = (ui & (0xffff)) >> 8;
               int dtv = (vi & (0xffff)) >> 8;
 
               int one_minus_dtu = (1 << 8) - dtu;
               int one_minus_dtv = (1 << 8) - dtv;

               // each interpolant has 3 terms, (du), (dv), textel, however
               // the (du) and (dv) terms repeat during each computation of
               // r_textel, g_textel, and b_textel, so we can compute them once
               int one_minus_dtu_x_one_minus_dtv = (one_minus_dtu) * (one_minus_dtv);
               int dtu_x_one_minus_dtv           = (dtu)           * (one_minus_dtv);
               int dtu_x_dtv                     = (dtu)           * (dtv);
               int one_minus_dtu_x_dtv           = (one_minus_dtu) * (dtv);

               // now we are ready to sample the texture 
               int r_textel = one_minus_dtu_x_one_minus_dtv * r_textel00 + 
                              dtu_x_one_minus_dtv           * r_textel10 +
                              dtu_x_dtv                     * r_textel11 +
                              one_minus_dtu_x_dtv           * r_textel01;

               int g_textel = one_minus_dtu_x_one_minus_dtv * g_textel00 + 
                              dtu_x_one_minus_dtv           * g_textel10 +
                              dtu_x_dtv                     * g_textel11 +
                              one_minus_dtu_x_dtv           * g_textel01;

               int b_textel = one_minus_dtu_x_one_minus_dtv * b_textel00 + 
                              dtu_x_one_minus_dtv           * b_textel10 +
                              dtu_x_dtv                     * b_textel11 +
                              one_minus_dtu_x_dtv           * b_textel01;

               // write textel
               screen_ptr[xi] = ((r_textel >> 16) << 11) + ((g_textel >> 16) << 5) + (b_textel >> 16);

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
               // compute integral values of u,v
               int uint = ui >> FIXP16_SHIFT;
               int vint = vi >> FIXP16_SHIFT;

               int uint_pls_1 = uint+1;
               if (uint_pls_1 > texture_size) uint_pls_1 = texture_size;

               int vint_pls_1 = vint+1;
               if (vint_pls_1 > texture_size) vint_pls_1 = texture_size;

 			   int textel00 = textmap[(uint+0)     + ((vint+0) << texture_shift2)];
 			   int textel10 = textmap[(uint_pls_1) + ((vint+0) << texture_shift2)];
 			   int textel01 = textmap[(uint+0)     + ((vint_pls_1) << texture_shift2)];
 			   int textel11 = textmap[(uint_pls_1) + ((vint_pls_1) << texture_shift2)];

               // extract rgb components
               int r_textel00  = ((textel00 >> 11)       ); 
               int g_textel00  = ((textel00 >> 5)  & 0x3f); 
               int b_textel00  =  (textel00        & 0x1f);

               int r_textel10  = ((textel10 >> 11)       ); 
               int g_textel10  = ((textel10 >> 5)  & 0x3f); 
               int b_textel10  =  (textel10        & 0x1f);

               int r_textel01  = ((textel01 >> 11)       ); 
               int g_textel01  = ((textel01 >> 5)  & 0x3f); 
               int b_textel01  =  (textel01        & 0x1f);

               int r_textel11  = ((textel11 >> 11)       ); 
               int g_textel11  = ((textel11 >> 5)  & 0x3f); 
               int b_textel11  =  (textel11        & 0x1f);

               // compute fractional components of u,v in fixed 24.8 point format
               int dtu = (ui & (0xffff)) >> 8;
               int dtv = (vi & (0xffff)) >> 8;
 
               int one_minus_dtu = (1 << 8) - dtu;
               int one_minus_dtv = (1 << 8) - dtv;

               // each interpolant has 3 terms, (du), (dv), textel, however
               // the (du) and (dv) terms repeat during each computation of
               // r_textel, g_textel, and b_textel, so we can compute them once
               int one_minus_dtu_x_one_minus_dtv = (one_minus_dtu) * (one_minus_dtv);
               int dtu_x_one_minus_dtv           = (dtu)           * (one_minus_dtv);
               int dtu_x_dtv                     = (dtu)           * (dtv);
               int one_minus_dtu_x_dtv           = (one_minus_dtu) * (dtv);

               // now we are ready to sample the texture 
               int r_textel = one_minus_dtu_x_one_minus_dtv * r_textel00 + 
                              dtu_x_one_minus_dtv           * r_textel10 +
                              dtu_x_dtv                     * r_textel11 +
                              one_minus_dtu_x_dtv           * r_textel01;

               int g_textel = one_minus_dtu_x_one_minus_dtv * g_textel00 + 
                              dtu_x_one_minus_dtv           * g_textel10 +
                              dtu_x_dtv                     * g_textel11 +
                              one_minus_dtu_x_dtv           * g_textel01;

               int b_textel = one_minus_dtu_x_one_minus_dtv * b_textel00 + 
                              dtu_x_one_minus_dtv           * b_textel10 +
                              dtu_x_dtv                     * b_textel11 +
                              one_minus_dtu_x_dtv           * b_textel01;

               // write textel
               screen_ptr[xi] = ((r_textel >> 16) << 11) + ((g_textel >> 16) << 5) + (b_textel >> 16);

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
               // compute integral values of u,v
               int uint = ui >> FIXP16_SHIFT;
               int vint = vi >> FIXP16_SHIFT;

               int uint_pls_1 = uint+1;
               if (uint_pls_1 > texture_size) uint_pls_1 = texture_size;

               int vint_pls_1 = vint+1;
               if (vint_pls_1 > texture_size) vint_pls_1 = texture_size;

 			   int textel00 = textmap[(uint+0)     + ((vint+0) << texture_shift2)];
 			   int textel10 = textmap[(uint_pls_1) + ((vint+0) << texture_shift2)];
 			   int textel01 = textmap[(uint+0)     + ((vint_pls_1) << texture_shift2)];
 			   int textel11 = textmap[(uint_pls_1) + ((vint_pls_1) << texture_shift2)];

               // extract rgb components
               int r_textel00  = ((textel00 >> 11)       ); 
               int g_textel00  = ((textel00 >> 5)  & 0x3f); 
               int b_textel00  =  (textel00        & 0x1f);

               int r_textel10  = ((textel10 >> 11)       ); 
               int g_textel10  = ((textel10 >> 5)  & 0x3f); 
               int b_textel10  =  (textel10        & 0x1f);

               int r_textel01  = ((textel01 >> 11)       ); 
               int g_textel01  = ((textel01 >> 5)  & 0x3f); 
               int b_textel01  =  (textel01        & 0x1f);

               int r_textel11  = ((textel11 >> 11)       ); 
               int g_textel11  = ((textel11 >> 5)  & 0x3f); 
               int b_textel11  =  (textel11        & 0x1f);

               // compute fractional components of u,v in fixed 24.8 point format
               int dtu = (ui & (0xffff)) >> 8;
               int dtv = (vi & (0xffff)) >> 8;
 
               int one_minus_dtu = (1 << 8) - dtu;
               int one_minus_dtv = (1 << 8) - dtv;

               // each interpolant has 3 terms, (du), (dv), textel, however
               // the (du) and (dv) terms repeat during each computation of
               // r_textel, g_textel, and b_textel, so we can compute them once
               int one_minus_dtu_x_one_minus_dtv = (one_minus_dtu) * (one_minus_dtv);
               int dtu_x_one_minus_dtv           = (dtu)           * (one_minus_dtv);
               int dtu_x_dtv                     = (dtu)           * (dtv);
               int one_minus_dtu_x_dtv           = (one_minus_dtu) * (dtv);

               // now we are ready to sample the texture 
               int r_textel = one_minus_dtu_x_one_minus_dtv * r_textel00 + 
                              dtu_x_one_minus_dtv           * r_textel10 +
                              dtu_x_dtv                     * r_textel11 +
                              one_minus_dtu_x_dtv           * r_textel01;

               int g_textel = one_minus_dtu_x_one_minus_dtv * g_textel00 + 
                              dtu_x_one_minus_dtv           * g_textel10 +
                              dtu_x_dtv                     * g_textel11 +
                              one_minus_dtu_x_dtv           * g_textel01;

               int b_textel = one_minus_dtu_x_one_minus_dtv * b_textel00 + 
                              dtu_x_one_minus_dtv           * b_textel10 +
                              dtu_x_dtv                     * b_textel11 +
                              one_minus_dtu_x_dtv           * b_textel01;

               // write textel
               screen_ptr[xi] = ((r_textel >> 16) << 11) + ((g_textel >> 16) << 5) + (b_textel >> 16);

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_Bilerp_TriangleZB_16

///////////////////////////////////////////////////////////////////////////////

void Draw_Textured_TriangleFSZB2_16(POLYF4DV2_PTR face, // ptr to face
                                 UCHAR *_dest_buffer,  // pointer to video buffer
                                 int mem_pitch,        // bytes per line, 320, 640 etc.
                                 UCHAR *_zbuffer,       // pointer to z-buffer
                                 int zpitch)          // bytes per line of zbuffer
{
// this function draws a textured triangle in 16-bit mode with flat shading

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,            // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dzdyl,    
	zl,
	dvdyl,   
	vl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

USHORT r_base, g_base, b_base,
       r_textel, g_textel, b_textel, textel;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;


#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;


// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP( face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract base color of lit poly, so we can modulate texture a bit
// for lighting
_RGB565FROM16BIT(face->lit_color[0], &r_base, &g_base, &b_base);

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = (int)(face->tvlist[v0].u0);
tv0 = (int)(face->tvlist[v0].v0);
tz0 = (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = (int)(face->tvlist[v1].u0);
tv1 = (int)(face->tvlist[v1].v0);
tz1 = (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = (int)(face->tvlist[v2].u0);
tv2 = (int)(face->tvlist[v2].v0);
tz2 = (int)(face->tvlist[v2].z+0.5);

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz2 - tz0) << FIXP16_SHIFT)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		zr = (tz1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
		
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
            dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,z
			ui+=du;
			vi+=dv;
            zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	    zl+=dzdyl;

		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
        zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
        dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
        dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;   		

		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
        zl = dzdyl*dyl + (tz1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
        zr = dzdyr*dyr + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
        dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
        dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
        zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
        zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
        dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
        dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;   		

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
        zl = (tz0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
        zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else


    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
        zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
            dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
            dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v
			ui+=du;
			vi+=dv;
            zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
     		// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;  

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else


			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,z interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)

			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
            dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
            dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,z
			ui+=du;
			vi+=dv;
            zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
        zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
        zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl; 

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_TriangleFSZB2_16

//////////////////////////////////////////////////////////////////////////////

void Draw_Textured_TriangleGSZB_16(POLYF4DV2_PTR face,   // ptr to face
                                 UCHAR *_dest_buffer, // pointer to video buffer
                                 int mem_pitch,       // bytes per line, 320, 640 etc.
                                 UCHAR *_zbuffer,       // pointer to z-buffer
                                 int zpitch)          // bytes per line of zbuffer

{
// this function draws a textured gouraud shaded polygon, and z bufferedbased on the affine texture mapper, 
// we simply interpolate the (R,G,B) values across the polygons along with the texture coordinates
// and then modulate to get the final color 

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;


int dx,dy,dyl,dyr,      // general deltas
    u,v,w,z, s,t,
    du,dv,dw,dz, ds, dt, 
    xi,yi,             // the current interpolated x,y
	ui,vi,wi,zi, si, ti,    // the current interpolated u,v
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dwdyl,   
	wl,
	dzdyl,   
	zl,
	dsdyl,    
	sl,
	dtdyl,   
	tl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dwdyr,
	wr,
	dzdyr,
	zr,
	dsdyr,
	sr,
	dtdyr,
	tr;

int x0,y0,tu0,tv0,tw0, tz0, ts0,tt0,    // cached vertices
	x1,y1,tu1,tv1,tw1, tz1, ts1,tt1,
	x2,y2,tu2,tv2,tw2, tz2, ts2,tt2;

int r_base0, g_base0, b_base0,
    r_base1, g_base1, b_base1,
    r_base2, g_base2, b_base2;


UINT r_textel, g_textel, b_textel;
USHORT textel;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif


// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.0);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.0);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.0);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.0);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.0);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.0);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// assume 5.6.5 format -- sorry!
// we can't afford a function call in the inner loops, so we must write 
// two hard coded versions, if we want support for both 5.6.5, and 5.5.5
_RGB565FROM16BIT(face->lit_color[v0], &r_base0, &g_base0, &b_base0);
_RGB565FROM16BIT(face->lit_color[v1], &r_base1, &g_base1, &b_base1);
_RGB565FROM16BIT(face->lit_color[v2], &r_base2, &g_base2, &b_base2);

// scale to 8 bit 
r_base0 <<= 3;
g_base0 <<= 2;
b_base0 <<= 3;

// scale to 8 bit 
r_base1 <<= 3;
g_base1 <<= 2;
b_base1 <<= 3;

// scale to 8 bit 
r_base2 <<= 3;
g_base2 <<= 2;
b_base2 <<= 3;

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

tz0 = (int)(face->tvlist[v0].z+0.5);
ts0 = (int)(face->tvlist[v0].u0);
tt0 = (int)(face->tvlist[v0].v0);

tu0 = r_base0;
tv0 = g_base0; 
tw0 = b_base0; 

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

tz1 = (int)(face->tvlist[v1].z+0.5);
ts1 = (int)(face->tvlist[v1].u0);
tt1 = (int)(face->tvlist[v1].v0);

tu1 = r_base1;
tv1 = g_base1; 
tw1 = b_base1; 

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

tz2 = (int)(face->tvlist[v2].z+0.5);
ts2 = (int)(face->tvlist[v2].u0);
tt2 = (int)(face->tvlist[v2].v0);

tu2 = r_base2; 
tv2 = g_base2; 
tw2 = b_base2; 

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw2 - tw0) << FIXP16_SHIFT)/dy;  
	dzdyl = ((tz2 - tz0) << FIXP16_SHIFT)/dy; 
	
    dsdyl = ((ts2 - ts0) << FIXP16_SHIFT)/dy;    
	dtdyl = ((tt2 - tt0) << FIXP16_SHIFT)/dy;  

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << FIXP16_SHIFT)/dy;   

	dsdyr = ((ts2 - ts1) << FIXP16_SHIFT)/dy;   
	dtdyr = ((tt2 - tt1) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << FIXP16_SHIFT);

		sr = dsdyr*dy + (ts1 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);


		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		wr = (tw1 << FIXP16_SHIFT);
		zr = (tz1 << FIXP16_SHIFT);

		sr = (ts1 << FIXP16_SHIFT);
		tr = (tt1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dy; 
	dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dy; 

	dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dy;    
	dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dy;   

	dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dy;   
	dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dy;   


	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		sr = dsdyr*dy + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt0 << FIXP16_SHIFT);


		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);


		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		sr = (ts0 << FIXP16_SHIFT);
		tr = (tt0 << FIXP16_SHIFT);


		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
		
        si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			zi+=dx*dz;
			
			si+=dx*ds;
			ti+=dx*dt;

			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
            { 
		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = ((b_textel >> (FIXP16_SHIFT+8)) + 
                             ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                             ((r_textel >> (FIXP16_SHIFT+8)) << 11));

            // update z-buffer
            z_ptr[xi] = zi;   

            } // end if 

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		sl+=dsdyl;
		tl+=dtdyl;

		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;
 
		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
            { 
		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = ((b_textel >> (FIXP16_SHIFT+8)) + 
                             ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                             ((r_textel >> (FIXP16_SHIFT+8)) << 11));

            // update z-buffer
            z_ptr[xi] = zi;   

            } // end if 

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;

		sl+=dsdyl;
		tl+=dtdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  
		dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;  

		dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;   
		
		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;  

		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);

		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		wl = dwdyl*dyl + (tw1 << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << FIXP16_SHIFT);

		sl = dsdyl*dyl + (ts1 << FIXP16_SHIFT);
		tl = dtdyl*dyl + (tt1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);

		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dyr + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << FIXP16_SHIFT);

		sr = dsdyr*dyr + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dyr + (tt0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
		
			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);

         	SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);

			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);

			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl; 
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl; 

		dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;   
		
		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;   

		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		sr = dsdyr*dy + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);

			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);

			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);

			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);

			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl;   
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl;  

		dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;

		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   		
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		sr = (ts0 << FIXP16_SHIFT);
		tr = (tt0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);

			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);


			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);


			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);

			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			zi+=dx*dz;
			
			si+=dx*ds;
			ti+=dx*dt;

			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
            { 
		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = ((b_textel >> (FIXP16_SHIFT+8)) + 
                             ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                             ((r_textel >> (FIXP16_SHIFT+8)) << 11));

            // update z-buffer
            z_ptr[xi] = zi;   

            } // end if 

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
        ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		sl+=dsdyl;
		tl+=dtdyl;

		xr+=dxdyr;
     	ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;  

			dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;   		
			dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;  


			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			sl = (ts1 << FIXP16_SHIFT);
			tl = (tt1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			zl+=dzdyl;

			sl+=dsdyl;
			tl+=dtdyl;

			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;   

			dsdyr = ((ts1 - ts2) << FIXP16_SHIFT)/dyr;   		
			dtdyr = ((tt1 - tt2) << FIXP16_SHIFT)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			sr = (ts2 << FIXP16_SHIFT);
			tr = (tt2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			zr+=dzdyr;
		
			sr+=dsdyr;
			tr+=dtdyr;
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
            { 
		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = ((b_textel >> (FIXP16_SHIFT+8)) + 
                             ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                             ((r_textel >> (FIXP16_SHIFT+8)) << 11));

            // update z-buffer
            z_ptr[xi] = zi;   

            } // end if 

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;

			si+=ds;
			ti+=dt;
			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;

		sl+=dsdyl;
		tl+=dtdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;   
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;  

			dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;   		
			dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			sl = (ts1 << FIXP16_SHIFT);
			tl = (tt1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			zl+=dzdyl;

			sl+=dsdyl;
			tl+=dtdyl;

			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;   

			dsdyr = ((ts1 - ts2) << FIXP16_SHIFT)/dyr;   		
			dtdyr = ((tt1 - tt2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			sr = (ts2 << FIXP16_SHIFT);
			tr = (tt2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			zr+=dzdyr;

			sr+=dsdyr;
			tr+=dtdyr;

			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_TriangleGSZB_16

///////////////////////////////////////////////////////////////////////////////

void Draw_Gouraud_TriangleZB2_16(POLYF4DV2_PTR face,   // ptr to face
                              UCHAR *_dest_buffer,   // pointer to video buffer
                              int mem_pitch,         // bytes per line, 320, 640 etc.
                              UCHAR *_zbuffer,       // pointer to z-buffer
                              int zpitch)            // bytes per line of zbuffer
{
// this function draws a gouraud shaded polygon, based on the affine texture mapper, instead
// of interpolating the texture coordinates, we simply interpolate the (R,G,B) values across
// the polygons, I simply needed at another interpolant, I have mapped u->red, v->green, w->blue
// also a new interpolant for z buffering has been added

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,w,z,
    du,dv,dw,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,wi,zi,        // the current interpolated u,v,w,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
    dudyl,    
	ul,
	dvdyl,   
	vl,
	dwdyl,   
	wl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dwdyr,
	wr,
	dzdyr,
	zr;

int x0,y0,tu0,tv0,tw0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tw1,tz1,
	x2,y2,tu2,tv2,tw2,tz2;

int r_base0, g_base0, b_base0,
    r_base1, g_base1, b_base1,
    r_base2, g_base2, b_base2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;


// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// assume 5.6.5 format -- sorry!
// we can't afford a function call in the inner loops, so we must write 
// two hard coded versions, if we want support for both 5.6.5, and 5.5.5
_RGB565FROM16BIT(face->lit_color[v0], &r_base0, &g_base0, &b_base0);
_RGB565FROM16BIT(face->lit_color[v1], &r_base1, &g_base1, &b_base1);
_RGB565FROM16BIT(face->lit_color[v2], &r_base2, &g_base2, &b_base2);

// scale to 8 bit 
r_base0 <<= 3;
g_base0 <<= 2;
b_base0 <<= 3;

// scale to 8 bit 
r_base1 <<= 3;
g_base1 <<= 2;
b_base1 <<= 3;

// scale to 8 bit 
r_base2 <<= 3;
g_base2 <<= 2;
b_base2 <<= 3;

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

tz0 = (int)(face->tvlist[v0].z+0.5);
tu0 = r_base0;
tv0 = g_base0; 
tw0 = b_base0; 

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

tz1 = (int)(face->tvlist[v1].z+0.5);
tu1 = r_base1;
tv1 = g_base1; 
tw1 = b_base1; 

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

tz2 = (int)(face->tvlist[v2].z+0.5);
tu2 = r_base2; 
tv2 = g_base2; 
tw2 = b_base2; 

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw2 - tw0) << FIXP16_SHIFT)/dy;  
	dzdyl = ((tz2 - tz0) << FIXP16_SHIFT)/dy; 

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		wr = (tw1 << FIXP16_SHIFT);
		zr = (tz1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dy; 
	dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel assume 5.6.5
    		   screen_ptr[xi] = ((ui >> (FIXP16_SHIFT+3)) << 11) + 
                                ((vi >> (FIXP16_SHIFT+2)) << 5) + 
                                 (wi >> (FIXP16_SHIFT+3));   

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,w,z
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;
			} // end for xi

		// interpolate u,v,w,z,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel 5.6.5
               screen_ptr[xi] = ((ui >> (FIXP16_SHIFT+3)) << 11) + 
                                ((vi >> (FIXP16_SHIFT+2)) << 5) + 
                                 (wi >> (FIXP16_SHIFT+3));   

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if


			// interpolate u,v,w,z
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;
			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  
		dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;  
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);

		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		wl = dwdyl*dyl + (tw1 << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);

		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dyr + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl; 
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;  
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl;   
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel assume 5.6.5
               screen_ptr[xi] = ((ui >> (FIXP16_SHIFT+3)) << 11) + 
                                ((vi >> (FIXP16_SHIFT+2)) << 5) + 
                                 (wi >> (FIXP16_SHIFT+3));   

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,w,z
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;
			} // end for xi

		// interpolate u,v,w,z,x along right and left edge
		xl+=dxdyl;
        ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
     	ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;  

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w,z interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel assume 5.6.5
    		   screen_ptr[xi] = ((ui >> (FIXP16_SHIFT+3)) << 11) + 
                                ((vi >> (FIXP16_SHIFT+2)) << 5) + 
                                 (wi >> (FIXP16_SHIFT+3));   

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,w,z
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;
			} // end for xi

		// interpolate u,v,w,x,z along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;   
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			zr+=dzdyr;
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Gouraud_TriangleZB2_16

///////////////////////////////////////////////////////////////////////////////

void Draw_RENDERLIST4DV2_SolidZB2_16(RENDERLIST4DV2_PTR rend_list, 
                                   UCHAR *video_buffer, 
	   						       int lpitch,
                                   UCHAR *zbuffer,
                                   int zpitch)
{
// 16-bit version
// this function "executes" the render list or in other words
// draws all the faces in the list, the function will call the 
// proper rasterizer based on the lighting model of the polygons


POLYF4DV2 face; // temp face used to render polygon

// at this point, all we have is a list of polygons and it's time
// to draw them
for (int poly=0; poly < rend_list->num_polys; poly++)
    {
    // render this polygon if and only if it's not clipped, not culled,
    // active, and visible, note however the concecpt of "backface" is 
    // irrelevant in a wire frame engine though
    if (!(rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_ACTIVE) ||
         (rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_CLIPPED ) ||
         (rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_BACKFACE) )
       continue; // move onto next poly

    // need to test for textured first, since a textured poly can either
    // be emissive, or flat shaded, hence we need to call different
    // rasterizers    
    if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_TEXTURE)
       {

       // set the vertices
       face.tvlist[0].x = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;
       face.tvlist[0].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[0].u0;
       face.tvlist[0].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[0].v0;

       face.tvlist[1].x = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;
       face.tvlist[1].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[1].u0;
       face.tvlist[1].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[1].v0;

       face.tvlist[2].x = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;
       face.tvlist[2].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[2].u0;
       face.tvlist[2].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[2].v0;
    

       // assign the texture
       face.texture = rend_list->poly_ptrs[poly]->texture;
       
       // is this a plain emissive texture?
       if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT)
          {
          // draw the textured triangle as emissive
          Draw_Textured_TriangleZB2_16(&face, video_buffer, lpitch,zbuffer,zpitch);
          } // end if
       else
       if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT)
          {
          // draw as flat shaded
          face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];
          Draw_Textured_TriangleFSZB2_16(&face, video_buffer, lpitch,zbuffer,zpitch);
          } // end else if
       else
          {
          // must be gouraud POLY4DV2_ATTR_SHADE_MODE_GOURAUD
          face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];
          face.lit_color[1] = rend_list->poly_ptrs[poly]->lit_color[1];
          face.lit_color[2] = rend_list->poly_ptrs[poly]->lit_color[2];

          Draw_Textured_TriangleGSZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);
          } // end else

       } // end if      
    else
    if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT) || 
        (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT) )
       {
       // draw as constant shaded
       face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];
       
       // set the vertices
       face.tvlist[0].x = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;

       face.tvlist[1].x = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;

       face.tvlist[2].x = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;

       // draw the triangle with basic flat rasterizer
       Draw_Triangle_2DZB2_16(&face, video_buffer, lpitch,zbuffer,zpitch);

       } // end if
    else
    if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_GOURAUD)
       {
        // {andre take advantage of the data structures later..}
        // set the vertices
        face.tvlist[0].x  = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
        face.tvlist[0].y  = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
        face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;
        face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];

        face.tvlist[1].x  = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
        face.tvlist[1].y  = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
        face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;
        face.lit_color[1] = rend_list->poly_ptrs[poly]->lit_color[1];

        face.tvlist[2].x  = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
        face.tvlist[2].y  = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
        face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;
        face.lit_color[2] = rend_list->poly_ptrs[poly]->lit_color[2];

	    // draw the gouraud shaded triangle
        Draw_Gouraud_TriangleZB2_16(&face, video_buffer, lpitch,zbuffer,zpitch);
       } // end if gouraud

    } // end for poly

} // end Draw_RENDERLIST4DV2_SolidZB2_16

////////////////////////////////////////////////////////////////////////////////////////////////
// NON-ZBUFFERED ///////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

void Draw_RENDERLIST4DV2_Solid2_16(RENDERLIST4DV2_PTR rend_list, 
                                   UCHAR *video_buffer, 
	   						       int lpitch)
{
// 16-bit version
// this function "executes" the render list or in other words
// draws all the faces in the list, the function will call the 
// proper rasterizer based on the lighting model of the polygons

POLYF4DV2 face; // temp face used to render polygon

// at this point, all we have is a list of polygons and it's time
// to draw them
for (int poly=0; poly < rend_list->num_polys; poly++)
    {
    // render this polygon if and only if it's not clipped, not culled,
    // active, and visible, note however the concecpt of "backface" is 
    // irrelevant in a wire frame engine though
    if (!(rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_ACTIVE) ||
         (rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_CLIPPED ) ||
         (rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_BACKFACE) )
       continue; // move onto next poly

    // need to test for textured first, since a textured poly can either
    // be emissive, or flat shaded, hence we need to call different
    // rasterizers    
    if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_TEXTURE)
       {

       // set the vertices
       face.tvlist[0].x = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;
       face.tvlist[0].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[0].u0;
       face.tvlist[0].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[0].v0;

       face.tvlist[1].x = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;
       face.tvlist[1].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[1].u0;
       face.tvlist[1].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[1].v0;

       face.tvlist[2].x = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;
       face.tvlist[2].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[2].u0;
       face.tvlist[2].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[2].v0;
    

       // assign the texture
       face.texture = rend_list->poly_ptrs[poly]->texture;
       
       // is this a plain emissive texture?
       if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT)
          {
          // draw the textured triangle as emissive
          Draw_Textured_Triangle2_16(&face, video_buffer, lpitch);
          //Draw_Textured_Perspective_Triangle_16(&face, video_buffer, lpitch);
          } // end if
       else
       if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT)
          {
          // draw as flat shaded
          face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];
          Draw_Textured_TriangleFS2_16(&face, video_buffer, lpitch);
          //Draw_Textured_Perspective_Triangle_FS_16(&face, video_buffer, lpitch);
          } // end else
       else
          {
          // must be gouraud POLY4DV2_ATTR_SHADE_MODE_GOURAUD
          face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];
          face.lit_color[1] = rend_list->poly_ptrs[poly]->lit_color[1];
          face.lit_color[2] = rend_list->poly_ptrs[poly]->lit_color[2];
          Draw_Textured_TriangleGS_16(&face, video_buffer, lpitch);
          } // end else

       } // end if      
    else
    if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT) || 
        (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT) )
       {
       // draw as constant shaded
       face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];
       
       // set the vertices
       face.tvlist[0].x = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;

       face.tvlist[1].x = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;

       face.tvlist[2].x = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;

       // draw the triangle with basic flat rasterizer
       Draw_Triangle_2D3_16(&face, video_buffer, lpitch);

       } // end if
    else
    if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_GOURAUD)
       {
        // {andre take advantage of the data structures later..}
        // set the vertices
        face.tvlist[0].x  = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
        face.tvlist[0].y  = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
        face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;
        face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];

        face.tvlist[1].x  = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
        face.tvlist[1].y  = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
        face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;
        face.lit_color[1] = rend_list->poly_ptrs[poly]->lit_color[1];

        face.tvlist[2].x  = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
        face.tvlist[2].y  = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
        face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;
        face.lit_color[2] = rend_list->poly_ptrs[poly]->lit_color[2];

	    // draw the gouraud shaded triangle
        Draw_Gouraud_Triangle2_16(&face, video_buffer, lpitch);

       } // end if gouraud

    } // end for poly

} // end Draw_RENDERLIST4DV2_Solid2_16

/////////////////////////////////////////////////////////////////////////////

void Draw_Triangle_2D3_16(POLYF4DV2_PTR face,   // ptr to face
                          UCHAR *_dest_buffer, // pointer to video buffer
                          int mem_pitch)       // bytes per line, 320, 640 etc.
{
// this function draws a flat shaded polygon with zbuffering

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    xi,yi,              // the current interpolated x,y
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr;

int x0,y0,    // cached vertices
	x1,y1,
	x2,y2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

USHORT color;    // polygon color

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);


// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;


// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// extract constant color
color = face->lit_color[0];

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        dx = (xend - xstart);

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
   	        // write textel assume 5.6.5
    	    screen_ptr[xi] = color;
			} // end for xi

		// interpolate x along right and left edge
		xl+=dxdyl;
		xr+=dxdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
        dx = (xend - xstart);

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
      	    // write textel 5.6.5
            screen_ptr[xi] = color;
			} // end for xi

		// interpolate x,z along right and left edge
		xl+=dxdyl;
		xr+=dxdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
        dx = (xend - xstart);

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
 			{
		   // write textel assume 5.6.5
            screen_ptr[xi] = color;

			} // end for xi

		// interpolate z,x along right and left edge
		xl+=dxdyl;
		xr+=dxdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;

			// set starting values
			xl = (x1  << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;

			// set starting values
			xr = (x2  << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
        dx = (xend - xstart);

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // write textel assume 5.6.5
     	    screen_ptr[xi] = color;
			} // end for xi

		// interpolate x,z along right and left edge
		xl+=dxdyl;
		xr+=dxdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;

			// set starting values
			xl = (x1  << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;

			// set starting values
			xr = (x2  << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Triangle_2D3_16

///////////////////////////////////////////////////////////////////////////////////

void Draw_Textured_Triangle2_16(POLYF4DV2_PTR face,   // ptr to face
                                UCHAR *_dest_buffer,   // pointer to video buffer
                                int mem_pitch)        // bytes per line, 320, 640 etc.
{
// this function draws a textured triangle in 16-bit mode

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,
    du,dv,
    xi,yi,              // the current interpolated x,y
	ui,vi,              // the current interpolated u,v
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dudyr,
	ur,
	dvdyr,
	vr;

int x0,y0,tu0,tv0,    // cached vertices
	x1,y1,tu1,tv1,
	x2,y2,tu2,tv2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = (int)(face->tvlist[v0].u0);
tv0 = (int)(face->tvlist[v0].v0);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = (int)(face->tvlist[v1].u0);
tv1 = (int)(face->tvlist[v1].v0);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = (int)(face->tvlist[v2].u0);
tv2 = (int)(face->tvlist[v2].v0);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel
            screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel
            screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) +  ((vi >> FIXP16_SHIFT) << texture_shift2)];
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else


    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel
            screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{

		// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
		
			} // end else


			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)

			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel
            screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_Triangle2_16

///////////////////////////////////////////////////////////////////////////////

void Draw_Textured_Bilerp_Triangle_16(POLYF4DV2_PTR face,   // ptr to face
                                      UCHAR *_dest_buffer,   // pointer to video buffer
                                      int mem_pitch)        // bytes per line, 320, 640 etc.
{
// this function draws a textured triangle in 16-bit mode

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,
    du,dv,
    xi,yi,              // the current interpolated x,y
	ui,vi,              // the current interpolated u,v
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dudyr,
	ur,
	dvdyr,
	vr;

int x0,y0,tu0,tv0,    // cached vertices
	x1,y1,tu1,tv1,
	x2,y2,tu2,tv2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// compute actual size of texture and store it
int texture_size = face->texture->width-1;

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = (int)(face->tvlist[v0].u0);
tv0 = (int)(face->tvlist[v0].v0);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = (int)(face->tvlist[v1].u0);
tv1 = (int)(face->tvlist[v1].v0);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = (int)(face->tvlist[v2].u0);
tv2 = (int)(face->tvlist[v2].v0);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
               // compute integral values of u,v
               int uint = ui >> FIXP16_SHIFT;
               int vint = vi >> FIXP16_SHIFT;

               int uint_pls_1 = uint+1;
               if (uint_pls_1 > texture_size) uint_pls_1 = texture_size;

               int vint_pls_1 = vint+1;
               if (vint_pls_1 > texture_size) vint_pls_1 = texture_size;

 			   int textel00 = textmap[(uint+0)     + ((vint+0) << texture_shift2)];
 			   int textel10 = textmap[(uint_pls_1) + ((vint+0) << texture_shift2)];
 			   int textel01 = textmap[(uint+0)     + ((vint_pls_1) << texture_shift2)];
 			   int textel11 = textmap[(uint_pls_1) + ((vint_pls_1) << texture_shift2)];

               // extract rgb components
               int r_textel00  = ((textel00 >> 11)       ); 
               int g_textel00  = ((textel00 >> 5)  & 0x3f); 
               int b_textel00  =  (textel00        & 0x1f);

               int r_textel10  = ((textel10 >> 11)       ); 
               int g_textel10  = ((textel10 >> 5)  & 0x3f); 
               int b_textel10  =  (textel10        & 0x1f);

               int r_textel01  = ((textel01 >> 11)       ); 
               int g_textel01  = ((textel01 >> 5)  & 0x3f); 
               int b_textel01  =  (textel01        & 0x1f);

               int r_textel11  = ((textel11 >> 11)       ); 
               int g_textel11  = ((textel11 >> 5)  & 0x3f); 
               int b_textel11  =  (textel11        & 0x1f);

               // compute fractional components of u,v in fixed 24.8 point format
               int dtu = (ui & (0xffff)) >> 8;
               int dtv = (vi & (0xffff)) >> 8;
 
               int one_minus_dtu = (1 << 8) - dtu;
               int one_minus_dtv = (1 << 8) - dtv;

               // each interpolant has 3 terms, (du), (dv), textel, however
               // the (du) and (dv) terms repeat during each computation of
               // r_textel, g_textel, and b_textel, so we can compute them once
               int one_minus_dtu_x_one_minus_dtv = (one_minus_dtu) * (one_minus_dtv);
               int dtu_x_one_minus_dtv           = (dtu)           * (one_minus_dtv);
               int dtu_x_dtv                     = (dtu)           * (dtv);
               int one_minus_dtu_x_dtv           = (one_minus_dtu) * (dtv);

               // now we are ready to sample the texture 
               int r_textel = one_minus_dtu_x_one_minus_dtv * r_textel00 + 
                              dtu_x_one_minus_dtv           * r_textel10 +
                              dtu_x_dtv                     * r_textel11 +
                              one_minus_dtu_x_dtv           * r_textel01;

               int g_textel = one_minus_dtu_x_one_minus_dtv * g_textel00 + 
                              dtu_x_one_minus_dtv           * g_textel10 +
                              dtu_x_dtv                     * g_textel11 +
                              one_minus_dtu_x_dtv           * g_textel01;

               int b_textel = one_minus_dtu_x_one_minus_dtv * b_textel00 + 
                              dtu_x_one_minus_dtv           * b_textel10 +
                              dtu_x_dtv                     * b_textel11 +
                              one_minus_dtu_x_dtv           * b_textel01;

               // write textel
               screen_ptr[xi] = ((r_textel >> 16) << 11) + ((g_textel >> 16) << 5) + (b_textel >> 16);
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
               // compute integral values of u,v
               int uint = ui >> FIXP16_SHIFT;
               int vint = vi >> FIXP16_SHIFT;

               int uint_pls_1 = uint+1;
               if (uint_pls_1 > texture_size) uint_pls_1 = texture_size;

               int vint_pls_1 = vint+1;
               if (vint_pls_1 > texture_size) vint_pls_1 = texture_size;

 			   int textel00 = textmap[(uint+0)     + ((vint+0) << texture_shift2)];
 			   int textel10 = textmap[(uint_pls_1) + ((vint+0) << texture_shift2)];
 			   int textel01 = textmap[(uint+0)     + ((vint_pls_1) << texture_shift2)];
 			   int textel11 = textmap[(uint_pls_1) + ((vint_pls_1) << texture_shift2)];

               // extract rgb components
               int r_textel00  = ((textel00 >> 11)       ); 
               int g_textel00  = ((textel00 >> 5)  & 0x3f); 
               int b_textel00  =  (textel00        & 0x1f);

               int r_textel10  = ((textel10 >> 11)       ); 
               int g_textel10  = ((textel10 >> 5)  & 0x3f); 
               int b_textel10  =  (textel10        & 0x1f);

               int r_textel01  = ((textel01 >> 11)       ); 
               int g_textel01  = ((textel01 >> 5)  & 0x3f); 
               int b_textel01  =  (textel01        & 0x1f);

               int r_textel11  = ((textel11 >> 11)       ); 
               int g_textel11  = ((textel11 >> 5)  & 0x3f); 
               int b_textel11  =  (textel11        & 0x1f);

               // compute fractional components of u,v in fixed 24.8 point format
               int dtu = (ui & (0xffff)) >> 8;
               int dtv = (vi & (0xffff)) >> 8;
 
               int one_minus_dtu = (1 << 8) - dtu;
               int one_minus_dtv = (1 << 8) - dtv;

               // each interpolant has 3 terms, (du), (dv), textel, however
               // the (du) and (dv) terms repeat during each computation of
               // r_textel, g_textel, and b_textel, so we can compute them once
               int one_minus_dtu_x_one_minus_dtv = (one_minus_dtu) * (one_minus_dtv);
               int dtu_x_one_minus_dtv           = (dtu)           * (one_minus_dtv);
               int dtu_x_dtv                     = (dtu)           * (dtv);
               int one_minus_dtu_x_dtv           = (one_minus_dtu) * (dtv);

               // now we are ready to sample the texture 
               int r_textel = one_minus_dtu_x_one_minus_dtv * r_textel00 + 
                              dtu_x_one_minus_dtv           * r_textel10 +
                              dtu_x_dtv                     * r_textel11 +
                              one_minus_dtu_x_dtv           * r_textel01;

               int g_textel = one_minus_dtu_x_one_minus_dtv * g_textel00 + 
                              dtu_x_one_minus_dtv           * g_textel10 +
                              dtu_x_dtv                     * g_textel11 +
                              one_minus_dtu_x_dtv           * g_textel01;

               int b_textel = one_minus_dtu_x_one_minus_dtv * b_textel00 + 
                              dtu_x_one_minus_dtv           * b_textel10 +
                              dtu_x_dtv                     * b_textel11 +
                              one_minus_dtu_x_dtv           * b_textel01;

               // write textel
               screen_ptr[xi] = ((r_textel >> 16) << 11) + ((g_textel >> 16) << 5) + (b_textel >> 16);
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else


    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
               // compute integral values of u,v
               int uint = ui >> FIXP16_SHIFT;
               int vint = vi >> FIXP16_SHIFT;

               int uint_pls_1 = uint+1;
               if (uint_pls_1 > texture_size) uint_pls_1 = texture_size;

               int vint_pls_1 = vint+1;
               if (vint_pls_1 > texture_size) vint_pls_1 = texture_size;

 			   int textel00 = textmap[(uint+0)     + ((vint+0) << texture_shift2)];
 			   int textel10 = textmap[(uint_pls_1) + ((vint+0) << texture_shift2)];
 			   int textel01 = textmap[(uint+0)     + ((vint_pls_1) << texture_shift2)];
 			   int textel11 = textmap[(uint_pls_1) + ((vint_pls_1) << texture_shift2)];

               // extract rgb components
               int r_textel00  = ((textel00 >> 11)       ); 
               int g_textel00  = ((textel00 >> 5)  & 0x3f); 
               int b_textel00  =  (textel00        & 0x1f);

               int r_textel10  = ((textel10 >> 11)       ); 
               int g_textel10  = ((textel10 >> 5)  & 0x3f); 
               int b_textel10  =  (textel10        & 0x1f);

               int r_textel01  = ((textel01 >> 11)       ); 
               int g_textel01  = ((textel01 >> 5)  & 0x3f); 
               int b_textel01  =  (textel01        & 0x1f);

               int r_textel11  = ((textel11 >> 11)       ); 
               int g_textel11  = ((textel11 >> 5)  & 0x3f); 
               int b_textel11  =  (textel11        & 0x1f);

               // compute fractional components of u,v in fixed 24.8 point format
               int dtu = (ui & (0xffff)) >> 8;
               int dtv = (vi & (0xffff)) >> 8;
 
               int one_minus_dtu = (1 << 8) - dtu;
               int one_minus_dtv = (1 << 8) - dtv;

               // each interpolant has 3 terms, (du), (dv), textel, however
               // the (du) and (dv) terms repeat during each computation of
               // r_textel, g_textel, and b_textel, so we can compute them once
               int one_minus_dtu_x_one_minus_dtv = (one_minus_dtu) * (one_minus_dtv);
               int dtu_x_one_minus_dtv           = (dtu)           * (one_minus_dtv);
               int dtu_x_dtv                     = (dtu)           * (dtv);
               int one_minus_dtu_x_dtv           = (one_minus_dtu) * (dtv);

               // now we are ready to sample the texture 
               int r_textel = one_minus_dtu_x_one_minus_dtv * r_textel00 + 
                              dtu_x_one_minus_dtv           * r_textel10 +
                              dtu_x_dtv                     * r_textel11 +
                              one_minus_dtu_x_dtv           * r_textel01;

               int g_textel = one_minus_dtu_x_one_minus_dtv * g_textel00 + 
                              dtu_x_one_minus_dtv           * g_textel10 +
                              dtu_x_dtv                     * g_textel11 +
                              one_minus_dtu_x_dtv           * g_textel01;

               int b_textel = one_minus_dtu_x_one_minus_dtv * b_textel00 + 
                              dtu_x_one_minus_dtv           * b_textel10 +
                              dtu_x_dtv                     * b_textel11 +
                              one_minus_dtu_x_dtv           * b_textel01;

               // write textel
               screen_ptr[xi] = ((r_textel >> 16) << 11) + ((g_textel >> 16) << 5) + (b_textel >> 16);
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{

		// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
		
			} // end else


			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)

			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
               // compute integral values of u,v
               int uint = ui >> FIXP16_SHIFT;
               int vint = vi >> FIXP16_SHIFT;

               int uint_pls_1 = uint+1;
               if (uint_pls_1 > texture_size) uint_pls_1 = texture_size;

               int vint_pls_1 = vint+1;
               if (vint_pls_1 > texture_size) vint_pls_1 = texture_size;

 			   int textel00 = textmap[(uint+0)     + ((vint+0) << texture_shift2)];
 			   int textel10 = textmap[(uint_pls_1) + ((vint+0) << texture_shift2)];
 			   int textel01 = textmap[(uint+0)     + ((vint_pls_1) << texture_shift2)];
 			   int textel11 = textmap[(uint_pls_1) + ((vint_pls_1) << texture_shift2)];

               // extract rgb components
               int r_textel00  = ((textel00 >> 11)       ); 
               int g_textel00  = ((textel00 >> 5)  & 0x3f); 
               int b_textel00  =  (textel00        & 0x1f);

               int r_textel10  = ((textel10 >> 11)       ); 
               int g_textel10  = ((textel10 >> 5)  & 0x3f); 
               int b_textel10  =  (textel10        & 0x1f);

               int r_textel01  = ((textel01 >> 11)       ); 
               int g_textel01  = ((textel01 >> 5)  & 0x3f); 
               int b_textel01  =  (textel01        & 0x1f);

               int r_textel11  = ((textel11 >> 11)       ); 
               int g_textel11  = ((textel11 >> 5)  & 0x3f); 
               int b_textel11  =  (textel11        & 0x1f);

               // compute fractional components of u,v in fixed 24.8 point format
               int dtu = (ui & (0xffff)) >> 8;
               int dtv = (vi & (0xffff)) >> 8;
 
               int one_minus_dtu = (1 << 8) - dtu;
               int one_minus_dtv = (1 << 8) - dtv;

               // each interpolant has 3 terms, (du), (dv), textel, however
               // the (du) and (dv) terms repeat during each computation of
               // r_textel, g_textel, and b_textel, so we can compute them once
               int one_minus_dtu_x_one_minus_dtv = (one_minus_dtu) * (one_minus_dtv);
               int dtu_x_one_minus_dtv           = (dtu)           * (one_minus_dtv);
               int dtu_x_dtv                     = (dtu)           * (dtv);
               int one_minus_dtu_x_dtv           = (one_minus_dtu) * (dtv);

               // now we are ready to sample the texture 
               int r_textel = one_minus_dtu_x_one_minus_dtv * r_textel00 + 
                              dtu_x_one_minus_dtv           * r_textel10 +
                              dtu_x_dtv                     * r_textel11 +
                              one_minus_dtu_x_dtv           * r_textel01;

               int g_textel = one_minus_dtu_x_one_minus_dtv * g_textel00 + 
                              dtu_x_one_minus_dtv           * g_textel10 +
                              dtu_x_dtv                     * g_textel11 +
                              one_minus_dtu_x_dtv           * g_textel01;

               int b_textel = one_minus_dtu_x_one_minus_dtv * b_textel00 + 
                              dtu_x_one_minus_dtv           * b_textel10 +
                              dtu_x_dtv                     * b_textel11 +
                              one_minus_dtu_x_dtv           * b_textel01;

               // write textel
               screen_ptr[xi] = ((r_textel >> 16) << 11) + ((g_textel >> 16) << 5) + (b_textel >> 16);
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_Bilerp_Triangle_16

///////////////////////////////////////////////////////////////////////////////


void Draw_Textured_TriangleFS2_16(POLYF4DV2_PTR face,   // ptr to face
                              UCHAR *_dest_buffer,   // pointer to video buffer
                              int mem_pitch)        // bytes per line, 320, 640 etc.
{
// this function draws a textured triangle in 16-bit mode with flat shading

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,
    du,dv,
    xi,yi,              // the current interpolated x,y
	ui,vi,              // the current interpolated u,v
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dudyr,
	ur,
	dvdyr,
	vr;

USHORT r_base, g_base, b_base,
       r_textel, g_textel, b_textel, textel;

int x0,y0,tu0,tv0,    // cached vertices
	x1,y1,tu1,tv1,
	x2,y2,tu2,tv2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract base color of lit poly, so we can modulate texture a bit
// for lighting
_RGB565FROM16BIT(face->lit_color[0], &r_base, &g_base, &b_base);

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = (int)(face->tvlist[v0].u0);
tv0 = (int)(face->tvlist[v0].v0);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = (int)(face->tvlist[v1].u0);
tv1 = (int)(face->tvlist[v1].v0);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = (int)(face->tvlist[v2].u0);
tv2 = (int)(face->tvlist[v2].v0);

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel
		    // get textel first
 			textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with lit background color
            r_textel*=r_base; 
            g_textel*=g_base;
            b_textel*=b_base;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel
		    // get textel first
 			textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with lit background color
            r_textel*=r_base; 
            g_textel*=g_base;
            b_textel*=b_base;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else


    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel
            //screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];
		    // get textel first
 			textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with lit background color
            r_textel*=r_base; 
            g_textel*=g_base;
            b_textel*=b_base;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
     		// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
		
			} // end else


			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)

			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel
		    // get textel first
 			textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with lit background color
            r_textel*=r_base; 
            g_textel*=g_base;
            b_textel*=b_base;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_TriangleFS2_16

///////////////////////////////////////////////////////////////////////////////

void Draw_Textured_Perspective_Triangle_16(POLYF4DV2_PTR face,  // ptr to face
                                                   UCHAR *_dest_buffer, // pointer to video buffer
                                                   int mem_pitch)       // bytes per line, 320, 640 etc.
{
// this function draws a textured triangle in 16-bit mode using a 1/z buffer and piecewise linear
// perspective correct texture mappping, 1/z, u/z, v/z are interpolated down each edge then to draw
// each span U and V are computed for each end point and the space is broken up into 32 pixel
// spans where the correct U,V is computed at each point along the span, but linearly interpolated
// across the span

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;


#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = ((int)(face->tvlist[v0].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tv0 = ((int)(face->tvlist[v0].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = ((int)(face->tvlist[v1].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tv1 = ((int)(face->tvlist[v1].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = ((int)(face->tvlist[v2].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tv2 = ((int)(face->tvlist[v2].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{
	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << 0)/dy;  
	dvdyl = ((tv2 - tv0) << 0)/dy;    
	dzdyl = ((tz2 - tz0) << 0)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << 0)/dy;  
	dvdyr = ((tv2 - tv1) << 0)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << 0);
		vr = dvdyr*dy + (tv1 << 0);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu1 << 0);
		vr = (tv1 << 0);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;
		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << 0)/dy;  
	dvdyl = ((tv1 - tv0) << 0)/dy;    
	dzdyl = ((tz1 - tz0) << 0)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << 0)/dy;  
	dvdyr = ((tv2 - tv0) << 0)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;
		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
 		    // write textel
            screen_ptr[xi] = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);


	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else


		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
 		    // write textel
            screen_ptr[xi] = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;


		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << 0)/dyl;  
		dvdyl = ((tv2 - tv1) << 0)/dyl;    
		dzdyl = ((tz2 - tz1) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << 0);
		vl = dvdyl*dyl + (tv1 << 0);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << 0);
		vr = dvdyr*dyr + (tv0 << 0);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   		
		dzdyr = ((tz2 - tz0) << 0)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);


	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else


		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
 		    // write textel
            screen_ptr[xi] = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;


		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);


	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
 		    // write textel
            screen_ptr[xi] = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;


		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_Perspective_Triangle_16

///////////////////////////////////////////////////////////////////////////////////

void Draw_Textured_PerspectiveLP_Triangle_16(POLYF4DV2_PTR face,  // ptr to face
                                                   UCHAR *_dest_buffer, // pointer to video buffer
                                                   int mem_pitch)       // bytes per line, 320, 640 etc.
{
// this function draws a textured triangle in 16-bit mode using a 1/z buffer and piecewise linear
// perspective correct texture mappping, 1/z, u/z, v/z are interpolated down each edge then to draw
// each span U and V are computed for each end point and the space is broken up into 32 pixel
// spans where the correct U,V is computed at each point along the span, but linearly interpolated
// across the span

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int ur2, ul2, vr2, vl2;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;


#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = ((int)(face->tvlist[v0].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tv0 = ((int)(face->tvlist[v0].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = ((int)(face->tvlist[v1].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tv1 = ((int)(face->tvlist[v1].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = ((int)(face->tvlist[v2].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tv2 = ((int)(face->tvlist[v2].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{
	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << 0)/dy;  
	dvdyl = ((tv2 - tv0) << 0)/dy;    
	dzdyl = ((tz2 - tz0) << 0)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << 0)/dy;  
	dvdyr = ((tv2 - tv1) << 0)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << 0);
		vr = dvdyr*dy + (tv1 << 0);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu1 << 0);
		vr = (tv1 << 0);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;
		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << 0)/dy;  
	dvdyl = ((tv1 - tv0) << 0)/dy;    
	dzdyl = ((tz1 - tz0) << 0)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << 0)/dy;  
	dvdyr = ((tv2 - tv0) << 0)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;
		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;


		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
 		    // write textel
            screen_ptr[xi] = textmap[ (ui >> FIXP22_SHIFT) + ((vi >> FIXP22_SHIFT) << texture_shift2)];
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);


	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else


		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
 		    // write textel
            screen_ptr[xi] = textmap[ (ui >>  FIXP22_SHIFT) + ((vi >> FIXP22_SHIFT) << texture_shift2)];
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;


		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << 0)/dyl;  
		dvdyl = ((tv2 - tv1) << 0)/dyl;    
		dzdyl = ((tz2 - tz1) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << 0);
		vl = dvdyl*dyl + (tv1 << 0);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << 0);
		vr = dvdyr*dyr + (tv0 << 0);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   		
		dzdyr = ((tz2 - tz0) << 0)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);


	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else


		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
 		    // write textel
            screen_ptr[xi] = textmap[ (ui >> FIXP22_SHIFT) + ((vi >> FIXP22_SHIFT) << texture_shift2)];
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;


		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);


	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);


        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
 		    // write textel
            screen_ptr[xi] = textmap[ (ui >> FIXP22_SHIFT) + ((vi >> FIXP22_SHIFT) << texture_shift2)];
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_PerspectiveLP_Triangle_16

///////////////////////////////////////////////////////////////////////////////////


void Draw_Textured_Perspective_Triangle_FS_16(POLYF4DV2_PTR face,  // ptr to face
                                                   UCHAR *_dest_buffer, // pointer to video buffer
                                                   int mem_pitch)       // bytes per line, 320, 640 etc.
{
// this function draws a textured triangle in 16-bit mode using a 1/z buffer and piecewise linear
// perspective correct texture mappping, 1/z, u/z, v/z are interpolated down each edge then to draw
// each span U and V are computed for each end point and the space is broken up into 32 pixel
// spans where the correct U,V is computed at each point along the span, but linearly interpolated
// across the span

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

USHORT r_base, g_base, b_base,
       r_textel, g_textel, b_textel, textel;



#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;


// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract base color of lit poly, so we can modulate texture a bit
// for lighting
_RGB565FROM16BIT(face->lit_color[0], &r_base, &g_base, &b_base);

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = ((int)(face->tvlist[v0].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tv0 = ((int)(face->tvlist[v0].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = ((int)(face->tvlist[v1].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tv1 = ((int)(face->tvlist[v1].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = ((int)(face->tvlist[v2].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tv2 = ((int)(face->tvlist[v2].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{
	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << 0)/dy;  
	dvdyl = ((tv2 - tv0) << 0)/dy;    
	dzdyl = ((tz2 - tz0) << 0)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << 0)/dy;  
	dvdyr = ((tv2 - tv1) << 0)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << 0);
		vr = dvdyr*dy + (tv1 << 0);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu1 << 0);
		vr = (tv1 << 0);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;
		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << 0)/dy;  
	dvdyl = ((tv1 - tv0) << 0)/dy;    
	dzdyl = ((tz1 - tz0) << 0)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << 0)/dy;  
	dvdyr = ((tv2 - tv0) << 0)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;
		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);


	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			   // write textel
		       // get textel first
 			   textel = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

		
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);


	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else


		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			   // write textel
		       // get textel first
 			   textel = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;


		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << 0)/dyl;  
		dvdyl = ((tv2 - tv1) << 0)/dyl;    
		dzdyl = ((tz2 - tz1) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << 0);
		vl = dvdyl*dyl + (tv1 << 0);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << 0);
		vr = dvdyr*dyr + (tv0 << 0);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   		
		dzdyr = ((tz2 - tz0) << 0)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);


	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else


		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			   // write textel
		       // get textel first
 			   textel = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;


		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);


	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			   // write textel
		       // get textel first
 			   textel = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;


		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_Perspective_Triangle_FS_16

///////////////////////////////////////////////////////////////////////////////////

void Draw_Textured_PerspectiveLP_Triangle_FS_16(POLYF4DV2_PTR face,  // ptr to face
                                                   UCHAR *_dest_buffer, // pointer to video buffer
                                                   int mem_pitch)       // bytes per line, 320, 640 etc.
{
// this function draws a textured triangle in 16-bit mode using a 1/z buffer and piecewise linear
// perspective correct texture mappping, 1/z, u/z, v/z are interpolated down each edge then to draw
// each span U and V are computed for each end point and the space is broken up into 32 pixel
// spans where the correct U,V is computed at each point along the span, but linearly interpolated
// across the span

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int ur2, ul2, vr2, vl2;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

USHORT r_base, g_base, b_base,
       r_textel, g_textel, b_textel, textel;



#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;


// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract base color of lit poly, so we can modulate texture a bit
// for lighting
_RGB565FROM16BIT(face->lit_color[0], &r_base, &g_base, &b_base);

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = ((int)(face->tvlist[v0].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tv0 = ((int)(face->tvlist[v0].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = ((int)(face->tvlist[v1].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tv1 = ((int)(face->tvlist[v1].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = ((int)(face->tvlist[v2].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tv2 = ((int)(face->tvlist[v2].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{
	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << 0)/dy;  
	dvdyl = ((tv2 - tv0) << 0)/dy;    
	dzdyl = ((tz2 - tz0) << 0)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << 0)/dy;  
	dvdyr = ((tv2 - tv1) << 0)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << 0);
		vr = dvdyr*dy + (tv1 << 0);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu1 << 0);
		vr = (tv1 << 0);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;
		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << 0)/dy;  
	dvdyl = ((tv1 - tv0) << 0)/dy;    
	dzdyl = ((tz1 - tz0) << 0)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << 0)/dy;  
	dvdyr = ((tv2 - tv0) << 0)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;
		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);


	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			   // write textel
		       // get textel first
 			   textel = textmap[ (ui >> FIXP22_SHIFT) + ((vi >> FIXP22_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

		
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);


	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else


		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			   // write textel
		       // get textel first
 			   textel = textmap[ (ui >> FIXP22_SHIFT) + ((vi >> FIXP22_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;


		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << 0)/dyl;  
		dvdyl = ((tv2 - tv1) << 0)/dyl;    
		dzdyl = ((tz2 - tz1) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << 0);
		vl = dvdyl*dyl + (tv1 << 0);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << 0);
		vr = dvdyr*dyr + (tv0 << 0);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   		
		dzdyr = ((tz2 - tz0) << 0)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);


	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else


		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			   // write textel
		       // get textel first
 			   textel = textmap[ (ui >> FIXP22_SHIFT) + ((vi >> FIXP22_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;


		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);


	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			   // write textel
		       // get textel first
 			   textel = textmap[ (ui >> FIXP22_SHIFT) + ((vi >> FIXP22_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;


		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_PerspectiveLP_Triangle_FS_16

////////////////////////////////////////////////////////////////////////////////

void Draw_Textured_TriangleGS_16(POLYF4DV2_PTR face,   // ptr to face
                                 UCHAR *_dest_buffer, // pointer to video buffer
                                 int mem_pitch)       // bytes per line, 320, 640 etc.
{
// this function draws a textured gouraud shaded polygon, based on the affine texture mapper, 
// we simply interpolate the (R,G,B) values across the polygons along with the texture coordinates
// and then modulate to get the final color 

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,w, s,t,
    du,dv,dw, ds, dt, 
    xi,yi,              // the current interpolated x,y
	ui,vi,wi, si, ti,    // the current interpolated u,v
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dwdyl,   
	wl,
	dsdyl,    
	sl,
	dtdyl,   
	tl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dwdyr,
	wr,
	dsdyr,
	sr,
	dtdyr,
	tr;

int x0,y0,tu0,tv0,tw0, ts0,tt0,    // cached vertices
	x1,y1,tu1,tv1,tw1, ts1,tt1,
	x2,y2,tu2,tv2,tw2, ts2,tt2;

int r_base0, g_base0, b_base0,
    r_base1, g_base1, b_base1,
    r_base2, g_base2, b_base2;


UINT r_textel, g_textel, b_textel;
USHORT textel;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif


// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.0);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.0);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.0);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.0);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.0);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.0);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// assume 5.6.5 format -- sorry!
// we can't afford a function call in the inner loops, so we must write 
// two hard coded versions, if we want support for both 5.6.5, and 5.5.5
_RGB565FROM16BIT(face->lit_color[v0], &r_base0, &g_base0, &b_base0);
_RGB565FROM16BIT(face->lit_color[v1], &r_base1, &g_base1, &b_base1);
_RGB565FROM16BIT(face->lit_color[v2], &r_base2, &g_base2, &b_base2);

// scale to 8 bit 
r_base0 <<= 3;
g_base0 <<= 2;
b_base0 <<= 3;

// scale to 8 bit 
r_base1 <<= 3;
g_base1 <<= 2;
b_base1 <<= 3;

// scale to 8 bit 
r_base2 <<= 3;
g_base2 <<= 2;
b_base2 <<= 3;

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

ts0 = (int)(face->tvlist[v0].u0);
tt0 = (int)(face->tvlist[v0].v0);

tu0 = r_base0;
tv0 = g_base0; 
tw0 = b_base0; 

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

ts1 = (int)(face->tvlist[v1].u0);
tt1 = (int)(face->tvlist[v1].v0);

tu1 = r_base1;
tv1 = g_base1; 
tw1 = b_base1; 

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

ts2 = (int)(face->tvlist[v2].u0);
tt2 = (int)(face->tvlist[v2].v0);

tu2 = r_base2; 
tv2 = g_base2; 
tw2 = b_base2; 


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw2 - tw0) << FIXP16_SHIFT)/dy;  
	
    dsdyl = ((ts2 - ts0) << FIXP16_SHIFT)/dy;    
	dtdyl = ((tt2 - tt0) << FIXP16_SHIFT)/dy;  

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw1) << FIXP16_SHIFT)/dy;   

	dsdyr = ((ts2 - ts1) << FIXP16_SHIFT)/dy;   
	dtdyr = ((tt2 - tt1) << FIXP16_SHIFT)/dy;   


	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);


		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw1 << FIXP16_SHIFT);

		sr = dsdyr*dy + (ts1 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);


		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		wr = (tw1 << FIXP16_SHIFT);

		sr = (ts1 << FIXP16_SHIFT);
		tr = (tt1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dy; 

	dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dy;    
	dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dy; 


	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dy;   

	dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dy;   
	dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dy;   


	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);


		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);

		sr = dsdyr*dy + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt0 << FIXP16_SHIFT);


		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);


		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);

		sr = (ts0 << FIXP16_SHIFT);
		tr = (tt0 << FIXP16_SHIFT);


		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		
        si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			
			si+=dx*ds;
			ti+=dx*dt;

			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
 

		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = ((b_textel >> (FIXP16_SHIFT+8)) + 
                             ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                             ((r_textel >> (FIXP16_SHIFT+8)) << 11));

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
	
		sl+=dsdyl;
		tl+=dtdyl;

		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
 
		sr+=dsdyr;
		tr+=dtdyr;


		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
   		    //screen_ptr[xi] = ( (ui >> (FIXP16_SHIFT+3)) << 11) + 
            //                 ( (vi >> (FIXP16_SHIFT+2)) << 5) + 
            //                   (wi >> (FIXP16_SHIFT+3) );   

		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = ((b_textel >> (FIXP16_SHIFT+8)) + 
                             ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                             ((r_textel >> (FIXP16_SHIFT+8)) << 11));

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;

		sl+=dsdyl;
		tl+=dtdyl;

	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;

		sr+=dsdyr;
		tr+=dtdyr;


		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  


		dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		
		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;  

		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);

		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		wl = dwdyl*dyl + (tw1 << FIXP16_SHIFT);

		sl = dsdyl*dyl + (ts1 << FIXP16_SHIFT);
		tl = dtdyl*dyl + (tt1 << FIXP16_SHIFT);


		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);

		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dyr + (tw0 << FIXP16_SHIFT);

		sr = dsdyr*dyr + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dyr + (tt0 << FIXP16_SHIFT);


		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
		
			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);

         	SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);

			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);

			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl; 

		dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dyl; 


		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		
		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;   


		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);


		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);

		sr = dsdyr*dy + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);

			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);

			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);


			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
		
			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);

			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl;   

		dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dyl;   


		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;

		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   		
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;


		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);

		sr = (ts0 << FIXP16_SHIFT);
		tr = (tt0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);

			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);


			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);


			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
		

			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);

			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;


		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			
			si+=dx*ds;
			ti+=dx*dt;


			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
   		    //screen_ptr[xi] = ( (ui >> (FIXP16_SHIFT+3)) << 11) + 
            //                 ( (vi >> (FIXP16_SHIFT+2)) << 5) + 
            //                   (wi >> (FIXP16_SHIFT+3) );   

		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = ((b_textel >> (FIXP16_SHIFT+8)) + 
                             ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                             ((r_textel >> (FIXP16_SHIFT+8)) << 11));

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;

			si+=ds;
			ti+=dt;


			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
        ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
	
		sl+=dsdyl;
		tl+=dtdyl;


		xr+=dxdyr;
     	ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;


		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  

			dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;   		
			dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;  


			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);

			sl = (ts1 << FIXP16_SHIFT);
			tl = (tt1 << FIXP16_SHIFT);


			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;

			sl+=dsdyl;
			tl+=dtdyl;

			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   		

			dsdyr = ((ts1 - ts2) << FIXP16_SHIFT)/dyr;   		
			dtdyr = ((tt1 - tt2) << FIXP16_SHIFT)/dyr;  


			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);

			sr = (ts2 << FIXP16_SHIFT);
			tr = (tt2 << FIXP16_SHIFT);


			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
		
			sr+=dsdyr;
			tr+=dtdyr;


			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
   		    //screen_ptr[xi] = ( (ui >> (FIXP16_SHIFT+3)) << 11) + 
            //                 ( (vi >> (FIXP16_SHIFT+2)) << 5) + 
            //                   (wi >> (FIXP16_SHIFT+3) );   

		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = ((b_textel >> (FIXP16_SHIFT+8)) + 
                             ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                             ((r_textel >> (FIXP16_SHIFT+8)) << 11));  

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;

		sl+=dsdyl;
		tl+=dtdyl;

	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;

		sr+=dsdyr;
		tr+=dtdyr;


		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;   


			dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;   		
			dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);

			sl = (ts1 << FIXP16_SHIFT);
			tl = (tt1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;

			sl+=dsdyl;
			tl+=dtdyl;

			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   

			dsdyr = ((ts1 - ts2) << FIXP16_SHIFT)/dyr;   		
			dtdyr = ((tt1 - tt2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);

			sr = (ts2 << FIXP16_SHIFT);
			tr = (tt2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;

			sr+=dsdyr;
			tr+=dtdyr;

			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_TriangleGS_16

////////////////////////////////////////////////////////////////////////////////

void Draw_Gouraud_Triangle2_16(POLYF4DV2_PTR face,   // ptr to face
                              UCHAR *_dest_buffer, // pointer to video buffer
                              int mem_pitch)       // bytes per line, 320, 640 etc.
{
// this function draws a gouraud shaded polygon, based on the affine texture mapper, instead
// of interpolating the texture coordinates, we simply interpolate the (R,G,B) values across
// the polygons, I simply needed at another interpolant, I have mapped u->red, v->green, w->blue

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,w,
    du,dv,dw,
    xi,yi,              // the current interpolated x,y
	ui,vi,wi,           // the current interpolated u,v
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dwdyl,   
	wl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dwdyr,
	wr;

int x0,y0,tu0,tv0,tw0,    // cached vertices
	x1,y1,tu1,tv1,tw1,
	x2,y2,tu2,tv2,tw2;

int r_base0, g_base0, b_base0,
    r_base1, g_base1, b_base1,
    r_base2, g_base2, b_base2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.0);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.0);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.0);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.0);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.0);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.0);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// assume 5.6.5 format -- sorry!
// we can't afford a function call in the inner loops, so we must write 
// two hard coded versions, if we want support for both 5.6.5, and 5.5.5
_RGB565FROM16BIT(face->lit_color[v0], &r_base0, &g_base0, &b_base0);
_RGB565FROM16BIT(face->lit_color[v1], &r_base1, &g_base1, &b_base1);
_RGB565FROM16BIT(face->lit_color[v2], &r_base2, &g_base2, &b_base2);

// scale to 8 bit 
r_base0 <<= 3;
g_base0 <<= 2;
b_base0 <<= 3;

// scale to 8 bit 
r_base1 <<= 3;
g_base1 <<= 2;
b_base1 <<= 3;

// scale to 8 bit 
r_base2 <<= 3;
g_base2 <<= 2;
b_base2 <<= 3;

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

tu0 = r_base0;
tv0 = g_base0; 
tw0 = b_base0; 

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

tu1 = r_base1;
tv1 = g_base1; 
tw1 = b_base1; 

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

tu2 = r_base2; 
tv2 = g_base2; 
tw2 = b_base2; 


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw2 - tw0) << FIXP16_SHIFT)/dy;  

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw1) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		wr = (tw1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
   		    screen_ptr[xi] = ((ui >> (FIXP16_SHIFT+3)) << 11) + ((vi >> (FIXP16_SHIFT+2)) << 5) + (wi >> (FIXP16_SHIFT+3));   

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel 5.6.5
            screen_ptr[xi] = ((ui >> (FIXP16_SHIFT+3)) << 11) + ((vi >> (FIXP16_SHIFT+2)) << 5) + (wi >> (FIXP16_SHIFT+3));   

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);

		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		wl = dwdyl*dyl + (tw1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);

		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dyr + (tw0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            screen_ptr[xi] = ((ui >> (FIXP16_SHIFT+3)) << 11) + ((vi >> (FIXP16_SHIFT+2)) << 5) + (wi >> (FIXP16_SHIFT+3));   

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
        ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
	
		xr+=dxdyr;
     	ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   		

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            screen_ptr[xi] = ((ui >> (FIXP16_SHIFT+3)) << 11) + ((vi >> (FIXP16_SHIFT+2)) << 5) + (wi >> (FIXP16_SHIFT+3));   

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Gouraud_Triangle2_16

//////////////////////////////////////////////////////////////////////////////
// ALPHA BLENDING SUPPORT ////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////

void Draw_RENDERLIST4DV2_Solid_Alpha16(RENDERLIST4DV2_PTR rend_list, 
                                   UCHAR *video_buffer, 
	   						       int lpitch, 
                                   int alpha_override)
{
// 16-bit version
// this function "executes" the render list or in other words
// draws all the faces in the list, the function will call the 
// proper rasterizer based on the lighting model of the polygons

POLYF4DV2 face; // temp face used to render polygon
int alpha;      // used to hold alpha channel

// at this point, all we have is a list of polygons and it's time
// to draw them
for (int poly=0; poly < rend_list->num_polys; poly++)
    {
    // render this polygon if and only if it's not clipped, not culled,
    // active, and visible, note however the concecpt of "backface" is 
    // irrelevant in a wire frame engine though
    if (!(rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_ACTIVE) ||
         (rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_CLIPPED ) ||
         (rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_BACKFACE) )
       continue; // move onto next poly

    // test for alpha override
    if (alpha_override >= 0)
       {
       // set alpha to override value
       alpha = alpha_override;
       }  // end if 
    else
        {
        // extract alpha (even if there isn't any)
        alpha = ((rend_list->poly_ptrs[poly]->color & 0xff000000) >> 24);
        } // end else


    // need to test for textured first, since a textured poly can either
    // be emissive, or flat shaded, hence we need to call different
    // rasterizers    
    if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_TEXTURE)
       {

       // set the vertices
       face.tvlist[0].x = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;
       face.tvlist[0].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[0].u0;
       face.tvlist[0].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[0].v0;

       face.tvlist[1].x = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;
       face.tvlist[1].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[1].u0;
       face.tvlist[1].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[1].v0;

       face.tvlist[2].x = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;
       face.tvlist[2].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[2].u0;
       face.tvlist[2].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[2].v0;
    
       // assign the texture
       face.texture = rend_list->poly_ptrs[poly]->texture;
       
       // is this a plain emissive texture?
       if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT)
          {
          // draw the textured triangle as emissive
          // test for transparent
          if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || alpha_override >=0)
              Draw_Textured_Triangle_Alpha16(&face, video_buffer, lpitch, alpha);
          else
              Draw_Textured_Triangle2_16(&face, video_buffer, lpitch);

          } // end if
       else
       if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT)
          {
          // draw as flat shaded
          face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];

          // test for transparent
          if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || alpha_override >=0)
             Draw_Textured_TriangleFS_Alpha16(&face, video_buffer, lpitch, alpha);
          else
             Draw_Textured_TriangleFS2_16(&face, video_buffer, lpitch);

          } // end else
       else
          {
          // must be gouraud POLY4DV2_ATTR_SHADE_MODE_GOURAUD
          face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];
          face.lit_color[1] = rend_list->poly_ptrs[poly]->lit_color[1];
          face.lit_color[2] = rend_list->poly_ptrs[poly]->lit_color[2];
          // test for transparent
          if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || alpha_override >=0)
             Draw_Textured_TriangleGS_Alpha16(&face, video_buffer, lpitch, alpha);
          else
             Draw_Textured_TriangleGS_16(&face, video_buffer, lpitch);

          } // end else


       } // end if      
    else
    if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT) || 
        (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT) )
       {
       // draw as constant shaded
       face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];
       
       // set the vertices
       face.tvlist[0].x = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;

       face.tvlist[1].x = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;

       face.tvlist[2].x = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;

       // draw the triangle with basic flat rasterizer

       // test for transparent
       if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || alpha_override >=0)
          Draw_Triangle_2D_Alpha16(&face, video_buffer, lpitch,alpha);
       else
          Draw_Triangle_2D3_16(&face, video_buffer, lpitch);

       } // end if
    else
    if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_GOURAUD)
       {
        // {andre take advantage of the data structures later..}
        // set the vertices
        face.tvlist[0].x  = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
        face.tvlist[0].y  = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
        face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;
        face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];

        face.tvlist[1].x  = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
        face.tvlist[1].y  = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
        face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;
        face.lit_color[1] = rend_list->poly_ptrs[poly]->lit_color[1];

        face.tvlist[2].x  = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
        face.tvlist[2].y  = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
        face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;
        face.lit_color[2] = rend_list->poly_ptrs[poly]->lit_color[2];

	    // draw the gouraud shaded triangle
        // test for transparent
        if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || alpha_override >=0)
           Draw_Gouraud_Triangle_Alpha16(&face, video_buffer, lpitch,alpha);
        else
           Draw_Gouraud_Triangle2_16(&face, video_buffer, lpitch);
       } // end if gouraud

    } // end for poly

} // end Draw_RENDERLIST4DV2_Solid_Alpha16

/////////////////////////////////////////////////////////////////////////////////

void Draw_Triangle_2D_Alpha16(POLYF4DV2_PTR face,  // ptr to face
                              UCHAR *_dest_buffer, // pointer to video buffer
                              int mem_pitch,       // bytes per line, 320, 640 etc.
                              int alpha)
{
// this function draws a flat shaded polygon with zbuffering

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    xi,yi,              // the current interpolated x,y
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr;

int x0,y0,    // cached vertices
	x1,y1,
	x2,y2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

USHORT  r_src1, g_src1, b_src1,
        r_src2, g_src2, b_src2;

USHORT color;    // polygon color

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);


// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;


// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];

// extract constant color
color = face->lit_color[0];

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        dx = (xend - xstart);

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////


		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
   	        // write textel assume 5.6.5
            screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + alpha_table_src2[color];
			} // end for xi

		// interpolate x along right and left edge
		xl+=dxdyl;
		xr+=dxdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
        dx = (xend - xstart);

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
   	        // write textel assume 5.6.5
            screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + alpha_table_src2[color];
			} // end for xi

		// interpolate x,z along right and left edge
		xl+=dxdyl;
		xr+=dxdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
        dx = (xend - xstart);

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
 			{
   	        // write textel assume 5.6.5
            screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + alpha_table_src2[color];

			} // end for xi

		// interpolate z,x along right and left edge
		xl+=dxdyl;
		xr+=dxdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;

			// set starting values
			xl = (x1  << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;

			// set starting values
			xr = (x2  << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
        dx = (xend - xstart);

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
   	        // write textel assume 5.6.5
            screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + alpha_table_src2[color];
			} // end for xi

		// interpolate x,z along right and left edge
		xl+=dxdyl;
		xr+=dxdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;

			// set starting values
			xl = (x1  << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;

			// set starting values
			xr = (x2  << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Triangle_2D_Alpha16

////////////////////////////////////////////////////////////////////////////

void Draw_Textured_Triangle_Alpha16(POLYF4DV2_PTR face,   // ptr to face
                                UCHAR *_dest_buffer,      // pointer to video buffer
                                int mem_pitch, int alpha) // bytes per line, 320, 640 etc.
{
// this function draws a textured triangle in 16-bit mode

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,
    du,dv,
    xi,yi,              // the current interpolated x,y
	ui,vi,              // the current interpolated u,v
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dudyr,
	ur,
	dvdyr,
	vr;

int x0,y0,tu0,tv0,    // cached vertices
	x1,y1,tu1,tv1,
	x2,y2,tu2,tv2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = (int)(face->tvlist[v0].u0);
tv0 = (int)(face->tvlist[v0].v0);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = (int)(face->tvlist[v1].u0);
tv1 = (int)(face->tvlist[v1].v0);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = (int)(face->tvlist[v2].u0);
tv2 = (int)(face->tvlist[v2].v0);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel
            screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)]];
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel
	        screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)]];
			
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else


    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel
	        screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)]];
			
					
			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{

		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
		
			} // end else


			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)

			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel
	        screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)]];
			
			
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_Triangle_Alpha16

///////////////////////////////////////////////////////////////////////////////

void Draw_Textured_TriangleFS_Alpha16(POLYF4DV2_PTR face,   // ptr to face
                              UCHAR *_dest_buffer,   // pointer to video buffer
                              int mem_pitch, int alpha)        // bytes per line, 320, 640 etc.
{
// this function draws a textured triangle in 16-bit mode with flat shading

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,
    du,dv,
    xi,yi,              // the current interpolated x,y
	ui,vi,              // the current interpolated u,v
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dudyr,
	ur,
	dvdyr,
	vr;

USHORT r_base, g_base, b_base,
       r_textel, g_textel, b_textel, textel;

int x0,y0,tu0,tv0,    // cached vertices
	x1,y1,tu1,tv1,
	x2,y2,tu2,tv2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract base color of lit poly, so we can modulate texture a bit
// for lighting
_RGB565FROM16BIT(face->lit_color[0], &r_base, &g_base, &b_base);

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = (int)(face->tvlist[v0].u0);
tv0 = (int)(face->tvlist[v0].v0);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = (int)(face->tvlist[v1].u0);
tv1 = (int)(face->tvlist[v1].v0);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = (int)(face->tvlist[v2].u0);
tv2 = (int)(face->tvlist[v2].v0);

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel
		    // get textel first
 			textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with lit background color
            r_textel*=r_base; 
            g_textel*=g_base;
            b_textel*=b_base;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...

			// write textel
	        screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];
			
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel
		    // get textel first
 			textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with lit background color
            r_textel*=r_base; 
            g_textel*=g_base;
            b_textel*=b_base;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
			// write textel
	        screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];
			
			

			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else


    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel
            //screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];
		    // get textel first
 			textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with lit background color
            r_textel*=r_base; 
            g_textel*=g_base;
            b_textel*=b_base;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
			// write textel
	        screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];
			
		
			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
     		// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
		
			} // end else


			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)

			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel
		    // get textel first
 			textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with lit background color
            r_textel*=r_base; 
            g_textel*=g_base;
            b_textel*=b_base;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
			// write textel
	        screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];
			
			

			// interpolate u,v
			ui+=du;
			vi+=dv;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_TriangleFS_Alpha16

////////////////////////////////////////////////////////////////////////////////

void Draw_Textured_TriangleGS_Alpha16(POLYF4DV2_PTR face,   // ptr to face
                                      UCHAR *_dest_buffer, // pointer to video buffer
                                      int mem_pitch,       // bytes per line, 320, 640 etc.
                                      int alpha)
{
// this function draws a textured gouraud shaded polygon, based on the affine texture mapper, 
// we simply interpolate the (R,G,B) values across the polygons along with the texture coordinates
// and then modulate to get the final color 

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,w, s,t,
    du,dv,dw, ds, dt, 
    xi,yi,              // the current interpolated x,y
	ui,vi,wi, si, ti,    // the current interpolated u,v
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dwdyl,   
	wl,
	dsdyl,    
	sl,
	dtdyl,   
	tl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dwdyr,
	wr,
	dsdyr,
	sr,
	dtdyr,
	tr;

int x0,y0,tu0,tv0,tw0, ts0,tt0,    // cached vertices
	x1,y1,tu1,tv1,tw1, ts1,tt1,
	x2,y2,tu2,tv2,tw2, ts2,tt2;

int r_base0, g_base0, b_base0,
    r_base1, g_base1, b_base1,
    r_base2, g_base2, b_base2;


UINT r_textel, g_textel, b_textel;
USHORT textel;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.0);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.0);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.0);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.0);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.0);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.0);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// assume 5.6.5 format -- sorry!
// we can't afford a function call in the inner loops, so we must write 
// two hard coded versions, if we want support for both 5.6.5, and 5.5.5
_RGB565FROM16BIT(face->lit_color[v0], &r_base0, &g_base0, &b_base0);
_RGB565FROM16BIT(face->lit_color[v1], &r_base1, &g_base1, &b_base1);
_RGB565FROM16BIT(face->lit_color[v2], &r_base2, &g_base2, &b_base2);

// scale to 8 bit 
r_base0 <<= 3;
g_base0 <<= 2;
b_base0 <<= 3;

// scale to 8 bit 
r_base1 <<= 3;
g_base1 <<= 2;
b_base1 <<= 3;

// scale to 8 bit 
r_base2 <<= 3;
g_base2 <<= 2;
b_base2 <<= 3;

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

ts0 = (int)(face->tvlist[v0].u0);
tt0 = (int)(face->tvlist[v0].v0);

tu0 = r_base0;
tv0 = g_base0; 
tw0 = b_base0; 

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

ts1 = (int)(face->tvlist[v1].u0);
tt1 = (int)(face->tvlist[v1].v0);

tu1 = r_base1;
tv1 = g_base1; 
tw1 = b_base1; 

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

ts2 = (int)(face->tvlist[v2].u0);
tt2 = (int)(face->tvlist[v2].v0);

tu2 = r_base2; 
tv2 = g_base2; 
tw2 = b_base2; 


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw2 - tw0) << FIXP16_SHIFT)/dy;  
	
    dsdyl = ((ts2 - ts0) << FIXP16_SHIFT)/dy;    
	dtdyl = ((tt2 - tt0) << FIXP16_SHIFT)/dy;  

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw1) << FIXP16_SHIFT)/dy;   

	dsdyr = ((ts2 - ts1) << FIXP16_SHIFT)/dy;   
	dtdyr = ((tt2 - tt1) << FIXP16_SHIFT)/dy;   


	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);


		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw1 << FIXP16_SHIFT);

		sr = dsdyr*dy + (ts1 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);


		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		wr = (tw1 << FIXP16_SHIFT);

		sr = (ts1 << FIXP16_SHIFT);
		tr = (tt1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dy; 

	dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dy;    
	dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dy; 


	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dy;   

	dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dy;   
	dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dy;   


	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);


		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);

		sr = dsdyr*dy + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt0 << FIXP16_SHIFT);


		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);


		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);

		sr = (ts0 << FIXP16_SHIFT);
		tr = (tt0 << FIXP16_SHIFT);


		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		
        si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			
			si+=dx*ds;
			ti+=dx*dt;

			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
 

		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> (FIXP16_SHIFT+8)) + 
                             ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                             ((r_textel >> (FIXP16_SHIFT+8)) << 11))];
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
	
		sl+=dsdyl;
		tl+=dtdyl;

		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
 
		sr+=dsdyr;
		tr+=dtdyr;


		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
   		    //screen_ptr[xi] = ( (ui >> (FIXP16_SHIFT+3)) << 11) + 
            //                 ( (vi >> (FIXP16_SHIFT+2)) << 5) + 
            //                   (wi >> (FIXP16_SHIFT+3) );   

		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> (FIXP16_SHIFT+8)) + 
                             ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                             ((r_textel >> (FIXP16_SHIFT+8)) << 11))];

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;

		sl+=dsdyl;
		tl+=dtdyl;

	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;

		sr+=dsdyr;
		tr+=dtdyr;


		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  


		dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		
		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;  

		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);

		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		wl = dwdyl*dyl + (tw1 << FIXP16_SHIFT);

		sl = dsdyl*dyl + (ts1 << FIXP16_SHIFT);
		tl = dtdyl*dyl + (tt1 << FIXP16_SHIFT);


		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);

		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dyr + (tw0 << FIXP16_SHIFT);

		sr = dsdyr*dyr + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dyr + (tt0 << FIXP16_SHIFT);


		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
		
			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);

         	SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);

			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);

			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl; 

		dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dyl; 


		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		
		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;   


		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);


		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);

		sr = dsdyr*dy + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);

			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);

			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);


			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
		
			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);

			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl;   

		dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dyl;   


		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;

		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   		
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;


		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);

		sr = (ts0 << FIXP16_SHIFT);
		tr = (tt0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);

			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);


			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);


			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
		

			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);

			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;


		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			
			si+=dx*ds;
			ti+=dx*dt;


			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
   		    //screen_ptr[xi] = ( (ui >> (FIXP16_SHIFT+3)) << 11) + 
            //                 ( (vi >> (FIXP16_SHIFT+2)) << 5) + 
            //                   (wi >> (FIXP16_SHIFT+3) );   

		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> (FIXP16_SHIFT+8)) + 
                             ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                             ((r_textel >> (FIXP16_SHIFT+8)) << 11))];

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;

			si+=ds;
			ti+=dt;
			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
        ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
	
		sl+=dsdyl;
		tl+=dtdyl;

		xr+=dxdyr;
     	ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;

		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  

			dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;   		
			dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;  


			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);

			sl = (ts1 << FIXP16_SHIFT);
			tl = (tt1 << FIXP16_SHIFT);


			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;

			sl+=dsdyl;
			tl+=dtdyl;

			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   		

			dsdyr = ((ts1 - ts2) << FIXP16_SHIFT)/dyr;   		
			dtdyr = ((tt1 - tt2) << FIXP16_SHIFT)/dyr;  


			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);

			sr = (ts2 << FIXP16_SHIFT);
			tr = (tt2 << FIXP16_SHIFT);


			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
		
			sr+=dsdyr;
			tr+=dtdyr;


			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
   		    //screen_ptr[xi] = ( (ui >> (FIXP16_SHIFT+3)) << 11) + 
            //                 ( (vi >> (FIXP16_SHIFT+2)) << 5) + 
            //                   (wi >> (FIXP16_SHIFT+3) );   

		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> (FIXP16_SHIFT+8)) + 
                             ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                             ((r_textel >> (FIXP16_SHIFT+8)) << 11))]; 

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;

		sl+=dsdyl;
		tl+=dtdyl;

	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;

		sr+=dsdyr;
		tr+=dtdyr;


		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;   


			dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;   		
			dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);

			sl = (ts1 << FIXP16_SHIFT);
			tl = (tt1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;

			sl+=dsdyl;
			tl+=dtdyl;

			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   

			dsdyr = ((ts1 - ts2) << FIXP16_SHIFT)/dyr;   		
			dtdyr = ((tt1 - tt2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);

			sr = (ts2 << FIXP16_SHIFT);
			tr = (tt2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;

			sr+=dsdyr;
			tr+=dtdyr;

			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_TriangleGS_Alpha16

////////////////////////////////////////////////////////////////////////////////

void Draw_Gouraud_Triangle_Alpha16(POLYF4DV2_PTR face,   // ptr to face
                              UCHAR *_dest_buffer, // pointer to video buffer
                              int mem_pitch, int alpha)       // bytes per line, 320, 640 etc.
{
// this function draws a gouraud shaded polygon, based on the affine texture mapper, instead
// of interpolating the texture coordinates, we simply interpolate the (R,G,B) values across
// the polygons, I simply needed at another interpolant, I have mapped u->red, v->green, w->blue

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,w,
    du,dv,dw,
    xi,yi,              // the current interpolated x,y
	ui,vi,wi,           // the current interpolated u,v
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dwdyl,   
	wl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dwdyr,
	wr;

int x0,y0,tu0,tv0,tw0,    // cached vertices
	x1,y1,tu1,tv1,tw1,
	x2,y2,tu2,tv2,tw2;

int r_base0, g_base0, b_base0,
    r_base1, g_base1, b_base1,
    r_base2, g_base2, b_base2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.0);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.0);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.0);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.0);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.0);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.0);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// assume 5.6.5 format -- sorry!
// we can't afford a function call in the inner loops, so we must write 
// two hard coded versions, if we want support for both 5.6.5, and 5.5.5
_RGB565FROM16BIT(face->lit_color[v0], &r_base0, &g_base0, &b_base0);
_RGB565FROM16BIT(face->lit_color[v1], &r_base1, &g_base1, &b_base1);
_RGB565FROM16BIT(face->lit_color[v2], &r_base2, &g_base2, &b_base2);

// scale to 8 bit 
r_base0 <<= 3;
g_base0 <<= 2;
b_base0 <<= 3;

// scale to 8 bit 
r_base1 <<= 3;
g_base1 <<= 2;
b_base1 <<= 3;

// scale to 8 bit 
r_base2 <<= 3;
g_base2 <<= 2;
b_base2 <<= 3;

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

tu0 = r_base0;
tv0 = g_base0; 
tw0 = b_base0; 

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

tu1 = r_base1;
tv1 = g_base1; 
tw1 = b_base1; 

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

tu2 = r_base2; 
tv2 = g_base2; 
tw2 = b_base2; 


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];


// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw2 - tw0) << FIXP16_SHIFT)/dy;  

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw1) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		wr = (tw1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
	        screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((ui >> (FIXP16_SHIFT+3)) << 11) + ((vi >> (FIXP16_SHIFT+2)) << 5) + (wi >> (FIXP16_SHIFT+3))];
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
	        screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((ui >> (FIXP16_SHIFT+3)) << 11) + ((vi >> (FIXP16_SHIFT+2)) << 5) + (wi >> (FIXP16_SHIFT+3))];
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);

		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		wl = dwdyl*dyl + (tw1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);

		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dyr + (tw0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
	        screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((ui >> (FIXP16_SHIFT+3)) << 11) + ((vi >> (FIXP16_SHIFT+2)) << 5) + (wi >> (FIXP16_SHIFT+3))];
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
        ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
	
		xr+=dxdyr;
     	ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   		

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
	        screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((ui >> (FIXP16_SHIFT+3)) << 11) + ((vi >> (FIXP16_SHIFT+2)) << 5) + (wi >> (FIXP16_SHIFT+3))];
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Gouraud_Triangle_Alpha16

/////////////////////////////////////////////////////////////////////////////////////////////
// ZBUFFERED and ALPHA BLENDED //////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

void Draw_Triangle_2DZB_Alpha16(POLYF4DV2_PTR face,   // ptr to face
                                UCHAR *_dest_buffer,   // pointer to video buffer
                                int mem_pitch,         // bytes per line, 320, 640 etc.
                                UCHAR *_zbuffer,       // pointer to z-buffer
                                int zpitch,            // bytes per line of zbuffer
                                int alpha)
{
// this function draws a flat shaded polygon with zbuffering

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    z,
    dz,
    xi,yi,              // the current interpolated x,y
	zi,                 // the current interpolated z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
    dzdyl,   
	zl,
	dzdyr,
	zr;

int x0,y0,tz0,    // cached vertices
	x1,y1,tz1,
	x2,y2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

USHORT color;    // polygon color

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);


// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;


// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

tz0 = (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

tz1 = (int)(face->tvlist[v1].z+0.5);
            
x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

tz2 = (int)(face->tvlist[v2].z+0.5);

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];

// extract constant color
color = face->lit_color[0];

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dzdyl = ((tz2 - tz0) << FIXP16_SHIFT)/dy; 

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dzdyr = ((tz2 - tz1) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		zl = (tz0 << FIXP16_SHIFT);
		zr = (tz1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		zl = (tz0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v,w interpolants
		zi = zl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel assume 5.6.5
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + alpha_table_src2[color];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,w,z
			zi+=dz;
			} // end for xi

		// interpolate z,x along right and left edge
		xl+=dxdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel 5.6.5
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + alpha_table_src2[color];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if


			// interpolate z
			zi+=dz;
			} // end for xi

		// interpolate x,z along right and left edge
		xl+=dxdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;  
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;  
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		zl = (tz0 << FIXP16_SHIFT);

		zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for z interpolants
		zi = zl + FIXP16_ROUND_UP;
	
		// compute z interpolants
		if ((dx = (xend - xstart))>0)
			{
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel assume 5.6.5
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + alpha_table_src2[color];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate z
			zi+=dz;
			} // end for xi

		// interpolate z,x along right and left edge
		xl+=dxdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;  

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w,z interpolants
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel assume 5.6.5
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + alpha_table_src2[color];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate z
			zi+=dz;
			} // end for xi

		// interpolate x,z along right and left edge
		xl+=dxdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			zr+=dzdyr;
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Triangle_2DZB_Alpha16

///////////////////////////////////////////////////////////////////////////////

void Draw_Textured_TriangleZB_Alpha16(POLYF4DV2_PTR face,  // ptr to face
                              UCHAR *_dest_buffer,  // pointer to video buffer
                              int mem_pitch,        // bytes per line, 320, 640 etc.
                              UCHAR *_zbuffer,       // pointer to z-buffer
                              int zpitch,          // bytes per line of zbuffer
                              int alpha)
{
// this function draws a textured triangle in 16-bit mode

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = (int)(face->tvlist[v0].u0);
tv0 = (int)(face->tvlist[v0].v0);
tz0 = (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = (int)(face->tvlist[v1].u0);
tv1 = (int)(face->tvlist[v1].v0);
tz1 = (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = (int)(face->tvlist[v2].u0);
tv2 = (int)(face->tvlist[v2].v0);
tz2 = (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz2 - tz0) << FIXP16_SHIFT)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << FIXP16_SHIFT)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		zr = (tz1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
		
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
  			   // write textel
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)]];
			

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)]];
			
               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)]];
			

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)]];
			

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_TriangleZB_Alpha16

///////////////////////////////////////////////////////////////////////////////

void Draw_Textured_TriangleFSZB_Alpha16(POLYF4DV2_PTR face, // ptr to face
                                        UCHAR *_dest_buffer,  // pointer to video buffer
                                        int mem_pitch,        // bytes per line, 320, 640 etc.
                                        UCHAR *_zbuffer,       // pointer to z-buffer
                                        int zpitch,          // bytes per line of zbuffer
                                        int alpha)
{
// this function draws a textured triangle in 16-bit mode with flat shading

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,            // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dzdyl,    
	zl,
	dvdyl,   
	vl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

USHORT r_base, g_base, b_base,
       r_textel, g_textel, b_textel, textel;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;


#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;


// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP( face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract base color of lit poly, so we can modulate texture a bit
// for lighting
_RGB565FROM16BIT(face->lit_color[0], &r_base, &g_base, &b_base);

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = (int)(face->tvlist[v0].u0);
tv0 = (int)(face->tvlist[v0].v0);
tz0 = (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = (int)(face->tvlist[v1].u0);
tv1 = (int)(face->tvlist[v1].v0);
tz1 = (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = (int)(face->tvlist[v2].u0);
tv2 = (int)(face->tvlist[v2].v0);
tz2 = (int)(face->tvlist[v2].z+0.5);

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz2 - tz0) << FIXP16_SHIFT)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		zr = (tz1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
		
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];
			

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
            dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];
			

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,z
			ui+=du;
			vi+=dv;
            zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	    zl+=dzdyl;

		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
        zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
        dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
        dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;   		

		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
        zl = dzdyl*dyl + (tz1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
        zr = dzdyr*dyr + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
        dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
        dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
        zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
        zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
        dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
        dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;   		

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
        zl = (tz0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
        zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else


    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
        zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
            dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
            dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];
			
               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v
			ui+=du;
			vi+=dv;
            zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
     		// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;  

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else


			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,z interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)

			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
            dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
            dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];
			
               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,z
			ui+=du;
			vi+=dv;
            zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
        zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
        zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl; 

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_TriangleFSZB_Alpha16

///////////////////////////////////////////////////////////////////////////////

void Draw_Textured_TriangleGSZB_Alpha16(POLYF4DV2_PTR face, // ptr to face
                                 UCHAR *_dest_buffer,       // pointer to video buffer
                                 int mem_pitch,             // bytes per line, 320, 640 etc.
                                 UCHAR *_zbuffer,           // pointer to z-buffer
                                 int zpitch,                // bytes per line of zbuffer
                                 int alpha)
{
// this function draws a textured gouraud shaded polygon, and z bufferedbased on the affine texture mapper, 
// we simply interpolate the (R,G,B) values across the polygons along with the texture coordinates
// and then modulate to get the final color 

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,w,z, s,t,
    du,dv,dw,dz, ds, dt, 
    xi,yi,             // the current interpolated x,y
	ui,vi,wi,zi, si, ti,    // the current interpolated u,v
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dwdyl,   
	wl,
	dzdyl,   
	zl,
	dsdyl,    
	sl,
	dtdyl,   
	tl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dwdyr,
	wr,
	dzdyr,
	zr,
	dsdyr,
	sr,
	dtdyr,
	tr;

int x0,y0,tu0,tv0,tw0, tz0, ts0,tt0,    // cached vertices
	x1,y1,tu1,tv1,tw1, tz1, ts1,tt1,
	x2,y2,tu2,tv2,tw2, tz2, ts2,tt2;

int r_base0, g_base0, b_base0,
    r_base1, g_base1, b_base1,
    r_base2, g_base2, b_base2;

UINT r_textel, g_textel, b_textel;
USHORT textel;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif


// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.0);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.0);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.0);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.0);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.0);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.0);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// assume 5.6.5 format -- sorry!
// we can't afford a function call in the inner loops, so we must write 
// two hard coded versions, if we want support for both 5.6.5, and 5.5.5
_RGB565FROM16BIT(face->lit_color[v0], &r_base0, &g_base0, &b_base0);
_RGB565FROM16BIT(face->lit_color[v1], &r_base1, &g_base1, &b_base1);
_RGB565FROM16BIT(face->lit_color[v2], &r_base2, &g_base2, &b_base2);

// scale to 8 bit 
r_base0 <<= 3;
g_base0 <<= 2;
b_base0 <<= 3;

// scale to 8 bit 
r_base1 <<= 3;
g_base1 <<= 2;
b_base1 <<= 3;

// scale to 8 bit 
r_base2 <<= 3;
g_base2 <<= 2;
b_base2 <<= 3;

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

tz0 = (int)(face->tvlist[v0].z+0.5);
ts0 = (int)(face->tvlist[v0].u0);
tt0 = (int)(face->tvlist[v0].v0);

tu0 = r_base0;
tv0 = g_base0; 
tw0 = b_base0; 

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

tz1 = (int)(face->tvlist[v1].z+0.5);
ts1 = (int)(face->tvlist[v1].u0);
tt1 = (int)(face->tvlist[v1].v0);

tu1 = r_base1;
tv1 = g_base1; 
tw1 = b_base1; 

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

tz2 = (int)(face->tvlist[v2].z+0.5);
ts2 = (int)(face->tvlist[v2].u0);
tt2 = (int)(face->tvlist[v2].v0);

tu2 = r_base2; 
tv2 = g_base2; 
tw2 = b_base2; 

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw2 - tw0) << FIXP16_SHIFT)/dy;  
	dzdyl = ((tz2 - tz0) << FIXP16_SHIFT)/dy; 
	
    dsdyl = ((ts2 - ts0) << FIXP16_SHIFT)/dy;    
	dtdyl = ((tt2 - tt0) << FIXP16_SHIFT)/dy;  

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << FIXP16_SHIFT)/dy;   

	dsdyr = ((ts2 - ts1) << FIXP16_SHIFT)/dy;   
	dtdyr = ((tt2 - tt1) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << FIXP16_SHIFT);

		sr = dsdyr*dy + (ts1 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);


		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		wr = (tw1 << FIXP16_SHIFT);
		zr = (tz1 << FIXP16_SHIFT);

		sr = (ts1 << FIXP16_SHIFT);
		tr = (tt1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dy; 
	dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dy; 

	dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dy;    
	dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dy;   

	dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dy;   
	dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dy;   


	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		sr = dsdyr*dy + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt0 << FIXP16_SHIFT);


		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);


		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		sr = (ts0 << FIXP16_SHIFT);
		tr = (tt0 << FIXP16_SHIFT);


		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
		
        si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			zi+=dx*dz;
			
			si+=dx*ds;
			ti+=dx*dt;

			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
            { 
		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> (FIXP16_SHIFT+8)) + 
                                              ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                                              ((r_textel >> (FIXP16_SHIFT+8)) << 11))];
			
            // update z-buffer
            z_ptr[xi] = zi;   

            } // end if 

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		sl+=dsdyl;
		tl+=dtdyl;

		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;
 
		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
            { 
		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> (FIXP16_SHIFT+8)) + 
                                              ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                                              ((r_textel >> (FIXP16_SHIFT+8)) << 11))];

            // update z-buffer
            z_ptr[xi] = zi;   

            } // end if 

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;

		sl+=dsdyl;
		tl+=dtdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  
		dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;  

		dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;   
		
		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;  

		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);

		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		wl = dwdyl*dyl + (tw1 << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << FIXP16_SHIFT);

		sl = dsdyl*dyl + (ts1 << FIXP16_SHIFT);
		tl = dtdyl*dyl + (tt1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);

		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dyr + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << FIXP16_SHIFT);

		sr = dsdyr*dyr + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dyr + (tt0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
		
			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);

         	SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);

			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);

			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl; 
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl; 

		dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;   
		
		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;   

		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		sr = dsdyr*dy + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);

			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);

			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);

			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);

			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl;   
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl;  

		dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;

		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   		
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		sr = (ts0 << FIXP16_SHIFT);
		tr = (tt0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);

			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);


			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);


			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);

			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			zi+=dx*dz;
			
			si+=dx*ds;
			ti+=dx*dt;

			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
            { 
		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> (FIXP16_SHIFT+8)) + 
                                              ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                                              ((r_textel >> (FIXP16_SHIFT+8)) << 11))];

            // update z-buffer
            z_ptr[xi] = zi;   

            } // end if 

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
        ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		sl+=dsdyl;
		tl+=dtdyl;

		xr+=dxdyr;
     	ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;  

			dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;   		
			dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;  


			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			sl = (ts1 << FIXP16_SHIFT);
			tl = (tt1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			zl+=dzdyl;

			sl+=dsdyl;
			tl+=dtdyl;

			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;   

			dsdyr = ((ts1 - ts2) << FIXP16_SHIFT)/dyr;   		
			dtdyr = ((tt1 - tt2) << FIXP16_SHIFT)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			sr = (ts2 << FIXP16_SHIFT);
			tr = (tt2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			zr+=dzdyr;
		
			sr+=dsdyr;
			tr+=dtdyr;
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
            { 
		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> (FIXP16_SHIFT+8)) + 
                                              ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                                              ((r_textel >> (FIXP16_SHIFT+8)) << 11))];

            // update z-buffer
            z_ptr[xi] = zi;   

            } // end if 

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;

			si+=ds;
			ti+=dt;
			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;

		sl+=dsdyl;
		tl+=dtdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;   
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;  

			dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;   		
			dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			sl = (ts1 << FIXP16_SHIFT);
			tl = (tt1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			zl+=dzdyl;

			sl+=dsdyl;
			tl+=dtdyl;

			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;   

			dsdyr = ((ts1 - ts2) << FIXP16_SHIFT)/dyr;   		
			dtdyr = ((tt1 - tt2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			sr = (ts2 << FIXP16_SHIFT);
			tr = (tt2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			zr+=dzdyr;

			sr+=dsdyr;
			tr+=dtdyr;

			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_TriangleGSZB_Alpha16

///////////////////////////////////////////////////////////////////////////////

void Draw_Gouraud_TriangleZB_Alpha16(POLYF4DV2_PTR face,   // ptr to face
                                     UCHAR *_dest_buffer,   // pointer to video buffer
                                     int mem_pitch,         // bytes per line, 320, 640 etc.
                                     UCHAR *_zbuffer,       // pointer to z-buffer
                                     int zpitch,            // bytes per line of zbuffer
                                     int alpha)
{
// this function draws a gouraud shaded polygon, based on the affine texture mapper, instead
// of interpolating the texture coordinates, we simply interpolate the (R,G,B) values across
// the polygons, I simply needed at another interpolant, I have mapped u->red, v->green, w->blue
// also a new interpolant for z buffering has been added

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,w,z,
    du,dv,dw,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,wi,zi,        // the current interpolated u,v,w,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
    dudyl,    
	ul,
	dvdyl,   
	vl,
	dwdyl,   
	wl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dwdyr,
	wr,
	dzdyr,
	zr;

int x0,y0,tu0,tv0,tw0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tw1,tz1,
	x2,y2,tu2,tv2,tw2,tz2;

int r_base0, g_base0, b_base0,
    r_base1, g_base1, b_base1,
    r_base2, g_base2, b_base2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;


// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// assume 5.6.5 format -- sorry!
// we can't afford a function call in the inner loops, so we must write 
// two hard coded versions, if we want support for both 5.6.5, and 5.5.5
_RGB565FROM16BIT(face->lit_color[v0], &r_base0, &g_base0, &b_base0);
_RGB565FROM16BIT(face->lit_color[v1], &r_base1, &g_base1, &b_base1);
_RGB565FROM16BIT(face->lit_color[v2], &r_base2, &g_base2, &b_base2);

// scale to 8 bit 
r_base0 <<= 3;
g_base0 <<= 2;
b_base0 <<= 3;

// scale to 8 bit 
r_base1 <<= 3;
g_base1 <<= 2;
b_base1 <<= 3;

// scale to 8 bit 
r_base2 <<= 3;
g_base2 <<= 2;
b_base2 <<= 3;

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

tz0 = (int)(face->tvlist[v0].z+0.5);
tu0 = r_base0;
tv0 = g_base0; 
tw0 = b_base0; 

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

tz1 = (int)(face->tvlist[v1].z+0.5);
tu1 = r_base1;
tv1 = g_base1; 
tw1 = b_base1; 

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

tz2 = (int)(face->tvlist[v2].z+0.5);
tu2 = r_base2; 
tv2 = g_base2; 
tw2 = b_base2; 

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw2 - tw0) << FIXP16_SHIFT)/dy;  
	dzdyl = ((tz2 - tz0) << FIXP16_SHIFT)/dy; 

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		wr = (tw1 << FIXP16_SHIFT);
		zr = (tz1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dy; 
	dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel assume 5.6.5
   	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((ui >> (FIXP16_SHIFT+3)) << 11) + ((vi >> (FIXP16_SHIFT+2)) << 5) + (wi >> (FIXP16_SHIFT+3))];
			

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,w,z
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;
			} // end for xi

		// interpolate u,v,w,z,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel 5.6.5
	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((ui >> (FIXP16_SHIFT+3)) << 11) + ((vi >> (FIXP16_SHIFT+2)) << 5) + (wi >> (FIXP16_SHIFT+3))];
			

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if


			// interpolate u,v,w,z
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;
			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  
		dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;  
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);

		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		wl = dwdyl*dyl + (tw1 << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);

		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dyr + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl; 
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;  
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl;   
		dzdyl = ((tz1 - tz0) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << FIXP16_SHIFT)/dyr;

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);
		zr = (tz0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel assume 5.6.5
	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((ui >> (FIXP16_SHIFT+3)) << 11) + ((vi >> (FIXP16_SHIFT+2)) << 5) + (wi >> (FIXP16_SHIFT+3))];
			

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,w,z
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;
			} // end for xi

		// interpolate u,v,w,z,x along right and left edge
		xl+=dxdyl;
        ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
     	ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;  

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w,z interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi < z_ptr[xi])
               {
			   // write textel assume 5.6.5
   	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((ui >> (FIXP16_SHIFT+3)) << 11) + ((vi >> (FIXP16_SHIFT+2)) << 5) + (wi >> (FIXP16_SHIFT+3))];
			

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,w,z
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;
			} // end for xi

		// interpolate u,v,w,x,z along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;   
			dzdyl = ((tz2 - tz1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);
			zl = (tz1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   
			dzdyr = ((tz1 - tz2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);
			zr = (tz2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			zr+=dzdyr;
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Gouraud_TriangleZB_Alpha16

///////////////////////////////////////////////////////////////////////////////

void Draw_RENDERLIST4DV2_SolidZB_Alpha16(RENDERLIST4DV2_PTR rend_list, 
                                         UCHAR *video_buffer, 
	        					         int lpitch,
                                         UCHAR *zbuffer,
                                         int zpitch,
                                         int alpha_override)
{
// 16-bit version
// this function "executes" the render list or in other words
// draws all the faces in the list, the function will call the 
// proper rasterizer based on the lighting model of the polygons
// only call the alpha rasterizer for polys with the POLY4DV2_ATTR_TRANSPARENT
// flag set

POLYF4DV2 face; // temp face used to render polygon
int alpha;      // alpha of the face


// at this point, all we have is a list of polygons and it's time
// to draw them
for (int poly=0; poly < rend_list->num_polys; poly++)
    {
    // render this polygon if and only if it's not clipped, not culled,
    // active, and visible, note however the concecpt of "backface" is 
    // irrelevant in a wire frame engine though
    if (!(rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_ACTIVE) ||
         (rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_CLIPPED ) ||
         (rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_BACKFACE) )
       continue; // move onto next poly

    // test for alpha override
    if (alpha_override >= 0)
       {
       // set alpha to override value
       alpha = alpha_override;
       }  // end if 
    else
        {
        // extract alpha (even if there isn't any)
        alpha = ((rend_list->poly_ptrs[poly]->color & 0xff000000) >> 24);
        } // end else

    // need to test for textured first, since a textured poly can either
    // be emissive, or flat shaded, hence we need to call different
    // rasterizers    
    if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_TEXTURE)
       {

       // set the vertices
       face.tvlist[0].x = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;
       face.tvlist[0].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[0].u0;
       face.tvlist[0].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[0].v0;

       face.tvlist[1].x = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;
       face.tvlist[1].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[1].u0;
       face.tvlist[1].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[1].v0;

       face.tvlist[2].x = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;
       face.tvlist[2].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[2].u0;
       face.tvlist[2].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[2].v0;
    
       // assign the texture
       face.texture = rend_list->poly_ptrs[poly]->texture;
       
       // is this a plain emissive texture?
       if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT)
          {
          // draw the textured triangle as emissive

          if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || alpha_override >=0)
             Draw_Textured_TriangleZB_Alpha16(&face, video_buffer, lpitch,zbuffer,zpitch, alpha);
          else
             Draw_Textured_TriangleZB2_16(&face, video_buffer, lpitch,zbuffer,zpitch);
          } // end if
       else
      if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT)
          {
          // draw as flat shaded
          face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];

          // test for transparency
          if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || alpha_override >=0)
             Draw_Textured_TriangleFSZB_Alpha16(&face, video_buffer, lpitch,zbuffer,zpitch, alpha);
          else
             Draw_Textured_TriangleFSZB2_16(&face, video_buffer, lpitch,zbuffer,zpitch);
          } // end else if
      else
         { // POLY4DV2_ATTR_SHADE_MODE_GOURAUD

          // must be gouraud POLY4DV2_ATTR_SHADE_MODE_GOURAUD
          face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];
          face.lit_color[1] = rend_list->poly_ptrs[poly]->lit_color[1];
          face.lit_color[2] = rend_list->poly_ptrs[poly]->lit_color[2];

          // test for transparency
          if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || alpha_override >=0)
             Draw_Textured_TriangleGSZB_Alpha16(&face, video_buffer, lpitch,zbuffer,zpitch,alpha);
          else
             Draw_Textured_TriangleGSZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);

         } // end else

       } // end if      
    else
    if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT) || 
        (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT) )
       {
       // draw as constant shaded
       face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];
       
       // set the vertices
       face.tvlist[0].x = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;

       face.tvlist[1].x = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;

       face.tvlist[2].x = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;

       // draw the triangle with basic flat rasterizer
       // test for transparency
       if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || alpha_override >=0)
          Draw_Triangle_2DZB_Alpha16(&face, video_buffer, lpitch,zbuffer,zpitch,alpha);
       else
          Draw_Triangle_2DZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);

       } // end if
    else
    if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_GOURAUD)
       {
        // {andre take advantage of the data structures later..}
        // set the vertices
        face.tvlist[0].x  = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
        face.tvlist[0].y  = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
        face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;
        face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];

        face.tvlist[1].x  = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
        face.tvlist[1].y  = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
        face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;
        face.lit_color[1] = rend_list->poly_ptrs[poly]->lit_color[1];

        face.tvlist[2].x  = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
        face.tvlist[2].y  = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
        face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;
        face.lit_color[2] = rend_list->poly_ptrs[poly]->lit_color[2];

	    // draw the gouraud shaded triangle
        // test for transparency
        if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || alpha_override >=0)
            Draw_Gouraud_TriangleZB_Alpha16(&face, video_buffer, lpitch,zbuffer,zpitch,alpha);
        else
            Draw_Gouraud_TriangleZB2_16(&face, video_buffer, lpitch,zbuffer,zpitch);

       } // end if gouraud

    } // end for poly

} // end Draw_RENDERLIST4DV2_SolidZB_Alpha16


/////////////////////////////////////////////////////////////////////////////////////////////

int RGB_Alpha_Table_Builder(int num_alpha_levels,            // number of levels to create
                            USHORT rgb_alpha_table[NUM_ALPHA_LEVELS][65536]) // lookup table
{
// this function creates an alpha lookup table, the purpose of the table is as 
// follows; when alpha blending two RGB values, one can't simply use the formula:
// final = (alpha)*(source1RGB) + (1-alpha)*(source2RGB)
// the reason of course is that the multiplication has to be carried out on R, G, B
// separately, this we first have to extract out r,g,b from both sources, then multiply
// both, then add the results, then build the result up and store it ! Ouch! 
// therefore, we can use a table to speed this up in some cases, so if we think of
// the input RGB as a number and then let the table extract everything out and do the
// multiplication by the alpha blending factor, then we save all that work and in the 
// end an alpha blend turns into two accesses, and an addition, so we avoid 6 multiplications
// and all the shift. Of course, if the colors are already in r,g,b form already then
// another approach may be better. In any case, the function works by creating a 
// table that consists of num_alpha_levels rows, each row consist of 65536 entries which
// represents the scale value of that row times each of the 65536 colors in RGB format
// also, the num_alpha_levels must be a power of two, so num_alpha_levels of 8 for example
// will result in a table that has 8 rows, where the multiplier each row would be
// 8/8, 7/8, 6/8..........1/8, 0/8 is the amount of source pixel to mix


// first check the pointer
if (!rgb_alpha_table)
   return(-1);

int r,g,b; // used to scan colors out of rgbindex

float alpha       = 0;
float delta_alpha = EPSILON_E6 + 1/((float)(num_alpha_levels-1)); 

// we need num_alpha_level_rows
for (int alpha_level = 0; alpha_level < num_alpha_levels; alpha_level++)
    {
    // there are 65536 RGB values we need to compute, assuming that we are in RGB: 4.4.4  format
    for (int rgbindex = 0; rgbindex < 65536; rgbindex++)
        {
        // extract r,g,b from rgbindex, assuming an encoding of 5.6.5
        _RGB565FROM16BIT(rgbindex, &r, &g, &b);

        // scale
        r = (int)( (float)r * (float)alpha );
        g = (int)( (float)g * (float)alpha );
        b = (int)( (float)b * (float)alpha );

        // build pixel back up and store
        rgb_alpha_table[alpha_level][rgbindex] = _RGB16BIT565(r,g,b);

        } // end for rgbindex
        
    // decrease alpha level
    alpha+=delta_alpha;

    } // end for row 

// return success
return(1);

} // end RGB_Alpha_Table_Builder


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int Load_OBJECT4DV2_COB2(OBJECT4DV2_PTR obj,   // pointer to object
                         char *filename,       // filename of Caligari COB file
                         VECTOR4D_PTR scale,   // initial scaling factors
                         VECTOR4D_PTR pos,     // initial position
                         VECTOR4D_PTR rot,     // initial rotations
                         int vertex_flags,     // flags to re-order vertices 
                                               // and perform transforms
                         int mipmap  )         // mipmap enable flag
                                               // 0 means no mipmap, 1 means
                                               // generate mip map
  
{
// this function loads a Caligari TrueSpace .COB file object in off disk, additionally
// it allows the caller to scale, position, and rotate the object
// to save extra calls later for non-dynamic objects, note that this function 
// works with a OBJECT4DV2 which has support for textures, but not materials, etc, 
// however we will still parse out the material stuff and get them ready for the 
// next incarnation objects, so we can re-use this code to support those features
// also, since this version IS going to read in the texture map and texture coordinates
// we have a couple issues to think about, first COB format like absolute texture paths
// we can't have that, so we will simple extract out ONLY the texture map bitmap name
// and use the global texture path variable to build a real file path, also texture
// coordinates are in 0..1 0..1 form, I still haven't decided if I want to use absolute
// coordinates or 0..1 0..1, but right now the affine texture mapper uses 

// new version 2.0 supports alpha channel and mip mapping, if mipmap = 1 then the
// loader will automatically mipmap the texture and then fix the object pointer and 
// all subsequent polygon texture pointers to point to the mipmap chain d=0 texture
// pointer rather than directly to the texture, thus mipmapped objects
// must be flagged and processed differently

// create a parser object
CPARSERV1 parser; 

char seps[16];          // seperators for token scanning
char token_buffer[256]; // used as working buffer for token
char *token;            // pointer to next token

int r,g,b;              // working colors

// cache for texture vertices
VERTEX2DF texture_vertices[OBJECT4DV2_MAX_VERTICES];

int num_texture_vertices = 0;

MATRIX4X4 mat_local,  // storage for local transform if user requests it in cob format
          mat_world;  // "   " for local to world " "

// initialize matrices
MAT_IDENTITY_4X4(&mat_local);
MAT_IDENTITY_4X4(&mat_world);

// Step 1: clear out the object and initialize it a bit
memset(obj, 0, sizeof(OBJECT4DV2));

// set state of object to active and visible
obj->state = OBJECT4DV2_STATE_ACTIVE | OBJECT4DV2_STATE_VISIBLE;

// set number of frames
obj->num_frames = 1;
obj->curr_frame = 0;
obj->attr = OBJECT4DV2_ATTR_SINGLE_FRAME;


// set position of object is caller requested position
if (pos)
   {
   // set position of object
   obj->world_pos.x = pos->x;
   obj->world_pos.y = pos->y;
   obj->world_pos.z = pos->z;
   obj->world_pos.w = pos->w;
   } // end 
else
   {
   // set it to (0,0,0,1)
   obj->world_pos.x = 0;
   obj->world_pos.y = 0;
   obj->world_pos.z = 0;
   obj->world_pos.w = 1;
   } // end else

// Step 2: open the file for reading using the parser
if (!parser.Open(filename))
   {
   Write_Error("Couldn't open .COB file %s.", filename);
   return(0);
   } // end if

// Step 3: 

// lets find the name of the object first 
while(1)
     {
     // get the next line, we are looking for "Name"
     if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
        {
        Write_Error("Image 'name' not found in .COB file %s.", filename);
        return(0);
        } // end if
    
     // check for pattern?  
     if ( parser.Pattern_Match(parser.buffer, "['Name'] [s>0]") )
        {
        // name should be in second string variable, index 1
        strcpy(obj->name, parser.pstrings[1]);          
        Write_Error("\nCOB Reader Object Name: %s", obj->name);

        break;    
        } // end if

     } // end while


// step 4: get local and world transforms and store them

// center 0 0 0
// x axis 1 0 0
// y axis 0 1 0
// z axis 0 0 1

while(1)
     {
     // get the next line, we are looking for "center"
     if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
        {
        Write_Error("Center not found in .COB file %s.", filename);
        return(0);
        } // end if
    
     // check for pattern?  
     if ( parser.Pattern_Match(parser.buffer, "['center'] [f] [f] [f]") )
        {
        // the "center" holds the translation factors, so place in
        // last row of homogeneous matrix, note that these are row vectors
        // that we need to drop in each column of matrix
        mat_local.M[3][0] = -parser.pfloats[0]; // center x
        mat_local.M[3][1] = -parser.pfloats[1]; // center y
        mat_local.M[3][2] = -parser.pfloats[2]; // center z

        // ok now, the next 3 lines should be the x,y,z transform vectors
        // so build up   

        // "x axis" 
        parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS);
        parser.Pattern_Match(parser.buffer, "['x'] ['axis'] [f] [f] [f]");
      
        // place row in x column of transform matrix
        mat_local.M[0][0] = parser.pfloats[0]; // rxx
        mat_local.M[1][0] = parser.pfloats[1]; // rxy
        mat_local.M[2][0] = parser.pfloats[2]; // rxz

        // "y axis" 
        parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS);
        parser.Pattern_Match(parser.buffer, "['y'] ['axis'] [f] [f] [f]");
      
        // place row in y column of transform matrix
        mat_local.M[0][1] = parser.pfloats[0]; // ryx
        mat_local.M[1][1] = parser.pfloats[1]; // ryy
        mat_local.M[2][1] = parser.pfloats[2]; // ryz

        // "z axis" 
        parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS);
        parser.Pattern_Match(parser.buffer, "['z'] ['axis'] [f] [f] [f]");
      
        // place row in z column of transform matrix
        mat_local.M[0][2] = parser.pfloats[0]; // rzx
        mat_local.M[1][2] = parser.pfloats[1]; // rzy
        mat_local.M[2][2] = parser.pfloats[2]; // rzz

        Print_Mat_4X4(&mat_local, "Local COB Matrix:");

        break;    
        } // end if

     } // end while

// now "Transform"
while(1)
     {
     // get the next line, we are looking for "Transform"
     if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
        {
        Write_Error("Transform not found in .COB file %s.", filename);
        return(0);
        } // end if
    
     // check for pattern?  
     if ( parser.Pattern_Match(parser.buffer, "['Transform']") )
        {

        // "x axis" 
        parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS);
        parser.Pattern_Match(parser.buffer, "[f] [f] [f]");
      
        // place row in x column of transform matrix
        mat_world.M[0][0] = parser.pfloats[0]; // rxx
        mat_world.M[1][0] = parser.pfloats[1]; // rxy
        mat_world.M[2][0] = parser.pfloats[2]; // rxz

        // "y axis" 
        parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS);
        parser.Pattern_Match(parser.buffer, "[f] [f] [f]");
      
        // place row in y column of transform matrix
        mat_world.M[0][1] = parser.pfloats[0]; // ryx
        mat_world.M[1][1] = parser.pfloats[1]; // ryy
        mat_world.M[2][1] = parser.pfloats[2]; // ryz

        // "z axis" 
        parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS);
        parser.Pattern_Match(parser.buffer, "[f] [f] [f]");
      
        // place row in z column of transform matrix
        mat_world.M[0][2] = parser.pfloats[0]; // rzx
        mat_world.M[1][2] = parser.pfloats[1]; // rzy
        mat_world.M[2][2] = parser.pfloats[2]; // rzz

        Print_Mat_4X4(&mat_world, "World COB Matrix:");

        // no need to read in last row, since it's always 0,0,0,1 and we don't use it anyway
        break;    

        } // end if

     } // end while

// step 6: get number of vertices and polys in object
while(1)
     {
     // get the next line, we are looking for "World Vertices" 
     if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
        {
        Write_Error("'World Vertices' line not found in .COB file %s.", filename);
        return(0);
        } // end if
    
     // check for pattern?  
     if (parser.Pattern_Match(parser.buffer, "['World'] ['Vertices'] [i]") )
        {
        // simply extract the number of vertices from the pattern matching 
        // output arrays
        obj->num_vertices = parser.pints[0];

        Write_Error("\nCOB Reader Num Vertices: %d", obj->num_vertices);
        break;    
 
        } // end if

     } // end while

// allocate the memory for the vertices and number of polys (unknown, so use 3*num_vertices)
// the call parameters are redundant in this case, but who cares
if (!Init_OBJECT4DV2(obj,   // object to allocate
                obj->num_vertices, 
                obj->num_vertices*3,  
                obj->num_frames))
    {
    Write_Error("\nASC file error with file %s (can't allocate memory).",filename);
    } // end if

// Step 7: load the vertex list
// now read in vertex list, format:
// "d.d d.d d.d"
 for (int vertex = 0; vertex < obj->num_vertices; vertex++)
     {
     // hunt for vertex
     while(1)
     {
     // get the next vertex
     if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
        {
        Write_Error("\nVertex list ended abruptly! in .COB file %s.", filename);
        return(0);
        } // end if
    
     // check for pattern?  
     if (parser.Pattern_Match(parser.buffer, "[f] [f] [f]"))
        {
        // at this point we have the x,y,z in the the pfloats array locations 0,1,2
        obj->vlist_local[vertex].x = parser.pfloats[0];
        obj->vlist_local[vertex].y = parser.pfloats[1];
        obj->vlist_local[vertex].z = parser.pfloats[2];
        obj->vlist_local[vertex].w = 1;

        // do vertex swapping right here, allow muliple swaps, why not!
        // defines for vertex re-ordering flags

        //#define VERTEX_FLAGS_INVERT_X   1    // inverts the Z-coordinates
        //#define VERTEX_FLAGS_INVERT_Y   2    // inverts the Z-coordinates
        //#define VERTEX_FLAGS_INVERT_Z   4    // inverts the Z-coordinates
        //#define VERTEX_FLAGS_SWAP_YZ    8    // transforms a RHS model to a LHS model
        //#define VERTEX_FLAGS_SWAP_XZ    16   // ???
        //#define VERTEX_FLAGS_SWAP_XY    32
        //#define VERTEX_FLAGS_INVERT_WINDING_ORDER 64  // invert winding order from cw to ccw or ccw to cc
        //#define VERTEX_FLAGS_TRANSFORM_LOCAL         512   // if file format has local transform then do it!
        //#define VERTEX_FLAGS_TRANSFORM_LOCAL_WORLD  1024  // if file format has local to world then do it!

        VECTOR4D temp_vector; // temp for calculations

        // now apply local and world transformations encoded in COB format
        if (vertex_flags & VERTEX_FLAGS_TRANSFORM_LOCAL )
           {
           Mat_Mul_VECTOR4D_4X4(&obj->vlist_local[vertex].v, &mat_local, &temp_vector);
           VECTOR4D_COPY(&obj->vlist_local[vertex].v, &temp_vector); 
           } // end if 

        if (vertex_flags & VERTEX_FLAGS_TRANSFORM_LOCAL_WORLD )
           {
           Mat_Mul_VECTOR4D_4X4(&obj->vlist_local[vertex].v, &mat_world, &temp_vector);
           VECTOR4D_COPY(&obj->vlist_local[vertex].v, &temp_vector); 
           } // end if 

        float temp_f; // used for swapping

        // invert signs?
        if (vertex_flags & VERTEX_FLAGS_INVERT_X)
           obj->vlist_local[vertex].x=-obj->vlist_local[vertex].x;

        if (vertex_flags & VERTEX_FLAGS_INVERT_Y)
           obj->vlist_local[vertex].y=-obj->vlist_local[vertex].y;

        if (vertex_flags & VERTEX_FLAGS_INVERT_Z)
           obj->vlist_local[vertex].z=-obj->vlist_local[vertex].z;

        // swap any axes?
        if (vertex_flags & VERTEX_FLAGS_SWAP_YZ)
           SWAP(obj->vlist_local[vertex].y, obj->vlist_local[vertex].z, temp_f);
        
        if (vertex_flags & VERTEX_FLAGS_SWAP_XZ)
           SWAP(obj->vlist_local[vertex].x, obj->vlist_local[vertex].z, temp_f);

        if (vertex_flags & VERTEX_FLAGS_SWAP_XY)
           SWAP(obj->vlist_local[vertex].x, obj->vlist_local[vertex].y, temp_f);

        // scale vertices
        if (scale)
           {
           obj->vlist_local[vertex].x*=scale->x;
           obj->vlist_local[vertex].y*=scale->y;
           obj->vlist_local[vertex].z*=scale->z;
           } // end if

          Write_Error("\nVertex %d = %f, %f, %f, %f", vertex,
                                           obj->vlist_local[vertex].x, 
                                           obj->vlist_local[vertex].y, 
                                           obj->vlist_local[vertex].z,
                                           obj->vlist_local[vertex].w);

         // set point field in this vertex, we need that at least 
         SET_BIT(obj->vlist_local[vertex].attr, VERTEX4DTV1_ATTR_POINT);

        // found vertex, break out of while for next pass
        break;

        } // end if

    } // end while

    } // end for vertex

// compute average and max radius
Compute_OBJECT4DV2_Radius(obj);

Write_Error("\nObject average radius = %f, max radius = %f", 
            obj->avg_radius, obj->max_radius);


// step 8: get number of texture vertices
while(1)
     {
     // get the next line, we are looking for "Texture Vertices ddd" 
     if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
        {
        Write_Error("'Texture Vertices' line not found in .COB file %s.", filename);
        return(0);
        } // end if
    
     // check for pattern?  
     if (parser.Pattern_Match(parser.buffer, "['Texture'] ['Vertices'] [i]") )
        {
        // simply extract the number of texture vertices from the pattern matching 
        // output arrays
        num_texture_vertices = parser.pints[0];

        Write_Error("\nCOB Reader Texture Vertices: %d", num_texture_vertices);
        break;    
 
        } // end if

     } // end while

// Step 9: load the texture vertex list in format "U V"
// "d.d d.d"
 for (int tvertex = 0; tvertex < num_texture_vertices; tvertex++)
     {
     // hunt for texture
     while(1)
     {
     // get the next vertex
     if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
        {
        Write_Error("\nTexture Vertex list ended abruptly! in .COB file %s.", filename);
        return(0);
        } // end if
    
     // check for pattern?  
     if (parser.Pattern_Match(parser.buffer, "[f] [f]"))
        {
        // at this point we have the U V in the the pfloats array locations 0,1 for this 
        // texture vertex, store in texture coordinate list
        // note texture coords are in 0..1 format, and must be scaled to texture size
        // after we load the texture
        obj->tlist[tvertex].x = parser.pfloats[0]; 
        obj->tlist[tvertex].y = parser.pfloats[1];

        Write_Error("\nTexture Vertex %d: U=%f, V=%f", tvertex,
                                          obj->tlist[tvertex].x, 
                                          obj->tlist[tvertex].y );

        // found vertex, break out of while for next pass
        break;

        } // end if

       } // end while

   } // end for

// when we load in the polygons then we will copy the texture vertices into the polygon
// vertices assuming that each vertex has a SINGLE texture coordinate, this means that
// you must NOT use multiple textures on an object! in other words think "skin" this is
// inline with Quake II md2 format, in 99% of the cases a single object can be textured
// with a single skin and the texture coordinates can be unique for each vertex and 1:1


int poly_material[OBJECT4DV2_MAX_POLYS]; // this holds the material index for each polygon
                                         // we need these indices since when reading the file
                                         // we read the polygons BEFORE the materials, so we need
                                         // this data, so we can go back later and extract the material
                                         // that each poly WAS assigned and get the colors out, since
                                         // objects and polygons do not currently support materials


int material_index_referenced[MAX_MATERIALS];   // used to track if an index has been used yet as a material 
                                                // reference. since we don't know how many materials, we need
                                                // a way to count them up, but if we have seen a material reference
                                                // more than once then we don't increment the total number of materials
                                                // this array is for this

// clear out reference array
memset(material_index_referenced,0, sizeof(material_index_referenced));


// step 10: load in the polygons
// poly list starts off with:
// "Faces ddd:"
while(1)
     {
     // get next line
     if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
        {
        Write_Error("\n'Faces' line not found in .COB file %s.", filename);
        return(0);
        } // end if
    
     // check for pattern?  
     if (parser.Pattern_Match(parser.buffer, "['Faces'] [i]"))
        {
        Write_Error("\nCOB Reader found face list in .COB file %s.", filename);

        // finally set number of polys
        obj->num_polys = parser.pints[0];

        break;
        } // end if
     } // end while

// now read each face in format:
// Face verts nn flags ff mat mm
// the nn is the number of vertices, always 3
// the ff is the flags, unused for now, has to do with holes
// the mm is the material index number 


int poly_surface_desc    = 0; // ASC surface descriptor/material in this case
int poly_num_verts       = 0; // number of vertices for current poly (always 3)
int num_materials_object = 0; // number of materials for this object

for (int poly=0; poly < obj->num_polys; poly++)
    {
    Write_Error("\nPolygon %d:", poly);
    // hunt until next face is found
    while(1)
         {
         // get the next polygon face
         if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
            {
            Write_Error("\nface list ended abruptly! in .COB file %s.", filename);
            return(0);
            } // end if
     
         // check for pattern?  
         if (parser.Pattern_Match(parser.buffer, "['Face'] ['verts'] [i] ['flags'] [i] ['mat'] [i]"))
            {
            // at this point we have the number of vertices for the polygon, the flags, and it's material index
            // in the integer output array locations 0,1,2

            // store the material index for this polygon for retrieval later, but make sure adjust the 
            // the index to take into consideration that the data in parser.pints[2] is 0 based, and we need
            // an index relative to the entire library, so we simply need to add num_materials to offset the 
            // index properly, but we will leave this reference zero based for now... and fix up later
            poly_material[poly] = parser.pints[2];

            // update the reference array
            if (material_index_referenced[ poly_material[poly] ] == 0)
               {
               // mark as referenced
               material_index_referenced[ poly_material[poly] ] = 1;

               // increment total number of materials for this object
               num_materials_object++;
               } // end if        


            // test if number of vertices is 3
            if (parser.pints[0]!=3)
               {
               Write_Error("\nface not a triangle! in .COB file %s.", filename);
               return(0);
               } // end if

           // now read out the vertex indices and texture indices format:
           // <vindex0, tindex0>  <vindex1, tindex1> <vindex1, tindex1> 
           if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
              {
              Write_Error("\nface list ended abruptly! in .COB file %s.", filename);
              return(0);
              } // end if

           // lets replace ",<>" with ' ' to make extraction easy
           ReplaceChars(parser.buffer, parser.buffer, ",<>",' ');      
           parser.Pattern_Match(parser.buffer, "[i] [i] [i] [i] [i] [i]");
 
           // 0,2,4 holds vertex indices
           // 1,3,5 holds texture indices

           
          // insert polygon, check for winding order invert
          if (vertex_flags & VERTEX_FLAGS_INVERT_WINDING_ORDER)
             {     
             poly_num_verts           = 3;
             obj->plist[poly].vert[0] = parser.pints[4];
             obj->plist[poly].vert[1] = parser.pints[2];
             obj->plist[poly].vert[2] = parser.pints[0];

             // now copy the texture coordinates into the vertices, this
             // may not be needed if the polygon doesn't have texture mapping
             // enabled, etc., 

             // so here's the deal the texture coordinates that 
             // map to vertex 0,1,2 have indices stored in the odd
             // numbered pints[] locations, so we simply need to copy
             // the right texture coordinate into the right vertex
             obj->plist[poly].text[0] = parser.pints[5];
             obj->plist[poly].text[1] = parser.pints[3];
             obj->plist[poly].text[2] = parser.pints[1];
             
             Write_Error("\nAssigning texture vertex index %d [%f, %f] to mesh vertex %d",
                                                                   parser.pints[5],
                                                                   obj->tlist[ parser.pints[5] ].x, 
                                                                   obj->tlist[ parser.pints[5] ].y,
                                                                   obj->plist[poly].vert[0] );

             Write_Error("\nAssigning texture vertex index %d [%f, %f] to mesh vertex %d",
                                                                   parser.pints[3],
                                                                   obj->tlist[ parser.pints[3] ].x, 
                                                                   obj->tlist[ parser.pints[3] ].y,
                                                                   obj->plist[poly].vert[1] );

             Write_Error("\nAssigning texture vertex index %d [%f, %f] to mesh vertex %d",
                                                                   parser.pints[1],
                                                                   obj->tlist[ parser.pints[1] ].x, 
                                                                   obj->tlist[ parser.pints[1] ].y,
                                                                   obj->plist[poly].vert[2] );

   

             } // end if
          else
             { // leave winding order alone
             poly_num_verts           = 3;
             obj->plist[poly].vert[0] = parser.pints[0];
             obj->plist[poly].vert[1] = parser.pints[2];
             obj->plist[poly].vert[2] = parser.pints[4];

             // now copy the texture coordinates into the vertices, this
             // may not be needed if the polygon doesn't have texture mapping
             // enabled, etc., 


             // so here's the deal the texture coordinates that 
             // map to vertex 0,1,2 have indices stored in the odd
             // numbered pints[] locations, so we simply need to copy
             // the right texture coordinate into the right vertex
             obj->plist[poly].text[0] = parser.pints[1];
             obj->plist[poly].text[1] = parser.pints[3];
             obj->plist[poly].text[2] = parser.pints[5];
             
             Write_Error("\nAssigning texture vertex index %d [%f, %f] to mesh vertex %d",
                                                                   parser.pints[1],
                                                                   obj->tlist[ parser.pints[1] ].x, 
                                                                   obj->tlist[ parser.pints[1] ].y,
                                                                   obj->plist[poly].vert[0] );

             Write_Error("\nAssigning texture vertex index %d [%f, %f] to mesh vertex %d",
                                                                   parser.pints[3],
                                                                   obj->tlist[ parser.pints[3] ].x, 
                                                                   obj->tlist[ parser.pints[3] ].y,
                                                                   obj->plist[poly].vert[1] );

             Write_Error("\nAssigning texture vertex index %d [%f, %f] to mesh vertex %d",
                                                                   parser.pints[5],
                                                                   obj->tlist[ parser.pints[5] ].x, 
                                                                   obj->tlist[ parser.pints[5] ].y,
                                                                   obj->plist[poly].vert[2] );

             } // end else

          // point polygon vertex list to object's vertex list
          // note that this is redundant since the polylist is contained
          // within the object in this case and its up to the user to select
          // whether the local or transformed vertex list is used when building up
          // polygon geometry, might be a better idea to set to NULL in the context
          // of polygons that are part of an object
          obj->plist[poly].vlist = obj->vlist_local; 

          // set texture coordinate list, this is needed
          obj->plist[poly].tlist = obj->tlist;


          // set polygon to active
          obj->plist[poly].state = POLY4DV2_STATE_ACTIVE;    

          // found the face, break out of while for another pass
          break;

          } // end if
 
       } // end while      

       Write_Error("\nLocal material Index=%d, total materials for object = %d, vert_indices [%d, %d, %d]", 
                                                                                poly_material[poly],
                                                                                num_materials_object,
                                                                                obj->plist[poly].vert[0],
                                                                                obj->plist[poly].vert[1],
                                                                                obj->plist[poly].vert[2]);       
    } // end for poly

// now find materials!!! and we are out of here!
for (int curr_material = 0; curr_material < num_materials_object; curr_material++)
    {
    // hunt for the material header "mat# ddd"
    while(1)
    {
    // get the next polygon material 
    if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
       {
       Write_Error("\nmaterial list ended abruptly! in .COB file %s.", filename);
       return(0);
       } // end if
     
    // check for pattern?  
    if (parser.Pattern_Match(parser.buffer, "['mat#'] [i]") )
       {
       // extract the material that is being defined 
       int material_index = parser.pints[0];

       // get color of polygon, although it might be irrelevant for a textured surface
       while(1)
            {
            // get the next line
            if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
               {
               Write_Error("\nRGB color ended abruptly! in .COB file %s.", filename);
               return(0);
               } // end if

               // replace the , comma's if there are any with spaces
               ReplaceChars(parser.buffer, parser.buffer, ",", ' ', 1);

               // look for "rgb float,float,float"
               if (parser.Pattern_Match(parser.buffer, "['rgb'] [f] [f] [f]") )
                  {
                  // extract data and store color in material libary
                  // pfloats[] 0,1,2,3, has data
                  materials[material_index + num_materials].color.r = (int)(parser.pfloats[0]*255 + 0.5);
                  materials[material_index + num_materials].color.g = (int)(parser.pfloats[1]*255 + 0.5);
                  materials[material_index + num_materials].color.b = (int)(parser.pfloats[2]*255 + 0.5);

                  break; // while looking for rgb
                  } // end if

             } // end while    

       // extract out lighting constants for the heck of it, they are on a line like this:
       // "alpha float ka float ks float exp float ior float"
       // alpha is transparency           0 - 1
       // ka is ambient coefficient       0 - 1
       // ks is specular coefficient      0 - 1
       // exp is highlight power exponent 0 - 1
       // ior is index of refraction (unused)

       // although our engine will have minimal support for these, we might as well get them
       while(1)
            {
            // get the next line
            if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
               {
               Write_Error("\nmaterial properties ended abruptly! in .COB file %s.", filename);
               return(0);
               } // end if

            // look for "alpha float ka float ks float exp float ior float"
            if (parser.Pattern_Match(parser.buffer, "['alpha'] [f] ['ka'] [f] ['ks'] [f] ['exp'] [f]") )
               {
               // extract data and store in material libary
               // pfloats[] 0,1,2,3, has data
               materials[material_index + num_materials].color.a  = (UCHAR)(parser.pfloats[0]*255 + 0.5);
               materials[material_index + num_materials].ka       = parser.pfloats[1];
               materials[material_index + num_materials].kd       = 1; // hard code for now
               materials[material_index + num_materials].ks       = parser.pfloats[2];
               materials[material_index + num_materials].power    = parser.pfloats[3];
 
               // compute material reflectivities in pre-multiplied format to help engine
               for (int rgb_index=0; rgb_index < 3; rgb_index++)
                    {
                    // ambient reflectivity
                    materials[material_index + num_materials].ra.rgba_M[rgb_index] = 
                              ( (UCHAR)(materials[material_index + num_materials].ka * 
                                (float)materials[material_index + num_materials].color.rgba_M[rgb_index] + 0.5) );

  
                    // diffuse reflectivity
                    materials[material_index + num_materials].rd.rgba_M[rgb_index] = 
                              ( (UCHAR)(materials[material_index + num_materials].kd * 
                                (float)materials[material_index + num_materials].color.rgba_M[rgb_index] + 0.5) );

  
                    // specular reflectivity
                    materials[material_index + num_materials].rs.rgba_M[rgb_index] = 
                              ( (UCHAR)(materials[material_index + num_materials].ks * 
                                (float)materials[material_index + num_materials].color.rgba_M[rgb_index] + 0.5) );

                     } // end for rgb_index

               break;
               } // end if

             } // end while    

       // now we need to know the shading model, it's a bit tricky, we need to look for the lines
       // "Shader class: color" first, then after this line is:
       // "Shader name: "xxxxxx" (xxxxxx) "
       // where the xxxxx part will be "plain color" and "plain" for colored polys 
       // or "texture map" and "caligari texture"  for textures
       // THEN based on that we hunt for "Shader class: reflectance" which is where the type
       // of shading is encoded, we look for the "Shader name: "xxxxxx" (xxxxxx) " again, 
       // and based on it's value we map it to our shading system as follows:
       // "constant" -> MATV1_ATTR_SHADE_MODE_CONSTANT 
       // "matte"    -> MATV1_ATTR_SHADE_MODE_FLAT
       // "plastic"  -> MATV1_ATTR_SHADE_MODE_GOURAUD
       // "phong"    -> MATV1_ATTR_SHADE_MODE_FASTPHONG 
       // and in the case that in the "color" class, we found a "texture map" then the "shading mode" is
       // "texture map" -> MATV1_ATTR_SHADE_MODE_TEXTURE 
       // which must be logically or'ed with the other previous modes
 
       //  look for the "shader class: color"
       while(1)
            {
            // get the next line
            if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
               {
               Write_Error("\nshader class ended abruptly! in .COB file %s.", filename);
               return(0);
               } // end if
       
            if (parser.Pattern_Match(parser.buffer, "['Shader'] ['class:'] ['color']") )
               {
               break;
               } // end if

             } // end while
          
       // now look for the shader name for this class
       // Shader name: "plain color" or Shader name: "texture map"
       while(1)
            {
            // get the next line
            if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
               {
               Write_Error("\nshader name ended abruptly! in .COB file %s.", filename);
               return(0);
               } // end if

            // replace the " with spaces
            ReplaceChars(parser.buffer, parser.buffer, "\"", ' ', 1);

            // is this a "plain color" poly?
            if (parser.Pattern_Match(parser.buffer, "['Shader'] ['name:'] ['plain'] ['color']") )
               {
               // not much to do this is default, we need to wait for the reflectance type
               // to tell us the shading mode

               break;
               } // end if

            // is this a "texture map" poly?
            if (parser.Pattern_Match(parser.buffer, "['Shader'] ['name:'] ['texture'] ['map']") )
               {
               // set the texture mapping flag in material
               SET_BIT(materials[material_index + num_materials].attr, MATV1_ATTR_SHADE_MODE_TEXTURE);
      
               // almost done, we need the file name of the darn texture map, its in this format:
               // file name: string "D:\Source\..\models\textures\wall01.bmp"
          
               // of course the filename in the quotes will change
               // so lets hunt until we find it...
               while(1)
                    {
                    // get the next line
                    if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
                       {
                       Write_Error("\ncouldnt find texture name! in .COB file %s.", filename);
                       return(0);
                       } // end if

                    // replace the " with spaces
                    ReplaceChars(parser.buffer, parser.buffer, "\"", ' ', 1);

                    // is this the file name?
                    if (parser.Pattern_Match(parser.buffer, "['file'] ['name:'] ['string']") )
                       {
                       // and save the FULL filename (useless though since its the path from the 
                       // machine that created it, but later we might want some of the info).
                       // filename and path starts at char position 19, 0 indexed
                       memcpy(materials[material_index + num_materials].texture_file, &parser.buffer[18], strlen(parser.buffer) - 18 + 2 );

                       // the OBJECT4DV2 is only allowed a single texture, although we are loading in all
                       // the materials, if this is the first texture map, load it, and set a flag disallowing
                       // any more texture loads for the object
                       if (!obj->texture)
                          {
                          // step 1: allocate memory for bitmap
                          obj->texture = (BITMAP_IMAGE_PTR)malloc(sizeof(BITMAP_IMAGE));

                          // load the texture, just use the final file name and the absolute global 
                          // texture path
                          char filename[80];
                          char path_filename[80];
                          // get the filename                     
                          Extract_Filename_From_Path(materials[material_index + num_materials].texture_file, filename);

                          // build the filename with root path
                          strcpy(path_filename, texture_path);
                          strcat(path_filename, filename);

                          // buffer now holds final texture path and file name
                          // load the bitmap(8/16 bit)
                          Load_Bitmap_File(&bitmap16bit, path_filename);

                          // create a proper size and bitdepth bitmap
                          Create_Bitmap(obj->texture,0,0,
                                        bitmap16bit.bitmapinfoheader.biWidth,
                                        bitmap16bit.bitmapinfoheader.biHeight,
                                        bitmap16bit.bitmapinfoheader.biBitCount);
                          
                          // load the bitmap image (later make this 8/16 bit)
                          if (obj->texture->bpp == 16)
                             Load_Image_Bitmap16(obj->texture, &bitmap16bit,0,0,BITMAP_EXTRACT_MODE_ABS);
                          else
                             {
                             Load_Image_Bitmap(obj->texture, &bitmap16bit,0,0,BITMAP_EXTRACT_MODE_ABS);
                             } // end else 8 bit

                          // done, so unload the bitmap
                          Unload_Bitmap_File(&bitmap16bit);

                          // flag object as having textures
                          SET_BIT(obj->attr, OBJECT4DV2_ATTR_TEXTURES);

                          } // end if

                       break;
                       } // end if

                    } // end while

                break;
                } // end if

            } // end while 


       ////////////////////////////////////////////////////////////////////////////////////////////
       // ADDED CODE FOR TRANSPARENCY AND ALPHA BLENDING //////////////////////////////////////////
       ////////////////////////////////////////////////////////////////////////////////////////////
       // Now we need to know if there is any transparency for the material
       // we have decided to encoded this in the shader class: transparency :)
       // also, you must use the "filter" shader, and then set the RGB color to
       // the level of transparency you want, 0,0,0 means totally transparent
       // 255,255,255 means totally opaque, so we are looking for something like
       // this:
       // Shader class: transparency
       // Shader name: "filter" (plain)
       // Number of parameters: 1
       // colour: color (146, 146, 146)
       // 
       // and if there isn't transparency then we will see this:
       //
       // Shader class: transparency
       // Shader name: "none" (none)
       // Number of parameters: 0
       // 
       // now, since we aren't doing anykind of RGB transparency, we are only concerned
       // with the overall value, so the way, I am going to do this is to look at the 
       // 3 values of R, G, B, and use the highest one as the final alpha/transparency 
       // value, so a value of 255, 255, 255 with be 100% alpha or totally opaque
      
       //  look for the "Shader class: transparency"
       while(1)
            {
            // get the next line
            if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
               {
               Write_Error("\nshader transparency class not found in .COB file %s.", filename);
               return(0);
               } // end if

            // look for "Shader class: transparency"
            if (parser.Pattern_Match(parser.buffer, "['Shader'] ['class:'] ['transparency']") )
               {
               // now we know the next "shader name" is what we are looking for so, break

               break;
               } // end if

             } // end while    

        while(1)
             {
             // get the next line
             if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
                {
                Write_Error("\nshader name ended abruptly! in .COB file %s.", filename);
                return(0);
                } // end if
         
             // get rid of those quotes
             ReplaceChars(parser.buffer, parser.buffer, "\"",' ',1);

             // did we find the name?
            if (parser.Pattern_Match(parser.buffer, "['Shader'] ['name:'] [s>0]" ) )
               {
               // figure out if transparency is enabled
               if (strcmp(parser.pstrings[2], "none") == 0)
                  {
                  // disable the alpha bit and write 0 alpha
                  RESET_BIT(materials[material_index + num_materials].attr, MATV1_ATTR_TRANSPARENT);
    
                  // set alpha to 0, unused
                  materials[material_index + num_materials].color.a = 0;

                  } // end if
               else
               if (strcmp(parser.pstrings[2], "filter") == 0)
                  {
                  // enable the alpha bit and write the alpha level
                  SET_BIT(materials[material_index + num_materials].attr, MATV1_ATTR_TRANSPARENT);

                  // now search for color line to extract alpha level
                  //  look for the "Shader class: transparency"
                  while(1)
                       {
                       // get the next line
                       if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
                          {
                          Write_Error("\ntransparency color not found in .COB file %s.", filename);
                          return(0);
                          } // end if

                          // get rid of extraneous characters
                          ReplaceChars(parser.buffer, parser.buffer, ":(,)",' ',1);

                        // look for colour: color (146, 146, 146)
                        if (parser.Pattern_Match(parser.buffer, "['colour'] ['color'] [i] [i] [i]") )
                           {
                           // set the alpha level to the highest value
                           int max_alpha = MAX(parser.pints[0], parser.pints[1]);
                           max_alpha = MAX(max_alpha, parser.pints[2]);

                           // set alpha value
                           materials[material_index + num_materials].color.a = 
                                                 (int)( (float)max_alpha/255 * (float)(NUM_ALPHA_LEVELS-1) + (float)0.5);
                           
                           // clamp
                           if (materials[material_index + num_materials].color.a >= NUM_ALPHA_LEVELS)
                               materials[material_index + num_materials].color.a = NUM_ALPHA_LEVELS-1;

                           break;
                           } // end if
            
                        } // end while    

                  } // end if

            break;
            } // end if

         } // end while
       //////////////////////////////////////////////////////////////////////////////////////////////



       // alright, finally! Now we need to know what the actual shader type, now in the COB format
       // I have decided that in the "reflectance" class that's where we will look at what kind
       // of shader is supposed to be used on the polygon

       //  look for the "Shader class: reflectance"
       while(1)
            {
            // get the next line
            if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
               {
               Write_Error("\nshader reflectance class not found in .COB file %s.", filename);
               return(0);
               } // end if

            // look for "Shader class: reflectance"
            if (parser.Pattern_Match(parser.buffer, "['Shader'] ['class:'] ['reflectance']") )
               {
               // now we know the next "shader name" is what we are looking for so, break

               break;
               } // end if

             } // end while    

        // looking for "Shader name: "xxxxxx" (xxxxxx) " again, 
        // and based on it's value we map it to our shading system as follows:
        // "constant" -> MATV1_ATTR_SHADE_MODE_CONSTANT 
        // "matte"    -> MATV1_ATTR_SHADE_MODE_FLAT
        // "plastic"  -> MATV1_ATTR_SHADE_MODE_GOURAUD
        // "phong"    -> MATV1_ATTR_SHADE_MODE_FASTPHONG 
        // and in the case that in the "color" class, we found a "texture map" then the "shading mode" is
        // "texture map" -> MATV1_ATTR_SHADE_MODE_TEXTURE 
        // which must be logically or'ed with the other previous modes
        while(1)
             {
             // get the next line
             if (!parser.Getline(PARSER_STRIP_EMPTY_LINES | PARSER_STRIP_WS_ENDS))
                {
                Write_Error("\nshader name ended abruptly! in .COB file %s.", filename);
                return(0);
                } // end if
         
             // get rid of those quotes
             ReplaceChars(parser.buffer, parser.buffer, "\"",' ',1);

             // did we find the name?
            if (parser.Pattern_Match(parser.buffer, "['Shader'] ['name:'] [s>0]" ) )
               {
               // figure out which shader to use
               if (strcmp(parser.pstrings[2], "constant") == 0)
                  {
                  // set the shading mode flag in material
                  SET_BIT(materials[material_index + num_materials].attr, MATV1_ATTR_SHADE_MODE_CONSTANT);
                  } // end if
               else
               if (strcmp(parser.pstrings[2], "matte") == 0)
                  {
                  // set the shading mode flag in material
                  SET_BIT(materials[material_index + num_materials].attr, MATV1_ATTR_SHADE_MODE_FLAT);
                  } // end if
               else
               if (strcmp(parser.pstrings[2], "plastic") == 0)
                  {
                  // set the shading mode flag in material
                  SET_BIT(materials[curr_material + num_materials].attr, MATV1_ATTR_SHADE_MODE_GOURAUD);
                  } // end if
               else
               if (strcmp(parser.pstrings[2], "phong") == 0)
                  {
                  // set the shading mode flag in material
                  SET_BIT(materials[material_index + num_materials].attr, MATV1_ATTR_SHADE_MODE_FASTPHONG);
                  } // end if
               else
                  {
                  // set the shading mode flag in material
                  SET_BIT(materials[material_index + num_materials].attr, MATV1_ATTR_SHADE_MODE_FLAT);
                  } // end else

            break;
            } // end if

         } // end while
          
       // found the material, break out of while for another pass
       break;

       } // end if found material

    } // end while looking for mat#1

    } // end for curr_material

// before performing texture application we need to determine if the texture on this
// object is mipmapped, if so we need to create a mip map chain, and set the proper 
// attributes in both the object and the polygons themselves
if (mipmap==1)
   {
   // set the mipmap bit in the object
   SET_BIT(obj->attr, OBJECT4DV2_ATTR_MIPMAP);

   // now with the base texture as level d=0 call the mipmap chain generator
   Generate_Mipmaps(obj->texture, (BITMAP_IMAGE_PTR *)&obj->texture); // (BITMAP_IMAGE_PTR *)&obj->texture);
   } // end if 

// at this point poly_material[] holds all the indices for the polygon materials (zero based, so they need fix up)
// and we must access the materials array to fill in each polygon with the polygon color, etc.
// now that we finally have the material libary loaded
for (int curr_poly = 0; curr_poly < obj->num_polys; curr_poly++)
    {
    Write_Error("\nfixing poly material %d from index %d to index %d", curr_poly, 
                                                                       poly_material[curr_poly],
                                                                       poly_material[curr_poly] + num_materials  );
    // fix up offset
    poly_material[curr_poly]  = poly_material[curr_poly] + num_materials;

    // we need to know what color depth we are dealing with, so check
    // the bits per pixel, this assumes that the system has already
    // made the call to DDraw_Init() or set the bit depth
    if (screen_bpp == 16)
       {
       // cool, 16 bit mode
       SET_BIT(obj->plist[curr_poly].attr,POLY4DV1_ATTR_RGB16);

       // test if this is a textured poly, if so override the color to WHITE,
       // so we get maximum reflection in lighting stage
       if (materials[ poly_material[curr_poly] ].attr & MATV1_ATTR_SHADE_MODE_TEXTURE)
           obj->plist[curr_poly].color = RGB16Bit(255,255,255);
       else
           obj->plist[curr_poly].color = RGB16Bit(materials[ poly_material[curr_poly] ].color.r, 
                                                  materials[ poly_material[curr_poly] ].color.g, 
                                                  materials[ poly_material[curr_poly] ].color.b);
       Write_Error("\nPolygon 16-bit");
       } // end
    else
       {
       // 8 bit mode
       SET_BIT(obj->plist[curr_poly].attr,POLY4DV1_ATTR_8BITCOLOR);

       // test if this is a textured poly, if so override the color to WHITE,
       // so we get maximum reflection in lighting stage
       if (materials[ poly_material[curr_poly] ].attr & MATV1_ATTR_SHADE_MODE_TEXTURE)
          obj->plist[curr_poly].color = RGBto8BitIndex(255, 255, 255, palette, 0);
       else
          obj->plist[curr_poly].color = RGBto8BitIndex(materials[ poly_material[curr_poly] ].color.r,
                                                       materials[ poly_material[curr_poly] ].color.g,
                                                       materials[ poly_material[curr_poly] ].color.b,
                                                       palette, 0);

       Write_Error("\nPolygon 8-bit, index=%d", obj->plist[curr_poly].color);
       } // end else

     // now set all the shading flags
     // figure out which shader to use
     if (materials[ poly_material[curr_poly] ].attr & MATV1_ATTR_SHADE_MODE_CONSTANT)
        {
        // set shading mode
        SET_BIT(obj->plist[curr_poly].attr, POLY4DV2_ATTR_SHADE_MODE_CONSTANT);
        } // end if
     else
     if (materials[ poly_material[curr_poly] ].attr & MATV1_ATTR_SHADE_MODE_FLAT)
        {
        // set shading mode
        SET_BIT(obj->plist[curr_poly].attr, POLY4DV2_ATTR_SHADE_MODE_FLAT);
        } // end if
     else
     if (materials[ poly_material[curr_poly] ].attr & MATV1_ATTR_SHADE_MODE_GOURAUD)
        {
        // set shading mode
        SET_BIT(obj->plist[curr_poly].attr, POLY4DV2_ATTR_SHADE_MODE_GOURAUD);

        // going to need vertex normals!
        SET_BIT(obj->vlist_local[ obj->plist[curr_poly].vert[0] ].attr, VERTEX4DTV1_ATTR_NORMAL); 
        SET_BIT(obj->vlist_local[ obj->plist[curr_poly].vert[1] ].attr, VERTEX4DTV1_ATTR_NORMAL); 
        SET_BIT(obj->vlist_local[ obj->plist[curr_poly].vert[2] ].attr, VERTEX4DTV1_ATTR_NORMAL); 
        } // end if
     else
     if (materials[ poly_material[curr_poly] ].attr & MATV1_ATTR_SHADE_MODE_FASTPHONG)
        {
        // set shading mode
        SET_BIT(obj->plist[curr_poly].attr, POLY4DV2_ATTR_SHADE_MODE_FASTPHONG);

        // going to need vertex normals!
        SET_BIT(obj->vlist_local[ obj->plist[curr_poly].vert[0] ].attr, VERTEX4DTV1_ATTR_NORMAL); 
        SET_BIT(obj->vlist_local[ obj->plist[curr_poly].vert[1] ].attr, VERTEX4DTV1_ATTR_NORMAL); 
        SET_BIT(obj->vlist_local[ obj->plist[curr_poly].vert[2] ].attr, VERTEX4DTV1_ATTR_NORMAL); 
        } // end if
     else
        {
        // set shading mode to default flat
        SET_BIT(obj->plist[curr_poly].attr, POLY4DV2_ATTR_SHADE_MODE_FLAT);
        } // end if

     if (materials[ poly_material[curr_poly] ].attr & MATV1_ATTR_SHADE_MODE_TEXTURE)
        {
        // set shading mode
        SET_BIT(obj->plist[curr_poly].attr, POLY4DV2_ATTR_SHADE_MODE_TEXTURE);

        // apply texture to this polygon
        obj->plist[curr_poly].texture = obj->texture;

        // if the object was mipmapped this above assignment will just point the texture to
        // the mipmap chain array, however we still need to set the polygon attribute, so 
        // we know the poly is mip mapped, since once its in the rendering list we will have
        // no idea
        if (mipmap)
           SET_BIT(obj->plist[curr_poly].attr,POLY4DV2_ATTR_MIPMAP);

        // set texture coordinate attributes
        SET_BIT(obj->vlist_local[ obj->plist[curr_poly].vert[0] ].attr, VERTEX4DTV1_ATTR_TEXTURE); 
        SET_BIT(obj->vlist_local[ obj->plist[curr_poly].vert[1] ].attr, VERTEX4DTV1_ATTR_TEXTURE); 
        SET_BIT(obj->vlist_local[ obj->plist[curr_poly].vert[2] ].attr, VERTEX4DTV1_ATTR_TEXTURE); 

        } // end if

      // now test for alpha channel
     if (materials[ poly_material[curr_poly] ].attr & MATV1_ATTR_TRANSPARENT)
        {
        // set the value of the alpha channel, upper 8-bits of color will be used to hold it
        // lets hope this doesn't break the lighting engine!!!!
        obj->plist[curr_poly].color+= (materials[ poly_material[curr_poly] ].color.a << 24);

        // set the alpha flag in polygon  
        SET_BIT(obj->plist[curr_poly].attr, POLY4DV2_ATTR_TRANSPARENT);

        } // end if

      // set the material mode to ver. 1.0 emulation (for now only!!!)
      SET_BIT(obj->plist[curr_poly].attr, POLY4DV2_ATTR_DISABLE_MATERIAL);

    } // end for curr_poly

// local object materials have been added to database, update total materials in system
num_materials+=num_materials_object;

// now fix up all texture coordinates
if (obj->texture)
   {
    for (tvertex = 0; tvertex < num_texture_vertices; tvertex++)
        {
        // step 1: scale the texture coordinates by the texture size in lod = 0
        // make sure to access mipmap chain if needed!!!!!!!
        int texture_size;

        if (!mipmap)
           texture_size = obj->texture->width; 
        else // must be a mipmap chain, cast pointer to ptr to array of pointers and access elem 0
           texture_size = ((BITMAP_IMAGE_PTR *)(obj->texture))[0]->width;

        // scale 0..1 to 0..texture_size-1
        obj->tlist[tvertex].x *= (texture_size-1); 
        obj->tlist[tvertex].y *= (texture_size-1);

        // now test for vertex transformation flags
        if (vertex_flags & VERTEX_FLAGS_INVERT_TEXTURE_U)  
           {
           obj->tlist[tvertex].x = (texture_size-1) - obj->tlist[tvertex].x;
           } // end if

        if (vertex_flags & VERTEX_FLAGS_INVERT_TEXTURE_V)  
           {
           obj->tlist[tvertex].y = (texture_size-1) - obj->tlist[tvertex].y;
           } // end if

        if (vertex_flags & VERTEX_FLAGS_INVERT_SWAP_UV)  
           {
           float temp;
           SWAP(obj->tlist[tvertex].x, obj->tlist[tvertex].y, temp);
           } // end if

        } // end for

    } // end if there was a texture loaded for this object

#ifdef DEBUG_ON
for (curr_material = 0; curr_material < num_materials; curr_material++)
    {
    Write_Error("\nMaterial %d", curr_material);

    Write_Error("\nint  state    = %d", materials[curr_material].state);
    Write_Error("\nint  id       = %d", materials[curr_material].id);
    Write_Error("\nchar name[64] = %s", materials[curr_material].name);
    Write_Error("\nint  attr     = %d", materials[curr_material].attr); 
    Write_Error("\nint r         = %d", materials[curr_material].color.r); 
    Write_Error("\nint g         = %d", materials[curr_material].color.g); 
    Write_Error("\nint b         = %d", materials[curr_material].color.b); 
    Write_Error("\nint alpha     = %d", materials[curr_material].color.a);
    Write_Error("\nint color     = %d", materials[curr_material].attr); 
    Write_Error("\nfloat ka      = %f", materials[curr_material].ka); 
    Write_Error("\nkd            = %f", materials[curr_material].kd); 
    Write_Error("\nks            = %f", materials[curr_material].ks); 
    Write_Error("\npower         = %f", materials[curr_material].power);
    Write_Error("\nchar texture_file = %s\n", materials[curr_material].texture_file);
    } // end for curr_material
#endif

// now that we know the correct number of polygons, we must allocate memory for them
// and fix up the object, this is a hack, but the file formats are so stupid by not
// all starting with NUM_VERTICES, NUM_POLYGONS -- that would make everyone's life
// easier!

#if 0

// step 1: allocate memory for the polygons
POLY4DV2_PTR plist_temp = NULL;

// allocate memory for polygon list, the correct number of polys was overwritten
// into the object during parsing, so we can use the num_polys field
if (!(plist_temp = (POLY4DV2_PTR)malloc(sizeof(POLY4DV2)*obj->num_polys)))
   return(0);

// step 2:  now copy the polygons into the correct list
memcpy((void *)plist_temp, (void *)obj->plist, sizeof(POLY4DV2));

// step 3: now free the old memory and fix the pointer
free(obj->plist);

// now fix the pointer
obj->plist = plist_temp;

#endif

// compute the polygon normal lengths
Compute_OBJECT4DV2_Poly_Normals(obj);

// compute vertex normals for any gouraud shaded polys
Compute_OBJECT4DV2_Vertex_Normals(obj);

// return success
return(1);

} // end Load_OBJECT4DV2_COB2

////////////////////////////////////////////////////////////////////////////////////////

int Generate_Terrain2_OBJECT4DV2(OBJECT4DV2_PTR obj,     // pointer to object
                                float twidth,            // width in world coords on x-axis
                                float theight,           // height (length) in world coords on z-axis
                                float vscale,           // vertical scale of terrain
                                char *height_map_file,  // filename of height bitmap encoded in 256 colors
                                char *texture_map_file, // filename of texture map
                                int rgbcolor,           // color of terrain if no texture        
                                VECTOR4D_PTR pos,       // initial position
                                VECTOR4D_PTR rot,       // initial rotations
                                int poly_attr,          // the shading attributes we would like
                                float sea_level,        // height of sea level
                                int alpha)              // alpha level to make all polys below sea level
        
{
// this function generates a terrain of width x height in the x-z plane
// the terrain is defined by a height field encoded as color values 
// of a 256 color texture, 0 being ground level 255 being 1.0, this value
// is scaled by vscale for the height of each point in the height field
// the height field generated will be composed of triangles where each vertex
// in the height field is derived from the height map, thus if the height map
// is 256 x 256 points then the final mesh will be (256-1) x (256-1) polygons 
// with a absolute world size of width x height (in the x-z plane)
// also if there is a texture map file then it will be mapped onto the terrain
// and texture coordinates will be generated
// this version allows transparency control for "sea level", if transparency is 
// desired to create transparent water, send a non negative for alpha
// alpha must be between 0 and 255, 255.0 being fully opaque

char buffer[256];  // working buffer

float col_tstep, row_tstep;
float col_vstep, row_vstep;
int columns, rows;

int rgbwhite;

BITMAP_FILE height_bitmap; // holds the height bitmap

// Step 1: clear out the object and initialize it a bit
memset(obj, 0, sizeof(OBJECT4DV2));

// set state of object to active and visible
obj->state = OBJECT4DV2_STATE_ACTIVE | OBJECT4DV2_STATE_VISIBLE;

// set position of object
obj->world_pos.x = pos->x;
obj->world_pos.y = pos->y;
obj->world_pos.z = pos->z;
obj->world_pos.w = pos->w;

// create proper color word based on selected bit depth of terrain
// rgbcolor is always in rgb5.6.5 format, so only need to downconvert for
// 8-bit mesh
if (poly_attr & POLY4DV1_ATTR_8BITCOLOR)
   { 
   rgbcolor = rgblookup[rgbcolor];
   rgbwhite = rgblookup[RGB16Bit(255,255,255)];
   } // end if
else
   {
   rgbwhite = RGB16Bit(255,255,255);
   } // end else

// set number of frames
obj->num_frames = 1;
obj->curr_frame = 0;
obj->attr = OBJECT4DV2_ATTR_SINGLE_FRAME;

// clear the bitmaps out
memset(&height_bitmap, 0, sizeof(BITMAP_FILE));
memset(&bitmap16bit, 0, sizeof(BITMAP_FILE));

// Step 2: load in the height field
Load_Bitmap_File(&height_bitmap, height_map_file);

// compute basic information
columns = height_bitmap.bitmapinfoheader.biWidth;
rows    = height_bitmap.bitmapinfoheader.biHeight;

col_vstep = twidth / (float)(columns - 1);
row_vstep = theight / (float)(rows - 1);

sprintf(obj->name ,"Terrain:%s%s", height_map_file, texture_map_file);
obj->num_vertices = columns * rows;
obj->num_polys    = ((columns - 1) * (rows - 1) ) * 2;

// store some results to help with terrain following
// use the auxialiary variables in the object -- might as well!
obj->ivar1 = columns;
obj->ivar2 = rows;
obj->fvar1 = col_vstep;
obj->fvar2 = row_vstep;

// allocate the memory for the vertices and number of polys
// the call parameters are redundant in this case, but who cares
if (!Init_OBJECT4DV2(obj,   // object to allocate
                     obj->num_vertices, 
                     obj->num_polys, 
                     obj->num_frames))
    {
    Write_Error("\nTerrain generator error (can't allocate memory).");
    } // end if



// load texture map if there is one
if ( (poly_attr & POLY4DV2_ATTR_SHADE_MODE_TEXTURE) && texture_map_file)
   {
   // load the texture from disk
   Load_Bitmap_File(&bitmap16bit, texture_map_file);

   // create a proper size and bitdepth bitmap
   obj->texture = (BITMAP_IMAGE_PTR)malloc(sizeof(BITMAP_IMAGE));
   Create_Bitmap(obj->texture,0,0,
                 bitmap16bit.bitmapinfoheader.biWidth,
                 bitmap16bit.bitmapinfoheader.biHeight,
                 bitmap16bit.bitmapinfoheader.biBitCount);
                          
    // load the bitmap image (later make this 8/16 bit)
    if (obj->texture->bpp == 16)
       Load_Image_Bitmap16(obj->texture, &bitmap16bit,0,0,BITMAP_EXTRACT_MODE_ABS);
    else
       {
       Load_Image_Bitmap(obj->texture, &bitmap16bit,0,0,BITMAP_EXTRACT_MODE_ABS);
       } // end else 8 bit


    // compute stepping factors in texture map for texture coordinate computation
    col_tstep = (float)(bitmap16bit.bitmapinfoheader.biWidth-1)/(float)(columns - 1);
    row_tstep = (float)(bitmap16bit.bitmapinfoheader.biHeight-1)/(float)(rows - 1);

    // flag object as having textures
    SET_BIT(obj->attr, OBJECT4DV2_ATTR_TEXTURES);

    // done, so unload the bitmap
    Unload_Bitmap_File(&bitmap16bit);
    } // end if

Write_Error("\ncolumns = %d, rows = %d", columns, rows);
Write_Error("\ncol_vstep = %f, row_vstep = %f", col_vstep, row_vstep);
Write_Error("\ncol_tstep=%f, row_tstep=%f", col_tstep, row_tstep);
Write_Error("\nnum_vertices = %d, num_polys = %d", obj->num_vertices, obj->num_polys);

// Step 4: generate the vertex list, and texture coordinate list in row major form
for (int curr_row = 0; curr_row < rows; curr_row++)
    {
    for (int curr_col = 0; curr_col < columns; curr_col++)
        {
        int vertex = (curr_row * columns) + curr_col;
        // compute the vertex
        obj->vlist_local[vertex].x = curr_col * col_vstep - (twidth/2);
        obj->vlist_local[vertex].y = vscale*((float)height_bitmap.buffer[curr_col + (curr_row * columns) ]) / 255;
        obj->vlist_local[vertex].z = curr_row * row_vstep - (theight/2);

        obj->vlist_local[vertex].w = 1;  

        // every vertex has a point at least, set that in the flags attribute
        SET_BIT(obj->vlist_local[vertex].attr, VERTEX4DTV1_ATTR_POINT);

        // need texture coord?
        if ( (poly_attr & POLY4DV2_ATTR_SHADE_MODE_TEXTURE) && texture_map_file)
           {
           // now texture coordinates
           obj->tlist[vertex].x = curr_col * col_tstep;
           obj->tlist[vertex].y = curr_row * row_tstep;

           } // end if

        Write_Error("\nVertex %d: V[%f, %f, %f], T[%f, %f]", vertex, obj->vlist_local[vertex].x,
                                                             obj->vlist_local[vertex].y,
                                                             obj->vlist_local[vertex].z,
                                                             obj->tlist[vertex].x,
                                                             obj->tlist[vertex].y);


        } // end for curr_col

     } // end curr_row

// perform rotation transformation?

// compute average and max radius
Compute_OBJECT4DV2_Radius(obj);

Write_Error("\nObject average radius = %f, max radius = %f", 
            obj->avg_radius[0], obj->max_radius[0]);

// Step 5: generate the polygon list
for (int poly=0; poly < obj->num_polys/2; poly++)
    {
    // polygons follow a regular pattern of 2 per square, row
    // major form, finding the correct indices is a pain, but 
    // the bottom line is we have an array of vertices mxn and we need
    // a list of polygons that is (m-1) x (n-1), with 2 triangles per
    // square with a consistent winding order... this is one one to arrive
    // at the indices, another way would be to use two loops, etc., 

    int base_poly_index = (poly % (columns-1)) + (columns * (poly / (columns - 1)) );

    // upper left poly
    obj->plist[poly*2].vert[0] = base_poly_index;
    obj->plist[poly*2].vert[1] = base_poly_index+columns;
    obj->plist[poly*2].vert[2] = base_poly_index+columns+1;

    // lower right poly
    obj->plist[poly*2+1].vert[0] = base_poly_index;
    obj->plist[poly*2+1].vert[1] = base_poly_index+columns+1;
    obj->plist[poly*2+1].vert[2] = base_poly_index+1;
 
    // point polygon vertex list to object's vertex list
    // note that this is redundant since the polylist is contained
    // within the object in this case and its up to the user to select
    // whether the local or transformed vertex list is used when building up
    // polygon geometry, might be a better idea to set to NULL in the context
    // of polygons that are part of an object
    obj->plist[poly*2].vlist = obj->vlist_local; 
    obj->plist[poly*2+1].vlist = obj->vlist_local; 

    // set attributes of polygon with sent attributes
    obj->plist[poly*2].attr = poly_attr;
    obj->plist[poly*2+1].attr = poly_attr;

    // now perform some test to make sure any secondary data elements are
    // set properly

    // set color of polygon
    obj->plist[poly*2].color   = rgbcolor;
    obj->plist[poly*2+1].color = rgbcolor;

    // check for gouraud of phong shading, if so need normals
    if ( (obj->plist[poly*2].attr & POLY4DV2_ATTR_SHADE_MODE_GOURAUD) ||  
         (obj->plist[poly*2].attr & POLY4DV2_ATTR_SHADE_MODE_PHONG) )
       {
       // the vertices from this polygon all need normals, set that in the flags attribute
       SET_BIT(obj->vlist_local[ obj->plist[poly*2].vert[0] ].attr, VERTEX4DTV1_ATTR_NORMAL); 
       SET_BIT(obj->vlist_local[ obj->plist[poly*2].vert[1] ].attr, VERTEX4DTV1_ATTR_NORMAL); 
       SET_BIT(obj->vlist_local[ obj->plist[poly*2].vert[2] ].attr, VERTEX4DTV1_ATTR_NORMAL); 

       SET_BIT(obj->vlist_local[ obj->plist[poly*2+1].vert[0] ].attr, VERTEX4DTV1_ATTR_NORMAL); 
       SET_BIT(obj->vlist_local[ obj->plist[poly*2+1].vert[1] ].attr, VERTEX4DTV1_ATTR_NORMAL); 
       SET_BIT(obj->vlist_local[ obj->plist[poly*2+1].vert[2] ].attr, VERTEX4DTV1_ATTR_NORMAL); 

       } // end if
 
     // if texture in enabled the enable texture coordinates
     if (poly_attr & POLY4DV2_ATTR_SHADE_MODE_TEXTURE)
        {
        // apply texture to this polygon
        obj->plist[poly*2].texture = obj->texture;
        obj->plist[poly*2+1].texture = obj->texture;

        // assign the texture coordinates
        // upper left poly
        obj->plist[poly*2].text[0] = base_poly_index;
        obj->plist[poly*2].text[1] = base_poly_index+columns;
        obj->plist[poly*2].text[2] = base_poly_index+columns+1;

        // lower right poly
        obj->plist[poly*2+1].text[0] = base_poly_index;
        obj->plist[poly*2+1].text[1] = base_poly_index+columns+1;
        obj->plist[poly*2+1].text[2] = base_poly_index+1;
 
        // override base color to make poly more reflective
        obj->plist[poly*2].color = rgbwhite;
        obj->plist[poly*2+1].color = rgbwhite;

        // set texture coordinate attributes
        SET_BIT(obj->vlist_local[ obj->plist[poly*2].vert[0] ].attr, VERTEX4DTV1_ATTR_TEXTURE); 
        SET_BIT(obj->vlist_local[ obj->plist[poly*2].vert[1] ].attr, VERTEX4DTV1_ATTR_TEXTURE); 
        SET_BIT(obj->vlist_local[ obj->plist[poly*2].vert[2] ].attr, VERTEX4DTV1_ATTR_TEXTURE); 

        SET_BIT(obj->vlist_local[ obj->plist[poly*2+1].vert[0] ].attr, VERTEX4DTV1_ATTR_TEXTURE); 
        SET_BIT(obj->vlist_local[ obj->plist[poly*2+1].vert[1] ].attr, VERTEX4DTV1_ATTR_TEXTURE); 
        SET_BIT(obj->vlist_local[ obj->plist[poly*2+1].vert[2] ].attr, VERTEX4DTV1_ATTR_TEXTURE); 

        } // end if

    // check for alpha enable for sea level polygons to help with water effect
    if (alpha >=0 )
       {
       // compute heights of both polygons
       float avg_y_poly1 = (obj->vlist_local[ obj->plist[poly*2].vert[0] ].y + 
                            obj->vlist_local[ obj->plist[poly*2].vert[1] ].y + 
                            obj->vlist_local[ obj->plist[poly*2].vert[2] ].y )/3;
        
       float avg_y_poly2 = (obj->vlist_local[ obj->plist[poly*2+1].vert[0] ].y + 
                            obj->vlist_local[ obj->plist[poly*2+1].vert[1] ].y + 
                            obj->vlist_local[ obj->plist[poly*2+1].vert[2] ].y )/3;


       // test height of poly1 relative to sea level
       if (avg_y_poly1 <= sea_level)
          {
          int ialpha = (int)( (float)alpha/255 * (float)(NUM_ALPHA_LEVELS-1) + (float)0.5);

          // set the alpha color
          obj->plist[poly*2+0].color+= (ialpha << 24);

          // set the alpha flag in polygon  
          SET_BIT(obj->plist[poly*2+0].attr, POLY4DV2_ATTR_TRANSPARENT);
          } // end if

     
       // test height of poly1 relative to sea level
       if (avg_y_poly2 <= sea_level)
          {
          int ialpha = (int)( (float)alpha/255 * (float)(NUM_ALPHA_LEVELS-1) + (float)0.5);

          // set the alpha color
          obj->plist[poly*2+1].color+= (ialpha << 24);

          // set the alpha flag in polygon  
          SET_BIT(obj->plist[poly*2+1].attr, POLY4DV2_ATTR_TRANSPARENT);
          } // end if

       } // end if 

    // set the material mode to ver. 1.0 emulation
    SET_BIT(obj->plist[poly*2].attr, POLY4DV2_ATTR_DISABLE_MATERIAL);
    SET_BIT(obj->plist[poly*2+1].attr, POLY4DV2_ATTR_DISABLE_MATERIAL);

    // finally set the polygon to active
    obj->plist[poly*2].state = POLY4DV2_STATE_ACTIVE;    
    obj->plist[poly*2+1].state = POLY4DV2_STATE_ACTIVE;  

    // point polygon vertex list to object's vertex list
    // note that this is redundant since the polylist is contained
    // within the object in this case and its up to the user to select
    // whether the local or transformed vertex list is used when building up
    // polygon geometry, might be a better idea to set to NULL in the context
    // of polygons that are part of an object
    obj->plist[poly*2].vlist = obj->vlist_local; 
    obj->plist[poly*2+1].vlist = obj->vlist_local; 

    // set texture coordinate list, this is needed
    obj->plist[poly*2].tlist = obj->tlist;
    obj->plist[poly*2+1].tlist = obj->tlist;

    } // end for poly
#if 0
for (poly=0; poly < obj->num_polys; poly++)
{
Write_Error("\nPoly %d: Vi[%d, %d, %d], Ti[%d, %d, %d]",poly,
                                                        obj->plist[poly].vert[0],
                                                        obj->plist[poly].vert[1],
                                                        obj->plist[poly].vert[2],
                                                        obj->plist[poly].text[0],
                                                        obj->plist[poly].text[1],
                                                        obj->plist[poly].text[2]);

} // end 
#endif

// compute the polygon normal lengths
Compute_OBJECT4DV2_Poly_Normals(obj);

// compute vertex normals for any gouraud shaded polys
Compute_OBJECT4DV2_Vertex_Normals(obj);

// return success
return(1);

} // end Generate_Terrain2_OBJECT4DV2

///////////////////////////////////////////////////////////////////////////////
// 1/z Buffer non alpha functions
///////////////////////////////////////////////////////////////////////////////

void Draw_Textured_TriangleINVZB_16(POLYF4DV2_PTR face,  // ptr to face
                                    UCHAR *_dest_buffer, // pointer to video buffer
                                    int mem_pitch,       // bytes per line, 320, 640 etc.
                                    UCHAR *_zbuffer,     // pointer to z-buffer
                                    int zpitch)          // bytes per line of zbuffer
{
// this function draws a textured triangle in 16-bit mode

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = (int)(face->tvlist[v0].u0);
tv0 = (int)(face->tvlist[v0].v0);

tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = (int)(face->tvlist[v1].u0);
tv1 = (int)(face->tvlist[v1].v0);

tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = (int)(face->tvlist[v2].u0);
tv2 = (int)(face->tvlist[v2].v0);

tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz2 - tz0) << 0)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz1 - tz0) << 0)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ????
		
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ????
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz2 - tz1) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dzdyr = ((tz2 - tz0) << 0)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ????
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_Triangle_INVZB_16

////////////////////////////////////////////////////////////////////////////////

void Draw_Textured_Bilerp_TriangleINVZB_16(POLYF4DV2_PTR face,  // ptr to face
                                    UCHAR *_dest_buffer, // pointer to video buffer
                                    int mem_pitch,       // bytes per line, 320, 640 etc.
                                    UCHAR *_zbuffer,     // pointer to z-buffer
                                    int zpitch)          // bytes per line of zbuffer
{
// this function draws a textured triangle in 16-bit mode

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// compute actual size of texture and store it
int texture_size = face->texture->width-1;

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = (int)(face->tvlist[v0].u0);
tv0 = (int)(face->tvlist[v0].v0);

tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = (int)(face->tvlist[v1].u0);
tv1 = (int)(face->tvlist[v1].v0);

tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = (int)(face->tvlist[v2].u0);
tv2 = (int)(face->tvlist[v2].v0);

tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz2 - tz0) << 0)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz1 - tz0) << 0)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ????
		
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
               // compute integral values of u,v
               int uint = ui >> FIXP16_SHIFT;
               int vint = vi >> FIXP16_SHIFT;

               int uint_pls_1 = uint+1;
               if (uint_pls_1 > texture_size) uint_pls_1 = texture_size;

               int vint_pls_1 = vint+1;
               if (vint_pls_1 > texture_size) vint_pls_1 = texture_size;

 			   int textel00 = textmap[(uint+0)     + ((vint+0) << texture_shift2)];
 			   int textel10 = textmap[(uint_pls_1) + ((vint+0) << texture_shift2)];
 			   int textel01 = textmap[(uint+0)     + ((vint_pls_1) << texture_shift2)];
 			   int textel11 = textmap[(uint_pls_1) + ((vint_pls_1) << texture_shift2)];

               // extract rgb components
               int r_textel00  = ((textel00 >> 11)       ); 
               int g_textel00  = ((textel00 >> 5)  & 0x3f); 
               int b_textel00  =  (textel00        & 0x1f);

               int r_textel10  = ((textel10 >> 11)       ); 
               int g_textel10  = ((textel10 >> 5)  & 0x3f); 
               int b_textel10  =  (textel10        & 0x1f);

               int r_textel01  = ((textel01 >> 11)       ); 
               int g_textel01  = ((textel01 >> 5)  & 0x3f); 
               int b_textel01  =  (textel01        & 0x1f);

               int r_textel11  = ((textel11 >> 11)       ); 
               int g_textel11  = ((textel11 >> 5)  & 0x3f); 
               int b_textel11  =  (textel11        & 0x1f);

               // compute fractional components of u,v in fixed 24.8 point format
               int dtu = (ui & (0xffff)) >> 8;
               int dtv = (vi & (0xffff)) >> 8;
 
               int one_minus_dtu = (1 << 8) - dtu;
               int one_minus_dtv = (1 << 8) - dtv;

               // each interpolant has 3 terms, (du), (dv), textel, however
               // the (du) and (dv) terms repeat during each computation of
               // r_textel, g_textel, and b_textel, so we can compute them once
               int one_minus_dtu_x_one_minus_dtv = (one_minus_dtu) * (one_minus_dtv);
               int dtu_x_one_minus_dtv           = (dtu)           * (one_minus_dtv);
               int dtu_x_dtv                     = (dtu)           * (dtv);
               int one_minus_dtu_x_dtv           = (one_minus_dtu) * (dtv);

               // now we are ready to sample the texture 
               int r_textel = one_minus_dtu_x_one_minus_dtv * r_textel00 + 
                              dtu_x_one_minus_dtv           * r_textel10 +
                              dtu_x_dtv                     * r_textel11 +
                              one_minus_dtu_x_dtv           * r_textel01;

               int g_textel = one_minus_dtu_x_one_minus_dtv * g_textel00 + 
                              dtu_x_one_minus_dtv           * g_textel10 +
                              dtu_x_dtv                     * g_textel11 +
                              one_minus_dtu_x_dtv           * g_textel01;

               int b_textel = one_minus_dtu_x_one_minus_dtv * b_textel00 + 
                              dtu_x_one_minus_dtv           * b_textel10 +
                              dtu_x_dtv                     * b_textel11 +
                              one_minus_dtu_x_dtv           * b_textel01;

               // write textel
               screen_ptr[xi] = ((r_textel >> 16) << 11) + ((g_textel >> 16) << 5) + (b_textel >> 16);

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ????
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               // compute integral values of u,v
               int uint = ui >> FIXP16_SHIFT;
               int vint = vi >> FIXP16_SHIFT;

               int uint_pls_1 = uint+1;
               if (uint_pls_1 > texture_size) uint_pls_1 = texture_size;

               int vint_pls_1 = vint+1;
               if (vint_pls_1 > texture_size) vint_pls_1 = texture_size;

 			   int textel00 = textmap[(uint+0)     + ((vint+0) << texture_shift2)];
 			   int textel10 = textmap[(uint_pls_1) + ((vint+0) << texture_shift2)];
 			   int textel01 = textmap[(uint+0)     + ((vint_pls_1) << texture_shift2)];
 			   int textel11 = textmap[(uint_pls_1) + ((vint_pls_1) << texture_shift2)];

               // extract rgb components
               int r_textel00  = ((textel00 >> 11)       ); 
               int g_textel00  = ((textel00 >> 5)  & 0x3f); 
               int b_textel00  =  (textel00        & 0x1f);

               int r_textel10  = ((textel10 >> 11)       ); 
               int g_textel10  = ((textel10 >> 5)  & 0x3f); 
               int b_textel10  =  (textel10        & 0x1f);

               int r_textel01  = ((textel01 >> 11)       ); 
               int g_textel01  = ((textel01 >> 5)  & 0x3f); 
               int b_textel01  =  (textel01        & 0x1f);

               int r_textel11  = ((textel11 >> 11)       ); 
               int g_textel11  = ((textel11 >> 5)  & 0x3f); 
               int b_textel11  =  (textel11        & 0x1f);

               // compute fractional components of u,v in fixed 24.8 point format
               int dtu = (ui & (0xffff)) >> 8;
               int dtv = (vi & (0xffff)) >> 8;
 
               int one_minus_dtu = (1 << 8) - dtu;
               int one_minus_dtv = (1 << 8) - dtv;

               // each interpolant has 3 terms, (du), (dv), textel, however
               // the (du) and (dv) terms repeat during each computation of
               // r_textel, g_textel, and b_textel, so we can compute them once
               int one_minus_dtu_x_one_minus_dtv = (one_minus_dtu) * (one_minus_dtv);
               int dtu_x_one_minus_dtv           = (dtu)           * (one_minus_dtv);
               int dtu_x_dtv                     = (dtu)           * (dtv);
               int one_minus_dtu_x_dtv           = (one_minus_dtu) * (dtv);

               // now we are ready to sample the texture 
               int r_textel = one_minus_dtu_x_one_minus_dtv * r_textel00 + 
                              dtu_x_one_minus_dtv           * r_textel10 +
                              dtu_x_dtv                     * r_textel11 +
                              one_minus_dtu_x_dtv           * r_textel01;

               int g_textel = one_minus_dtu_x_one_minus_dtv * g_textel00 + 
                              dtu_x_one_minus_dtv           * g_textel10 +
                              dtu_x_dtv                     * g_textel11 +
                              one_minus_dtu_x_dtv           * g_textel01;

               int b_textel = one_minus_dtu_x_one_minus_dtv * b_textel00 + 
                              dtu_x_one_minus_dtv           * b_textel10 +
                              dtu_x_dtv                     * b_textel11 +
                              one_minus_dtu_x_dtv           * b_textel01;

               // write textel
               screen_ptr[xi] = ((r_textel >> 16) << 11) + ((g_textel >> 16) << 5) + (b_textel >> 16);

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz2 - tz1) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dzdyr = ((tz2 - tz0) << 0)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
               // compute integral values of u,v
               int uint = ui >> FIXP16_SHIFT;
               int vint = vi >> FIXP16_SHIFT;

               int uint_pls_1 = uint+1;
               if (uint_pls_1 > texture_size) uint_pls_1 = texture_size;

               int vint_pls_1 = vint+1;
               if (vint_pls_1 > texture_size) vint_pls_1 = texture_size;

 			   int textel00 = textmap[(uint+0)     + ((vint+0) << texture_shift2)];
 			   int textel10 = textmap[(uint_pls_1) + ((vint+0) << texture_shift2)];
 			   int textel01 = textmap[(uint+0)     + ((vint_pls_1) << texture_shift2)];
 			   int textel11 = textmap[(uint_pls_1) + ((vint_pls_1) << texture_shift2)];

               // extract rgb components
               int r_textel00  = ((textel00 >> 11)       ); 
               int g_textel00  = ((textel00 >> 5)  & 0x3f); 
               int b_textel00  =  (textel00        & 0x1f);

               int r_textel10  = ((textel10 >> 11)       ); 
               int g_textel10  = ((textel10 >> 5)  & 0x3f); 
               int b_textel10  =  (textel10        & 0x1f);

               int r_textel01  = ((textel01 >> 11)       ); 
               int g_textel01  = ((textel01 >> 5)  & 0x3f); 
               int b_textel01  =  (textel01        & 0x1f);

               int r_textel11  = ((textel11 >> 11)       ); 
               int g_textel11  = ((textel11 >> 5)  & 0x3f); 
               int b_textel11  =  (textel11        & 0x1f);

               // compute fractional components of u,v in fixed 24.8 point format
               int dtu = (ui & (0xffff)) >> 8;
               int dtv = (vi & (0xffff)) >> 8;
 
               int one_minus_dtu = (1 << 8) - dtu;
               int one_minus_dtv = (1 << 8) - dtv;

               // each interpolant has 3 terms, (du), (dv), textel, however
               // the (du) and (dv) terms repeat during each computation of
               // r_textel, g_textel, and b_textel, so we can compute them once
               int one_minus_dtu_x_one_minus_dtv = (one_minus_dtu) * (one_minus_dtv);
               int dtu_x_one_minus_dtv           = (dtu)           * (one_minus_dtv);
               int dtu_x_dtv                     = (dtu)           * (dtv);
               int one_minus_dtu_x_dtv           = (one_minus_dtu) * (dtv);

               // now we are ready to sample the texture 
               int r_textel = one_minus_dtu_x_one_minus_dtv * r_textel00 + 
                              dtu_x_one_minus_dtv           * r_textel10 +
                              dtu_x_dtv                     * r_textel11 +
                              one_minus_dtu_x_dtv           * r_textel01;

               int g_textel = one_minus_dtu_x_one_minus_dtv * g_textel00 + 
                              dtu_x_one_minus_dtv           * g_textel10 +
                              dtu_x_dtv                     * g_textel11 +
                              one_minus_dtu_x_dtv           * g_textel01;

               int b_textel = one_minus_dtu_x_one_minus_dtv * b_textel00 + 
                              dtu_x_one_minus_dtv           * b_textel10 +
                              dtu_x_dtv                     * b_textel11 +
                              one_minus_dtu_x_dtv           * b_textel01;

               // write textel
               screen_ptr[xi] = ((r_textel >> 16) << 11) + ((g_textel >> 16) << 5) + (b_textel >> 16);

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ????
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               // compute integral values of u,v
               int uint = ui >> FIXP16_SHIFT;
               int vint = vi >> FIXP16_SHIFT;

               int uint_pls_1 = uint+1;
               if (uint_pls_1 > texture_size) uint_pls_1 = texture_size;

               int vint_pls_1 = vint+1;
               if (vint_pls_1 > texture_size) vint_pls_1 = texture_size;

 			   int textel00 = textmap[(uint+0)     + ((vint+0) << texture_shift2)];
 			   int textel10 = textmap[(uint_pls_1) + ((vint+0) << texture_shift2)];
 			   int textel01 = textmap[(uint+0)     + ((vint_pls_1) << texture_shift2)];
 			   int textel11 = textmap[(uint_pls_1) + ((vint_pls_1) << texture_shift2)];

               // extract rgb components
               int r_textel00  = ((textel00 >> 11)       ); 
               int g_textel00  = ((textel00 >> 5)  & 0x3f); 
               int b_textel00  =  (textel00        & 0x1f);

               int r_textel10  = ((textel10 >> 11)       ); 
               int g_textel10  = ((textel10 >> 5)  & 0x3f); 
               int b_textel10  =  (textel10        & 0x1f);

               int r_textel01  = ((textel01 >> 11)       ); 
               int g_textel01  = ((textel01 >> 5)  & 0x3f); 
               int b_textel01  =  (textel01        & 0x1f);

               int r_textel11  = ((textel11 >> 11)       ); 
               int g_textel11  = ((textel11 >> 5)  & 0x3f); 
               int b_textel11  =  (textel11        & 0x1f);

               // compute fractional components of u,v in fixed 24.8 point format
               int dtu = (ui & (0xffff)) >> 8;
               int dtv = (vi & (0xffff)) >> 8;
 
               int one_minus_dtu = (1 << 8) - dtu;
               int one_minus_dtv = (1 << 8) - dtv;

               // each interpolant has 3 terms, (du), (dv), textel, however
               // the (du) and (dv) terms repeat during each computation of
               // r_textel, g_textel, and b_textel, so we can compute them once
               int one_minus_dtu_x_one_minus_dtv = (one_minus_dtu) * (one_minus_dtv);
               int dtu_x_one_minus_dtv           = (dtu)           * (one_minus_dtv);
               int dtu_x_dtv                     = (dtu)           * (dtv);
               int one_minus_dtu_x_dtv           = (one_minus_dtu) * (dtv);

               // now we are ready to sample the texture 
               int r_textel = one_minus_dtu_x_one_minus_dtv * r_textel00 + 
                              dtu_x_one_minus_dtv           * r_textel10 +
                              dtu_x_dtv                     * r_textel11 +
                              one_minus_dtu_x_dtv           * r_textel01;

               int g_textel = one_minus_dtu_x_one_minus_dtv * g_textel00 + 
                              dtu_x_one_minus_dtv           * g_textel10 +
                              dtu_x_dtv                     * g_textel11 +
                              one_minus_dtu_x_dtv           * g_textel01;

               int b_textel = one_minus_dtu_x_one_minus_dtv * b_textel00 + 
                              dtu_x_one_minus_dtv           * b_textel10 +
                              dtu_x_dtv                     * b_textel11 +
                              one_minus_dtu_x_dtv           * b_textel01;

               // write textel
               screen_ptr[xi] = ((r_textel >> 16) << 11) + ((g_textel >> 16) << 5) + (b_textel >> 16);

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_Bilerp_Triangle_INVZB_16

////////////////////////////////////////////////////////////////////////////////


void Draw_Textured_Perspective_Triangle_INVZB_16(POLYF4DV2_PTR face,  // ptr to face
                                                   UCHAR *_dest_buffer, // pointer to video buffer
                                                   int mem_pitch,       // bytes per line, 320, 640 etc.
                                                   UCHAR *_zbuffer,     // pointer to z-buffer
                                                   int zpitch)          // bytes per line of zbuffer
{
// this function draws a textured triangle in 16-bit mode using a 1/z buffer and piecewise linear
// perspective correct texture mappping, 1/z, u/z, v/z are interpolated down each edge then to draw
// each span U and V are computed for each end point and the space is broken up into 32 pixel
// spans where the correct U,V is computed at each point along the span, but linearly interpolated
// across the span

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = ((int)(face->tvlist[v0].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tv0 = ((int)(face->tvlist[v0].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = ((int)(face->tvlist[v1].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tv1 = ((int)(face->tvlist[v1].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = ((int)(face->tvlist[v2].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tv2 = ((int)(face->tvlist[v2].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{
	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << 0)/dy;  
	dvdyl = ((tv2 - tv0) << 0)/dy;    
	dzdyl = ((tz2 - tz0) << 0)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << 0)/dy;  
	dvdyr = ((tv2 - tv1) << 0)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << 0);
		vr = dvdyr*dy + (tv1 << 0);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu1 << 0);
		vr = (tv1 << 0);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;
		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << 0)/dy;  
	dvdyl = ((tv1 - tv0) << 0)/dy;    
	dzdyl = ((tz1 - tz0) << 0)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << 0)/dy;  
	dvdyr = ((tv2 - tv0) << 0)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;
		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];
               //screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;
		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else


		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];
               //screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << 0)/dyl;  
		dvdyl = ((tv2 - tv1) << 0)/dyl;    
		dzdyl = ((tz2 - tz1) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << 0);
		vl = dvdyl*dyl + (tv1 << 0);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << 0);
		vr = dvdyr*dyr + (tv0 << 0);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   		
		dzdyr = ((tz2 - tz0) << 0)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else


		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];
               //screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi]) 
               {
   			   // write textel
               screen_ptr[xi] = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];
               //screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_Perspective_Triangle_INVZB_16

///////////////////////////////////////////////////////////////////////////////////

void Draw_Textured_PerspectiveLP_Triangle_INVZB_16(POLYF4DV2_PTR face,  // ptr to face
                                                   UCHAR *_dest_buffer, // pointer to video buffer
                                                   int mem_pitch,       // bytes per line, 320, 640 etc.
                                                   UCHAR *_zbuffer,     // pointer to z-buffer
                                                   int zpitch)          // bytes per line of zbuffer
{
// this function draws a textured triangle in 16-bit mode using a 1/z buffer and piecewise linear
// perspective correct texture mappping, 1/z, u/z, v/z are interpolated down each edge then to draw
// each span U and V are computed for each end point and the space is broken up into 32 pixel
// spans where the correct U,V is computed at each point along the span, but linearly interpolated
// across the span

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int ul2, ur2, vl2, vr2;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = ((int)(face->tvlist[v0].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tv0 = ((int)(face->tvlist[v0].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = ((int)(face->tvlist[v1].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tv1 = ((int)(face->tvlist[v1].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = ((int)(face->tvlist[v2].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tv2 = ((int)(face->tvlist[v2].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{
	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << 0)/dy;  
	dvdyl = ((tv2 - tv0) << 0)/dy;    
	dzdyl = ((tz2 - tz0) << 0)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << 0)/dy;  
	dvdyr = ((tv2 - tv1) << 0)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << 0);
		vr = dvdyr*dy + (tv1 << 0);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu1 << 0);
		vr = (tv1 << 0);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;
		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << 0)/dy;  
	dvdyl = ((tv1 - tv0) << 0)/dy;    
	dzdyl = ((tz1 - tz0) << 0)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << 0)/dy;  
	dvdyr = ((tv2 - tv0) << 0)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;
		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
   
        // compute linear version of ul, ur, vl, vr
        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
        dx = (xend - xstart);

		// compute u,v interpolants
		if ( dx > 0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = textmap[(ui >> FIXP22_SHIFT) + ((vi >> FIXP22_SHIFT) << texture_shift2)];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;
		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
        // compute linear version of ul, ur, vl, vr
        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else


		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = textmap[(ui >> FIXP22_SHIFT) + ((vi >> FIXP22_SHIFT) << texture_shift2)];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << 0)/dyl;  
		dvdyl = ((tv2 - tv1) << 0)/dyl;    
		dzdyl = ((tz2 - tz1) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << 0);
		vl = dvdyl*dyl + (tv1 << 0);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << 0);
		vr = dvdyr*dyr + (tv0 << 0);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   		
		dzdyr = ((tz2 - tz0) << 0)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
        // compute linear version of ul, ur, vl, vr
        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;


		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else


		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = textmap[(ui >> FIXP22_SHIFT) + ((vi >> FIXP22_SHIFT) << texture_shift2)];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi]) 
               {
   			   // write textel
               screen_ptr[xi] = textmap[(ui >> FIXP22_SHIFT) + ((vi >> FIXP22_SHIFT) << texture_shift2)];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_PerspectiveLP_Triangle_INVZB_16

///////////////////////////////////////////////////////////////////////////////////

void Draw_Textured_Perspective_Triangle_FSINVZB_16(POLYF4DV2_PTR face,  // ptr to face
                                                   UCHAR *_dest_buffer, // pointer to video buffer
                                                   int mem_pitch,       // bytes per line, 320, 640 etc.
                                                   UCHAR *_zbuffer,     // pointer to z-buffer
                                                   int zpitch)          // bytes per line of zbuffer
{
// this function draws a textured triangle in 16-bit mode using a 1/z buffer and piecewise linear
// perspective correct texture mappping, 1/z, u/z, v/z are interpolated down each edge then to draw
// each span U and V are computed for each end point and the space is broken up into 32 pixel
// spans where the correct U,V is computed at each point along the span, but linearly interpolated
// across the span

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

USHORT r_base, g_base, b_base,
       r_textel, g_textel, b_textel, textel;


UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract base color of lit poly, so we can modulate texture a bit
// for lighting
_RGB565FROM16BIT(face->lit_color[0], &r_base, &g_base, &b_base);

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = ((int)(face->tvlist[v0].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tv0 = ((int)(face->tvlist[v0].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = ((int)(face->tvlist[v1].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tv1 = ((int)(face->tvlist[v1].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = ((int)(face->tvlist[v2].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tv2 = ((int)(face->tvlist[v2].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{
	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << 0)/dy;  
	dvdyl = ((tv2 - tv0) << 0)/dy;    
	dzdyl = ((tz2 - tz0) << 0)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << 0)/dy;  
	dvdyr = ((tv2 - tv1) << 0)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << 0);
		vr = dvdyr*dy + (tv1 << 0);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu1 << 0);
		vr = (tv1 << 0);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;
		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << 0)/dy;  
	dvdyl = ((tv1 - tv0) << 0)/dy;    
	dzdyl = ((tz1 - tz0) << 0)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << 0)/dy;  
	dvdyr = ((tv2 - tv0) << 0)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;
		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

		
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;
		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else


		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << 0)/dyl;  
		dvdyl = ((tv2 - tv1) << 0)/dyl;    
		dzdyl = ((tz2 - tz1) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << 0);
		vl = dvdyl*dyl + (tv1 << 0);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << 0);
		vr = dvdyr*dyr + (tv0 << 0);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   		
		dzdyr = ((tz2 - tz0) << 0)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else


		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_Perspective_Triangle_FSINVZB_16

//////////////////////////////////////////////////////////////////////////////////////////////////////

void Draw_Textured_PerspectiveLP_Triangle_FSINVZB_16(POLYF4DV2_PTR face,  // ptr to face
                                                   UCHAR *_dest_buffer, // pointer to video buffer
                                                   int mem_pitch,       // bytes per line, 320, 640 etc.
                                                   UCHAR *_zbuffer,     // pointer to z-buffer
                                                   int zpitch)          // bytes per line of zbuffer
{
// this function draws a textured triangle in 16-bit mode using a 1/z buffer and piecewise linear
// perspective correct texture mappping, 1/z, u/z, v/z are interpolated down each edge then to draw
// each span U and V are computed for each end point and the space is broken up into 32 pixel
// spans where the correct U,V is computed at each point along the span, but linearly interpolated
// across the span

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int ur2, ul2, vr2, vl2;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

USHORT r_base, g_base, b_base,
       r_textel, g_textel, b_textel, textel;


UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract base color of lit poly, so we can modulate texture a bit
// for lighting
_RGB565FROM16BIT(face->lit_color[0], &r_base, &g_base, &b_base);

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = ((int)(face->tvlist[v0].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tv0 = ((int)(face->tvlist[v0].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = ((int)(face->tvlist[v1].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tv1 = ((int)(face->tvlist[v1].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = ((int)(face->tvlist[v2].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tv2 = ((int)(face->tvlist[v2].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{
	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << 0)/dy;  
	dvdyl = ((tv2 - tv0) << 0)/dy;    
	dzdyl = ((tz2 - tz0) << 0)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << 0)/dy;  
	dvdyr = ((tv2 - tv1) << 0)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << 0);
		vr = dvdyr*dy + (tv1 << 0);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu1 << 0);
		vr = (tv1 << 0);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;
		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << 0)/dy;  
	dvdyl = ((tv1 - tv0) << 0)/dy;    
	dzdyl = ((tz1 - tz0) << 0)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << 0)/dy;  
	dvdyr = ((tv2 - tv0) << 0)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;
		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;


		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[ (ui >> FIXP22_SHIFT) + ( (vi >> FIXP22_SHIFT)  << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

		
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;
		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else


		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 		       textel = textmap[ (ui >> FIXP22_SHIFT) + ( (vi >> FIXP22_SHIFT)  << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << 0)/dyl;  
		dvdyl = ((tv2 - tv1) << 0)/dyl;    
		dzdyl = ((tz2 - tz1) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << 0);
		vl = dvdyl*dyl + (tv1 << 0);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << 0);
		vr = dvdyr*dyr + (tv0 << 0);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   		
		dzdyr = ((tz2 - tz0) << 0)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else


		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[ (ui >> FIXP22_SHIFT) + ( (vi >> FIXP22_SHIFT)  << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[ (ui >> FIXP22_SHIFT) + ( (vi >> FIXP22_SHIFT)  << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_PerspectiveLP_Triangle_FSINVZB_16

////////////////////////////////////////////////////////////////////////////////////

void Draw_Triangle_2DINVZB_16(POLYF4DV2_PTR face,   // ptr to face
                           UCHAR *_dest_buffer,   // pointer to video buffer
                           int mem_pitch,         // bytes per line, 320, 640 etc.
                           UCHAR *_zbuffer,       // pointer to z-buffer
                           int zpitch)            // bytes per line of zbuffer
{
// this function draws a flat shaded polygon with 1/z buffering

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    z,
    dz,
    xi,yi,              // the current interpolated x,y
	zi,                 // the current interpolated z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
    dzdyl,   
	zl,
	dzdyr,
	zr;

int x0,y0,tz0,    // cached vertices
	x1,y1,tz1,
	x2,y2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

USHORT color;    // polygon color

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);


// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;


// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);
            
x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// extract constant color
color = face->lit_color[0];

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dzdyl = ((tz2 - tz0) << 0)/dy; 

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dzdyr = ((tz2 - tz1) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		zl = (tz0 << 0);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dzdyl = ((tz1 - tz0) << 0)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		zl = (tz0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v,w interpolants
		zi = zl;// + FIXP16_ROUND_UP; // ???

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel assume 5.6.5
    		   screen_ptr[xi] = color;

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,w,z
			zi+=dz;
			} // end for xi

		// interpolate z,x along right and left edge
		xl+=dxdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel 5.6.5
               screen_ptr[xi] = color;

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate z
			zi+=dz;
			} // end for xi

		// interpolate x,z along right and left edge
		xl+=dxdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dzdyl = ((tz2 - tz1) << 0)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << 0)/dyr;  
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dzdyl = ((tz1 - tz0) << 0)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << 0)/dyr;  
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dzdyl = ((tz1 - tz0) << 0)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << 0)/dyr;

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		zl = (tz0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for z interpolants
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		// compute z interpolants
		if ((dx = (xend - xstart))>0)
			{
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel assume 5.6.5
               screen_ptr[xi] = color;

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate z
			zi+=dz;
			} // end for xi

		// interpolate z,x along right and left edge
		xl+=dxdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dzdyl = ((tz2 - tz1) << 0)/dyl;  

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dzdyr = ((tz1 - tz2) << 0)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w,z interpolants
		zi = zl; // + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel assume 5.6.5
    		   screen_ptr[xi] = color;

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate z
			zi+=dz;
			} // end for xi

		// interpolate x,z along right and left edge
		xl+=dxdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dzdyr = ((tz1 - tz2) << 0)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			zr+=dzdyr;
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Triangle_2DINVZB_16

///////////////////////////////////////////////////////////////////////////////

void Draw_Textured_TriangleFSINVZB_16(POLYF4DV2_PTR face, // ptr to face
                                 UCHAR *_dest_buffer,  // pointer to video buffer
                                 int mem_pitch,        // bytes per line, 320, 640 etc.
                                 UCHAR *_zbuffer,       // pointer to z-buffer
                                 int zpitch)          // bytes per line of zbuffer
{
// this function draws a textured triangle in 16-bit mode with flat shading

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,            // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dzdyl,    
	zl,
	dvdyl,   
	vl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

USHORT r_base, g_base, b_base,
       r_textel, g_textel, b_textel, textel;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;


#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;


// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP( face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract base color of lit poly, so we can modulate texture a bit
// for lighting
_RGB565FROM16BIT(face->lit_color[0], &r_base, &g_base, &b_base);

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = (int)(face->tvlist[v0].u0);
tv0 = (int)(face->tvlist[v0].v0);
tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = (int)(face->tvlist[v1].u0);
tv1 = (int)(face->tvlist[v1].v0);
tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = (int)(face->tvlist[v2].u0);
tv2 = (int)(face->tvlist[v2].v0);
tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz2 - tz0) << 0)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz1 - tz0) << 0)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl; //  + FIXP16_ROUND_UP; // ???
		
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[(ui >> (FIXP16_SHIFT)) + ((vi >> (FIXP16_SHIFT)) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl; //  + FIXP16_ROUND_UP; // ???
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
            dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[(ui >> (FIXP16_SHIFT)) + ((vi >> (FIXP16_SHIFT)) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,z
			ui+=du;
			vi+=dv;
            zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	    zl+=dzdyl;

		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
        zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
        dzdyl = ((tz2 - tz1) << 0)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
        dzdyr = ((tz2 - tz0) << 0)/dyr;   		

		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
        zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
        zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
        dzdyl = ((tz1 - tz0) << 0)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
        dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
        zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
        zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
        dzdyl = ((tz1 - tz0) << 0)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
        dzdyr = ((tz2 - tz0) << 0)/dyr;   		

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
        zl = (tz0 << 0);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
        zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else


    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
        zi = zl;// + FIXP16_ROUND_UP; // ???
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
            dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
            dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[(ui >> (FIXP16_SHIFT)) + ((vi >> (FIXP16_SHIFT)) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v
			ui+=du;
			vi+=dv;
            zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
     		// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;  

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else


			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,z interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl; //  + FIXP16_ROUND_UP; // ???
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
            dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
            dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[(ui >> (FIXP16_SHIFT)) + ((vi >> (FIXP16_SHIFT)) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
               screen_ptr[xi] = ((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11));

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,z
			ui+=du;
			vi+=dv;
            zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
        zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
        zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag
			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl; 

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_TriangleFSINVZB2_16

////////////////////////////////////////////////////////////////////////////////

void Draw_Textured_TriangleGSINVZB_16(POLYF4DV2_PTR face,   // ptr to face
                                      UCHAR *_dest_buffer, // pointer to video buffer
                                      int mem_pitch,       // bytes per line, 320, 640 etc.
                                      UCHAR *_zbuffer,       // pointer to z-buffer
                                      int zpitch)          // bytes per line of zbuffer

{
// this function draws a textured gouraud shaded polygon, and z bufferedbased on the affine texture mapper, 
// we simply interpolate the (R,G,B) values across the polygons along with the texture coordinates
// and then modulate to get the final color 

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;


int dx,dy,dyl,dyr,      // general deltas
    u,v,w,z, s,t,
    du,dv,dw,dz, ds, dt, 
    xi,yi,             // the current interpolated x,y
	ui,vi,wi,zi, si, ti,    // the current interpolated u,v
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dwdyl,   
	wl,
	dzdyl,   
	zl,
	dsdyl,    
	sl,
	dtdyl,   
	tl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dwdyr,
	wr,
	dzdyr,
	zr,
	dsdyr,
	sr,
	dtdyr,
	tr;

int x0,y0,tu0,tv0,tw0, tz0, ts0,tt0,    // cached vertices
	x1,y1,tu1,tv1,tw1, tz1, ts1,tt1,
	x2,y2,tu2,tv2,tw2, tz2, ts2,tt2;

int r_base0, g_base0, b_base0,
    r_base1, g_base1, b_base1,
    r_base2, g_base2, b_base2;


UINT r_textel, g_textel, b_textel;
USHORT textel;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif


// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.0);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.0);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.0);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.0);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.0);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.0);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// assume 5.6.5 format -- sorry!
// we can't afford a function call in the inner loops, so we must write 
// two hard coded versions, if we want support for both 5.6.5, and 5.5.5
_RGB565FROM16BIT(face->lit_color[v0], &r_base0, &g_base0, &b_base0);
_RGB565FROM16BIT(face->lit_color[v1], &r_base1, &g_base1, &b_base1);
_RGB565FROM16BIT(face->lit_color[v2], &r_base2, &g_base2, &b_base2);

// scale to 8 bit 
r_base0 <<= 3;
g_base0 <<= 2;
b_base0 <<= 3;

// scale to 8 bit 
r_base1 <<= 3;
g_base1 <<= 2;
b_base1 <<= 3;

// scale to 8 bit 
r_base2 <<= 3;
g_base2 <<= 2;
b_base2 <<= 3;

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);
ts0 = (int)(face->tvlist[v0].u0);
tt0 = (int)(face->tvlist[v0].v0);

tu0 = r_base0;
tv0 = g_base0; 
tw0 = b_base0; 

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);
ts1 = (int)(face->tvlist[v1].u0);
tt1 = (int)(face->tvlist[v1].v0);

tu1 = r_base1;
tv1 = g_base1; 
tw1 = b_base1; 

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);
ts2 = (int)(face->tvlist[v2].u0);
tt2 = (int)(face->tvlist[v2].v0);

tu2 = r_base2; 
tv2 = g_base2; 
tw2 = b_base2; 

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw2 - tw0) << FIXP16_SHIFT)/dy;  
	dzdyl = ((tz2 - tz0) << 0)/dy; 
	
    dsdyl = ((ts2 - ts0) << FIXP16_SHIFT)/dy;    
	dtdyl = ((tt2 - tt0) << FIXP16_SHIFT)/dy;  

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;   

	dsdyr = ((ts2 - ts1) << FIXP16_SHIFT)/dy;   
	dtdyr = ((tt2 - tt1) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << 0);

		sr = dsdyr*dy + (ts1 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);


		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		wr = (tw1 << FIXP16_SHIFT);
		zr = (tz1 << 0);

		sr = (ts1 << FIXP16_SHIFT);
		tr = (tt1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dy; 
	dzdyl = ((tz1 - tz0) << 0)/dy; 

	dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dy;    
	dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dy;   
	dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dy;   


	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		sr = dsdyr*dy + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt0 << FIXP16_SHIFT);


		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);
		zr = (tz0 << 0);

		sr = (ts0 << FIXP16_SHIFT);
		tr = (tt0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???
		
        si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			zi+=dx*dz;
			
			si+=dx*ds;
			ti+=dx*dt;

			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
            { 
		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = ((b_textel >> (FIXP16_SHIFT+8)) + 
                             ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                             ((r_textel >> (FIXP16_SHIFT+8)) << 11));

            // update z-buffer
            z_ptr[xi] = zi;   

            } // end if 

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		sl+=dsdyl;
		tl+=dtdyl;

		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;
 
		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
            { 
		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = ((b_textel >> (FIXP16_SHIFT+8)) + 
                             ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                             ((r_textel >> (FIXP16_SHIFT+8)) << 11));

            // update z-buffer
            z_ptr[xi] = zi;   

            } // end if 

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;

		sl+=dsdyl;
		tl+=dtdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  
		dzdyl = ((tz2 - tz1) << 0)/dyl;  

		dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;  

		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);

		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		wl = dwdyl*dyl + (tw1 << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << 0);

		sl = dsdyl*dyl + (ts1 << FIXP16_SHIFT);
		tl = dtdyl*dyl + (tt1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);

		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dyr + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << 0);

		sr = dsdyr*dyr + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dyr + (tt0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
		
			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);

         	SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);

			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);

			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl; 
		dzdyl = ((tz1 - tz0) << 0)/dyl; 

		dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;   

		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		sr = dsdyr*dy + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);

			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);

			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);

			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);

			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl;   
		dzdyl = ((tz1 - tz0) << 0)/dyl;  

		dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << 0)/dyr;

		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   		
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);
		zr = (tz0 << 0);

		sr = (ts0 << FIXP16_SHIFT);
		tr = (tt0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);

			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);


			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);


			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);

			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			zi+=dx*dz;
			
			si+=dx*ds;
			ti+=dx*dt;

			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
            { 
		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = ((b_textel >> (FIXP16_SHIFT+8)) + 
                             ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                             ((r_textel >> (FIXP16_SHIFT+8)) << 11));

            // update z-buffer
            z_ptr[xi] = zi;   

            } // end if 

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
        ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		sl+=dsdyl;
		tl+=dtdyl;

		xr+=dxdyr;
     	ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  
			dzdyl = ((tz2 - tz1) << 0)/dyl;  

			dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;   		
			dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;  

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			sl = (ts1 << FIXP16_SHIFT);
			tl = (tt1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			zl+=dzdyl;

			sl+=dsdyl;
			tl+=dtdyl;

			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;   

			dsdyr = ((ts1 - ts2) << FIXP16_SHIFT)/dyr;   		
			dtdyr = ((tt1 - tt2) << FIXP16_SHIFT)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			sr = (ts2 << FIXP16_SHIFT);
			tr = (tt2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			zr+=dzdyr;
		
			sr+=dsdyr;
			tr+=dtdyr;
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
            { 
		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = ((b_textel >> (FIXP16_SHIFT+8)) + 
                             ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                             ((r_textel >> (FIXP16_SHIFT+8)) << 11));

            // update z-buffer
            z_ptr[xi] = zi;   

            } // end if 

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;

			si+=ds;
			ti+=dt;
			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;

		sl+=dsdyl;
		tl+=dtdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;   
			dzdyl = ((tz2 - tz1) << 0)/dyl;  

			dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;   		
			dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			sl = (ts1 << FIXP16_SHIFT);
			tl = (tt1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			zl+=dzdyl;

			sl+=dsdyl;
			tl+=dtdyl;

			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   
			dzdyr = ((tz1 - tz2) << 0)/dyr;   

			dsdyr = ((ts1 - ts2) << FIXP16_SHIFT)/dyr;   		
			dtdyr = ((tt1 - tt2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			sr = (ts2 << FIXP16_SHIFT);
			tr = (tt2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			zr+=dzdyr;

			sr+=dsdyr;
			tr+=dtdyr;

			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_TriangleGSINVZB_16

///////////////////////////////////////////////////////////////////////////////

void Draw_Gouraud_TriangleINVZB_16(POLYF4DV2_PTR face,   // ptr to face
                                    UCHAR *_dest_buffer,   // pointer to video buffer
                                    int mem_pitch,         // bytes per line, 320, 640 etc.
                                    UCHAR *_zbuffer,       // pointer to z-buffer
                                    int zpitch)            // bytes per line of zbuffer
{
// this function draws a gouraud shaded polygon, based on the affine texture mapper, instead
// of interpolating the texture coordinates, we simply interpolate the (R,G,B) values across
// the polygons, I simply needed at another interpolant, I have mapped u->red, v->green, w->blue
// also a new interpolant for z buffering has been added

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,w,z,
    du,dv,dw,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,wi,zi,        // the current interpolated u,v,w,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
    dudyl,    
	ul,
	dvdyl,   
	vl,
	dwdyl,   
	wl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dwdyr,
	wr,
	dzdyr,
	zr;

int x0,y0,tu0,tv0,tw0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tw1,tz1,
	x2,y2,tu2,tv2,tw2,tz2;

int r_base0, g_base0, b_base0,
    r_base1, g_base1, b_base1,
    r_base2, g_base2, b_base2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;


// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// assume 5.6.5 format -- sorry!
// we can't afford a function call in the inner loops, so we must write 
// two hard coded versions, if we want support for both 5.6.5, and 5.5.5
_RGB565FROM16BIT(face->lit_color[v0], &r_base0, &g_base0, &b_base0);
_RGB565FROM16BIT(face->lit_color[v1], &r_base1, &g_base1, &b_base1);
_RGB565FROM16BIT(face->lit_color[v2], &r_base2, &g_base2, &b_base2);

// scale to 8 bit 
r_base0 <<= 3;
g_base0 <<= 2;
b_base0 <<= 3;

// scale to 8 bit 
r_base1 <<= 3;
g_base1 <<= 2;
b_base1 <<= 3;

// scale to 8 bit 
r_base2 <<= 3;
g_base2 <<= 2;
b_base2 <<= 3;

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tu0 = r_base0;
tv0 = g_base0; 
tw0 = b_base0; 

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tu1 = r_base1;
tv1 = g_base1; 
tw1 = b_base1; 

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

tz2 = (1 <<FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tu2 = r_base2; 
tv2 = g_base2; 
tw2 = b_base2; 

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{
	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw2 - tw0) << FIXP16_SHIFT)/dy;  
	dzdyl = ((tz2 - tz0) << 0)/dy; 

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		wr = (tw1 << FIXP16_SHIFT);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dy; 
	dzdyl = ((tz1 - tz0) << 0)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel assume 5.6.5
    		   screen_ptr[xi] = ((ui >> (FIXP16_SHIFT+3)) << 11) + 
                                ((vi >> (FIXP16_SHIFT+2)) << 5) + 
                                 (wi >> (FIXP16_SHIFT+3));   

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,w,z
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;
			} // end for xi

		// interpolate u,v,w,z,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel 5.6.5
               screen_ptr[xi] = ((ui >> (FIXP16_SHIFT+3)) << 11) + 
                                ((vi >> (FIXP16_SHIFT+2)) << 5) + 
                                 (wi >> (FIXP16_SHIFT+3));   

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if


			// interpolate u,v,w,z
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;
			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  
		dzdyl = ((tz2 - tz1) << 0)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;  
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);

		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		wl = dwdyl*dyl + (tw1 << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);

		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dyr + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl; 
		dzdyl = ((tz1 - tz0) << 0)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;  
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl;   
		dzdyl = ((tz1 - tz0) << 0)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << 0)/dyr;

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel assume 5.6.5
               screen_ptr[xi] = ((ui >> (FIXP16_SHIFT+3)) << 11) + 
                                ((vi >> (FIXP16_SHIFT+2)) << 5) + 
                                 (wi >> (FIXP16_SHIFT+3));   

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,w,z
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;
			} // end for xi

		// interpolate u,v,w,z,x along right and left edge
		xl+=dxdyl;
        ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
     	ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  
			dzdyl = ((tz2 - tz1) << 0)/dyl;  

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w,z interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel assume 5.6.5
    		   screen_ptr[xi] = ((ui >> (FIXP16_SHIFT+3)) << 11) + 
                                ((vi >> (FIXP16_SHIFT+2)) << 5) + 
                                 (wi >> (FIXP16_SHIFT+3));   

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,w,z
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;
			} // end for xi

		// interpolate u,v,w,x,z along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;   
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   
			dzdyr = ((tz1 - tz2) << 0)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			zr+=dzdyr;
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Gouraud_TriangleINVZB_16

///////////////////////////////////////////////////////////////////////////////

void Draw_RENDERLIST4DV2_SolidINVZB_16(RENDERLIST4DV2_PTR rend_list, 
                                   UCHAR *video_buffer, 
	   						       int lpitch,
                                   UCHAR *zbuffer,
                                   int zpitch)
{
// 16-bit version
// this function "executes" the render list or in other words
// draws all the faces in the list, the function will call the 
// proper rasterizer based on the lighting model of the polygons


POLYF4DV2 face; // temp face used to render polygon

// at this point, all we have is a list of polygons and it's time
// to draw them
for (int poly=0; poly < rend_list->num_polys; poly++)
    {
    // render this polygon if and only if it's not clipped, not culled,
    // active, and visible, note however the concecpt of "backface" is 
    // irrelevant in a wire frame engine though
    if (!(rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_ACTIVE) ||
         (rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_CLIPPED ) ||
         (rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_BACKFACE) )
       continue; // move onto next poly

    // need to test for textured first, since a textured poly can either
    // be emissive, or flat shaded, hence we need to call different
    // rasterizers    
    if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_TEXTURE)
       {
       // set the vertices
       face.tvlist[0].x = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;
       face.tvlist[0].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[0].u0;
       face.tvlist[0].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[0].v0;

       face.tvlist[1].x = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;
       face.tvlist[1].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[1].u0;
       face.tvlist[1].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[1].v0;

       face.tvlist[2].x = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;
       face.tvlist[2].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[2].u0;
       face.tvlist[2].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[2].v0;

       // test if this is a mipmapped polygon?
       if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_MIPMAP)
          {
          // determine mip level for this polygon
          int miplevel = (6*rend_list->poly_ptrs[poly]->tvlist[0].z/2000);
       
          if (miplevel > 6) 
              miplevel = 6;

          face.texture = ((BITMAP_IMAGE_PTR *)(rend_list->poly_ptrs[poly]->texture))[miplevel];

          for (int ts = 0; ts < miplevel; ts++)
              {
              face.tvlist[0].u0*=.5;
              face.tvlist[0].v0*=.5;

              face.tvlist[1].u0*=.5;
              face.tvlist[1].v0*=.5;

              face.tvlist[2].u0*=.5;
              face.tvlist[2].v0*=.5;
              } // end for

          } // end if
       else
          {
          // assign the texture without change
          face.texture = rend_list->poly_ptrs[poly]->texture;
          } // end if

       // is this a plain emissive texture?
       if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT)
          {
          // draw the textured triangle as emissive
           Draw_Textured_TriangleINVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);

          } // end if
       else
       if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT)
          {
          // draw as flat shaded
          face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];

          //if (avg_z > MIN_PERSPECTIVE_CORRECT_DIST)
             Draw_Textured_TriangleFSINVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);
          //else
             //Draw_Textured_PerspectiveLP_Triangle_FSINVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);

          } // end else if
       else
          {
          // must be gouraud POLY4DV2_ATTR_SHADE_MODE_GOURAUD
          face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];
          face.lit_color[1] = rend_list->poly_ptrs[poly]->lit_color[1];
          face.lit_color[2] = rend_list->poly_ptrs[poly]->lit_color[2];

          Draw_Textured_TriangleGSINVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);
          } // end else

       } // end if      
    else
    if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT) || 
        (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT) )
       {
       // draw as constant shaded
       face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];
       
       // set the vertices
       face.tvlist[0].x = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;

       face.tvlist[1].x = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;

       face.tvlist[2].x = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;

       // draw the triangle with basic flat rasterizer
       Draw_Triangle_2DINVZB_16(&face, video_buffer, lpitch, zbuffer, zpitch);

       } // end if
    else
    if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_GOURAUD)
       {
        // {andre take advantage of the data structures later..}
        // set the vertices
        face.tvlist[0].x  = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
        face.tvlist[0].y  = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
        face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;
        face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];

        face.tvlist[1].x  = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
        face.tvlist[1].y  = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
        face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;
        face.lit_color[1] = rend_list->poly_ptrs[poly]->lit_color[1];

        face.tvlist[2].x  = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
        face.tvlist[2].y  = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
        face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;
        face.lit_color[2] = rend_list->poly_ptrs[poly]->lit_color[2];

	    // draw the gouraud shaded triangle
        Draw_Gouraud_TriangleINVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);
       } // end if gouraud

    } // end for poly

} // end Draw_RENDERLIST4DV2_SolidINVZB_16

///////////////////////////////////////////////////////////////////////////////////////////

void Draw_RENDERLIST4DV2_Hybrid_Textured_SolidINVZB_16(RENDERLIST4DV2_PTR rend_list, 
                                   UCHAR *video_buffer, 
	   						       int lpitch,
                                   UCHAR *zbuffer,
                                   int zpitch,
                                   float dist1, float dist2)
{
// 16-bit version
// this function "executes" the render list or in other words
// draws all the faces in the list, the function will call the 
// proper rasterizer based on the lighting model of the polygons
// testing function only for demo, place maxperspective distance
// into dist1, and max linear into dist2, after dist2 everything
// will be affine


POLYF4DV2 face; // temp face used to render polygon

// at this point, all we have is a list of polygons and it's time
// to draw them
for (int poly=0; poly < rend_list->num_polys; poly++)
    {
    // render this polygon if and only if it's not clipped, not culled,
    // active, and visible, note however the concecpt of "backface" is 
    // irrelevant in a wire frame engine though
    if (!(rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_ACTIVE) ||
         (rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_CLIPPED ) ||
         (rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_BACKFACE) )
       continue; // move onto next poly

    // need to test for textured first, since a textured poly can either
    // be emissive, or flat shaded, hence we need to call different
    // rasterizers    
    if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_TEXTURE)
       {
       // set the vertices
       face.tvlist[0].x = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;
       face.tvlist[0].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[0].u0;
       face.tvlist[0].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[0].v0;

       face.tvlist[1].x = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;
       face.tvlist[1].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[1].u0;
       face.tvlist[1].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[1].v0;

       face.tvlist[2].x = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;
       face.tvlist[2].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[2].u0;
       face.tvlist[2].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[2].v0;

       // test if this is a mipmapped polygon?
       if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_MIPMAP)
          {
          // determine mip level for this polygon
          int miplevel = (6*rend_list->poly_ptrs[poly]->tvlist[0].z/2000);
       
          if (miplevel > 6) 
              miplevel = 6;

          face.texture = ((BITMAP_IMAGE_PTR *)(rend_list->poly_ptrs[poly]->texture))[miplevel];

          for (int ts = 0; ts < miplevel; ts++)
              {
              face.tvlist[0].u0*=.5;
              face.tvlist[0].v0*=.5;

              face.tvlist[1].u0*=.5;
              face.tvlist[1].v0*=.5;

              face.tvlist[2].u0*=.5;
              face.tvlist[2].v0*=.5;
              } // end for

          } // end if
       else
          {
          // assign the texture without change
          face.texture = rend_list->poly_ptrs[poly]->texture;
          } // end if

       float avg_z = 0.33*(rend_list->poly_ptrs[poly]->tvlist[0].z + 
                           rend_list->poly_ptrs[poly]->tvlist[1].z + 
                           rend_list->poly_ptrs[poly]->tvlist[2].z );
       
       // is this a plain emissive texture?
       if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT)
          {
          // draw the textured triangle as emissive
          if (avg_z < dist1)
             Draw_Textured_Perspective_Triangle_INVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);
          else 
          if (avg_z > dist1 && avg_z < dist2)
             Draw_Textured_PerspectiveLP_Triangle_INVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);
          else
             Draw_Textured_TriangleINVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);

          } // end if
       else
       if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT)
          {
          // draw as flat shaded
          face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];

          if (avg_z < dist1)
             Draw_Textured_Perspective_Triangle_FSINVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);
          else 
          if (avg_z > dist1 && avg_z < dist2)
             Draw_Textured_PerspectiveLP_Triangle_FSINVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);
          else
             Draw_Textured_TriangleFSINVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);

          } // end else if
       else
          {
          // must be gouraud POLY4DV2_ATTR_SHADE_MODE_GOURAUD
          face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];
          face.lit_color[1] = rend_list->poly_ptrs[poly]->lit_color[1];
          face.lit_color[2] = rend_list->poly_ptrs[poly]->lit_color[2];

          Draw_Textured_TriangleGSINVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);
          } // end else

       } // end if      
    else
    if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT) || 
        (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT) )
       {
       // draw as constant shaded
       face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];
       
       // set the vertices
       face.tvlist[0].x = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;

       face.tvlist[1].x = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;

       face.tvlist[2].x = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;

       // draw the triangle with basic flat rasterizer
       Draw_Triangle_2DINVZB_16(&face, video_buffer, lpitch, zbuffer, zpitch);

       } // end if
    else
    if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_GOURAUD)
       {
        // {andre take advantage of the data structures later..}
        // set the vertices
        face.tvlist[0].x  = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
        face.tvlist[0].y  = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
        face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;
        face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];

        face.tvlist[1].x  = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
        face.tvlist[1].y  = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
        face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;
        face.lit_color[1] = rend_list->poly_ptrs[poly]->lit_color[1];

        face.tvlist[2].x  = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
        face.tvlist[2].y  = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
        face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;
        face.lit_color[2] = rend_list->poly_ptrs[poly]->lit_color[2];

	    // draw the gouraud shaded triangle
        Draw_Gouraud_TriangleINVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);
       } // end if gouraud

    } // end for poly

} // end Draw_RENDERLIST4DV2_Hybrid_Textured_SolidINVZB_16





///////////////////////////////////////////////////////////////////////////////////////
// 1/Z BUFFERED ALPHA CHANNEL
///////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////

void Draw_Triangle_2DINVZB_Alpha16(POLYF4DV2_PTR face,   // ptr to face
                           UCHAR *_dest_buffer,   // pointer to video buffer
                           int mem_pitch,         // bytes per line, 320, 640 etc.
                           UCHAR *_zbuffer,       // pointer to z-buffer
                           int zpitch,            // bytes per line of zbuffer
                           int alpha)
{
// this function draws a flat shaded polygon with zbuffering

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    z,
    dz,
    xi,yi,              // the current interpolated x,y
	zi,                 // the current interpolated z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
    dzdyl,   
	zl,
	dzdyr,
	zr;

int x0,y0,tz0,    // cached vertices
	x1,y1,tz1,
	x2,y2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

USHORT color;    // polygon color

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);


// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;


// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

tz1 = (1 <<FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);
            
x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

tz2 = (1 <<FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];


// extract constant color
color = face->lit_color[0];

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dzdyl = ((tz2 - tz0) << 0)/dy; 

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dzdyr = ((tz2 - tz1) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		zl = (tz0 << 0);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dzdyl = ((tz1 - tz0) << 0)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		zl = (tz0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v,w interpolants
		zi = zl;// + FIXP16_ROUND_UP; // ???

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel assume 5.6.5
    		   // screen_ptr[xi] = color;
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + alpha_table_src2[color];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,w,z
			zi+=dz;
			} // end for xi

		// interpolate z,x along right and left edge
		xl+=dxdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel 5.6.5
               // screen_ptr[xi] = color;
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + alpha_table_src2[color];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate z
			zi+=dz;
			} // end for xi

		// interpolate x,z along right and left edge
		xl+=dxdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dzdyl = ((tz2 - tz1) << 0)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << 0)/dyr;  
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dzdyl = ((tz1 - tz0) << 0)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << 0)/dyr;  
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dzdyl = ((tz1 - tz0) << 0)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << 0)/dyr;

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		zl = (tz0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for z interpolants
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		// compute z interpolants
		if ((dx = (xend - xstart))>0)
			{
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel assume 5.6.5
               // screen_ptr[xi] = color;
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + alpha_table_src2[color];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate z
			zi+=dz;
			} // end for xi

		// interpolate z,x along right and left edge
		xl+=dxdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dzdyl = ((tz2 - tz1) << 0)/dyl;  

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dzdyr = ((tz1 - tz2) << 0)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w,z interpolants
		zi = zl; // + FIXP16_ROUND_UP;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel assume 5.6.5
    		   // screen_ptr[xi] = color;
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + alpha_table_src2[color];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate z
			zi+=dz;
			} // end for xi

		// interpolate x,z along right and left edge
		xl+=dxdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dzdyr = ((tz1 - tz2) << 0)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			zr+=dzdyr;
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Triangle_2DINVZB_Alpha16


///////////////////////////////////////////////////////////////////////////////////////

void Draw_Textured_TriangleINVZB_Alpha16(POLYF4DV2_PTR face,  // ptr to face
                                    UCHAR *_dest_buffer, // pointer to video buffer
                                    int mem_pitch,       // bytes per line, 320, 640 etc.
                                    UCHAR *_zbuffer,     // pointer to z-buffer
                                    int zpitch,          // bytes per line of zbuffer
                                    int alpha)
{
// this function draws a textured triangle in 16-bit mode

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = (int)(face->tvlist[v0].u0);
tv0 = (int)(face->tvlist[v0].v0);

tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = (int)(face->tvlist[v1].u0);
tv1 = (int)(face->tvlist[v1].v0);

tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = (int)(face->tvlist[v2].u0);
tv2 = (int)(face->tvlist[v2].v0);

tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz2 - tz0) << 0)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz1 - tz0) << 0)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ????
		
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               //screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)]];


               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ????
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               //screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)]];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz2 - tz1) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dzdyr = ((tz2 - tz0) << 0)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               //screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)]];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ????
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               //screen_ptr[xi] = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)]];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_Triangle_INVZB_Alpha16

////////////////////////////////////////////////////////////////////////////////

void Draw_Textured_Perspective_Triangle_INVZB_Alpha16(POLYF4DV2_PTR face,  // ptr to face
                                                   UCHAR *_dest_buffer, // pointer to video buffer
                                                   int mem_pitch,       // bytes per line, 320, 640 etc.
                                                   UCHAR *_zbuffer,     // pointer to z-buffer
                                                   int zpitch,          // bytes per line of zbuffer
                                                   int alpha)
{
// this function draws a textured triangle in 16-bit mode using a 1/z buffer and piecewise linear
// perspective correct texture mappping, 1/z, u/z, v/z are interpolated down each edge then to draw
// each span U and V are computed for each end point and the space is broken up into 32 pixel
// spans where the correct U,V is computed at each point along the span, but linearly interpolated
// across the span

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = ((int)(face->tvlist[v0].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tv0 = ((int)(face->tvlist[v0].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = ((int)(face->tvlist[v1].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tv1 = ((int)(face->tvlist[v1].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = ((int)(face->tvlist[v2].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tv2 = ((int)(face->tvlist[v2].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];


// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{
	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << 0)/dy;  
	dvdyl = ((tv2 - tv0) << 0)/dy;    
	dzdyl = ((tz2 - tz0) << 0)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << 0)/dy;  
	dvdyr = ((tv2 - tv1) << 0)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << 0);
		vr = dvdyr*dy + (tv1 << 0);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu1 << 0);
		vr = (tv1 << 0);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;
		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << 0)/dy;  
	dvdyl = ((tv1 - tv0) << 0)/dy;    
	dzdyl = ((tz1 - tz0) << 0)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << 0)/dy;  
	dvdyr = ((tv2 - tv0) << 0)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;
		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + 
                                                          (((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)]];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;
		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else


		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + 
                                                          (((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)]];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << 0)/dyl;  
		dvdyl = ((tv2 - tv1) << 0)/dyl;    
		dzdyl = ((tz2 - tz1) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << 0);
		vl = dvdyl*dyl + (tv1 << 0);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << 0);
		vr = dvdyr*dyr + (tv0 << 0);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   		
		dzdyr = ((tz2 - tz0) << 0)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else


		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + 
                                                          (((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)]];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi]) 
               {
   			   // write textel
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + 
                                                          (((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)]];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_Perspective_Triangle_INVZB_Alpha16

//////////////////////////////////////////////////////////////////////////////////////////

void Draw_Textured_PerspectiveLP_Triangle_INVZB_Alpha16(POLYF4DV2_PTR face,  // ptr to face
                                                   UCHAR *_dest_buffer, // pointer to video buffer
                                                   int mem_pitch,       // bytes per line, 320, 640 etc.
                                                   UCHAR *_zbuffer,     // pointer to z-buffer
                                                   int zpitch,          // bytes per line of zbuffer
                                                   int alpha)
{
// this function draws a textured triangle in 16-bit mode using a 1/z buffer and piecewise linear
// perspective correct texture mappping, 1/z, u/z, v/z are interpolated down each edge then to draw
// each span U and V are computed for each end point and the space is broken up into 32 pixel
// spans where the correct U,V is computed at each point along the span, but linearly interpolated
// across the span

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int ur2, ul2, vr2, vl2;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = ((int)(face->tvlist[v0].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tv0 = ((int)(face->tvlist[v0].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = ((int)(face->tvlist[v1].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tv1 = ((int)(face->tvlist[v1].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = ((int)(face->tvlist[v2].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tv2 = ((int)(face->tvlist[v2].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];


// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{
	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << 0)/dy;  
	dvdyl = ((tv2 - tv0) << 0)/dy;    
	dzdyl = ((tz2 - tz0) << 0)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << 0)/dy;  
	dvdyr = ((tv2 - tv1) << 0)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << 0);
		vr = dvdyr*dy + (tv1 << 0);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu1 << 0);
		vr = (tv1 << 0);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;
		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << 0)/dy;  
	dvdyl = ((tv1 - tv0) << 0)/dy;    
	dzdyl = ((tz1 - tz0) << 0)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << 0)/dy;  
	dvdyr = ((tv2 - tv0) << 0)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;
		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[textmap[ (ui >> FIXP22_SHIFT) + 
                                                          ((vi >> FIXP22_SHIFT) << texture_shift2)]];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;
		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else


		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[textmap[ (ui >> FIXP22_SHIFT) + 
                                                          ((vi >> FIXP22_SHIFT) << texture_shift2)]];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << 0)/dyl;  
		dvdyl = ((tv2 - tv1) << 0)/dyl;    
		dzdyl = ((tz2 - tz1) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << 0);
		vl = dvdyl*dyl + (tv1 << 0);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << 0);
		vr = dvdyr*dyr + (tv0 << 0);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   		
		dzdyr = ((tz2 - tz0) << 0)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else


		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
   			   // write textel
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[textmap[ (ui >> FIXP22_SHIFT) + 
                                                          ((vi >> FIXP22_SHIFT) << texture_shift2)]];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;
	
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi]) 
               {
   			   // write textel
               screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[textmap[ (ui >> FIXP22_SHIFT) + 
                                                          ((vi >> FIXP22_SHIFT) << texture_shift2)]];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_PerspectiveLP_Triangle_INVZB_Alpha16

//////////////////////////////////////////////////////////////////////////////////////////

void Draw_Textured_Perspective_Triangle_FSINVZB_Alpha16(POLYF4DV2_PTR face,  // ptr to face
                                                   UCHAR *_dest_buffer, // pointer to video buffer
                                                   int mem_pitch,       // bytes per line, 320, 640 etc.
                                                   UCHAR *_zbuffer,     // pointer to z-buffer
                                                   int zpitch,          // bytes per line of zbuffer
                                                   int alpha)
{
// this function draws a textured triangle in 16-bit mode using a 1/z buffer and piecewise linear
// perspective correct texture mappping, 1/z, u/z, v/z are interpolated down each edge then to draw
// each span U and V are computed for each end point and the space is broken up into 32 pixel
// spans where the correct U,V is computed at each point along the span, but linearly interpolated
// across the span

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

USHORT r_base, g_base, b_base,
       r_textel, g_textel, b_textel, textel;


UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract base color of lit poly, so we can modulate texture a bit
// for lighting
_RGB565FROM16BIT(face->lit_color[0], &r_base, &g_base, &b_base);

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = ((int)(face->tvlist[v0].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tv0 = ((int)(face->tvlist[v0].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = ((int)(face->tvlist[v1].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tv1 = ((int)(face->tvlist[v1].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = ((int)(face->tvlist[v2].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tv2 = ((int)(face->tvlist[v2].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{
	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << 0)/dy;  
	dvdyl = ((tv2 - tv0) << 0)/dy;    
	dzdyl = ((tz2 - tz0) << 0)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << 0)/dy;  
	dvdyr = ((tv2 - tv1) << 0)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << 0);
		vr = dvdyr*dy + (tv1 << 0);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu1 << 0);
		vr = (tv1 << 0);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;
		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << 0)/dy;  
	dvdyl = ((tv1 - tv0) << 0)/dy;    
	dzdyl = ((tz1 - tz0) << 0)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << 0)/dy;  
	dvdyr = ((tv2 - tv0) << 0)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;
		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
  	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

		
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;
		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else


		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
  	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << 0)/dyl;  
		dvdyl = ((tv2 - tv1) << 0)/dyl;    
		dzdyl = ((tz2 - tz1) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << 0);
		vl = dvdyl*dyl + (tv1 << 0);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << 0);
		vr = dvdyr*dyr + (tv0 << 0);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   		
		dzdyr = ((tz2 - tz0) << 0)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else


		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
  	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul + 0;
		vi = vl + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul) / dx;
			dv = (vr - vl) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur - ul) ;
			dv = (vr - vl) ;
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[ ((ui << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) + ( ((vi << (FIXP28_SHIFT - FIXP22_SHIFT)) / zi) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
  	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_Perspective_Triangle_FSINVZB_Alpha16


//////////////////////////////////////////////////////////////////////////////////////////

void Draw_Textured_PerspectiveLP_Triangle_FSINVZB_Alpha16(POLYF4DV2_PTR face,  // ptr to face
                                                   UCHAR *_dest_buffer, // pointer to video buffer
                                                   int mem_pitch,       // bytes per line, 320, 640 etc.
                                                   UCHAR *_zbuffer,     // pointer to z-buffer
                                                   int zpitch,          // bytes per line of zbuffer
                                                   int alpha)
{
// this function draws a textured triangle in 16-bit mode using a 1/z buffer and piecewise linear
// perspective correct texture mappping, 1/z, u/z, v/z are interpolated down each edge then to draw
// each span U and V are computed for each end point and the space is broken up into 32 pixel
// spans where the correct U,V is computed at each point along the span, but linearly interpolated
// across the span

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,           // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

int ur2, ul2, vr2, vl2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

USHORT r_base, g_base, b_base,
       r_textel, g_textel, b_textel, textel;


UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y ,face->tvlist[v2].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract base color of lit poly, so we can modulate texture a bit
// for lighting
_RGB565FROM16BIT(face->lit_color[0], &r_base, &g_base, &b_base);

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = ((int)(face->tvlist[v0].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tv0 = ((int)(face->tvlist[v0].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = ((int)(face->tvlist[v1].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tv1 = ((int)(face->tvlist[v1].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = ((int)(face->tvlist[v2].u0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tv2 = ((int)(face->tvlist[v2].v0+0.5) << FIXP22_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);


// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];

// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{
	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << 0)/dy;  
	dvdyl = ((tv2 - tv0) << 0)/dy;    
	dzdyl = ((tz2 - tz0) << 0)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << 0)/dy;  
	dvdyr = ((tv2 - tv1) << 0)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;  

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << 0);
		vr = dvdyr*dy + (tv1 << 0);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu1 << 0);
		vr = (tv1 << 0);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;
		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << 0)/dy;  
	dvdyl = ((tv1 - tv0) << 0)/dy;    
	dzdyl = ((tz1 - tz0) << 0)/dy;   

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << 0)/dy;  
	dvdyr = ((tv2 - tv0) << 0)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;
		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;
		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[ (ui >> FIXP22_SHIFT) + ((vi >> FIXP22_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
  	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

		
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;
		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else


		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[ (ui >> FIXP22_SHIFT) + ((vi >> FIXP22_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
  	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << 0)/dyl;  
		dvdyl = ((tv2 - tv1) << 0)/dyl;    
		dzdyl = ((tz2 - tz1) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << 0);
		vl = dvdyl*dyl + (tv1 << 0);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << 0);
		vr = dvdyr*dyr + (tv0 << 0);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << 0);
		vl = dvdyl*dy + (tv0 << 0);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << 0);
		vr = dvdyr*dy + (tv0 << 0);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << 0)/dyl;  
		dvdyl = ((tv1 - tv0) << 0)/dyl;    
		dzdyl = ((tz1 - tz0) << 0)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << 0)/dyr;  
		dvdyr = ((tv2 - tv0) << 0)/dyr;   		
		dzdyr = ((tz2 - tz0) << 0)/dyr;  

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << 0);
		vl = (tv0 << 0);
		zl = (tz0 << 0);

		ur = (tu0 << 0);
		vr = (tv0 << 0);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else


		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[ (ui >> FIXP22_SHIFT) + ((vi >> FIXP22_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
  	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

        ul2 = ((ul << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        ur2 = ((ur << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;

        vl2 = ((vl << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zl >> 6) ) << 16;
        vr2 = ((vr << (FIXP28_SHIFT - FIXP22_SHIFT)) / (zr >> 6) ) << 16;
		
		// compute starting points for u,v interpolants
		zi = zl + 0; // ????
		ui = ul2 + 0;
		vi = vl2 + 0;
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur2 - ul2) / dx;
			dv = (vr2 - vl2) / dx;
			dz = (zr - zl) / dx;
			} // end if
		else
			{
			du = (ur2 - ul2) ;
			dv = (vr2 - vl2) ;
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[ (ui >> FIXP22_SHIFT) + ((vi >> FIXP22_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
  	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if
			
			// interpolate u,v
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << 0)/dyl;  
			dvdyl = ((tv2 - tv1) << 0)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << 0);
			vl = (tv1 << 0);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << 0)/dyr;  
			dvdyr = ((tv1 - tv2) << 0)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr; 

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << 0);
			vr = (tv2 << 0);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_PerspectiveLP_Triangle_FSINVZB_Alpha16


///////////////////////////////////////////////////////////////////////////////

void Draw_Textured_TriangleFSINVZB_Alpha16(POLYF4DV2_PTR face, // ptr to face
                                 UCHAR *_dest_buffer,  // pointer to video buffer
                                 int mem_pitch,        // bytes per line, 320, 640 etc.
                                 UCHAR *_zbuffer,       // pointer to z-buffer
                                 int zpitch,           // bytes per line of zbuffer
                                 int alpha)
{
// this function draws a textured triangle in 16-bit mode with flat shading

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,z,
    du,dv,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,zi,            // the current interpolated u,v,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dzdyl,    
	zl,
	dvdyl,   
	vl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dzdyr,
	zr;

USHORT r_base, g_base, b_base,
       r_textel, g_textel, b_textel, textel;

int x0,y0,tu0,tv0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tz1,
	x2,y2,tu2,tv2,tz2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;


#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;


// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP( face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// extract base color of lit poly, so we can modulate texture a bit
// for lighting
_RGB565FROM16BIT(face->lit_color[0], &r_base, &g_base, &b_base);

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);
tu0 = (int)(face->tvlist[v0].u0);
tv0 = (int)(face->tvlist[v0].v0);
tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);
tu1 = (int)(face->tvlist[v1].u0);
tv1 = (int)(face->tvlist[v1].v0);
tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);
tu2 = (int)(face->tvlist[v2].u0);
tv2 = (int)(face->tvlist[v2].v0);
tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];



// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz2 - tz0) << 0)/dy;    

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dzdyl = ((tz1 - tz0) << 0)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl; //  + FIXP16_ROUND_UP; // ???
		
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
  	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];


               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,z
			ui+=du;
			vi+=dv;
			zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl; //  + FIXP16_ROUND_UP; // ???
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
            dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
  	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,z
			ui+=du;
			vi+=dv;
            zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
	    zl+=dzdyl;

		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
        zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
        dzdyl = ((tz2 - tz1) << 0)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
        dzdyr = ((tz2 - tz0) << 0)/dyr;   		

		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);
		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
        zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);
		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
        zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
        dzdyl = ((tz1 - tz0) << 0)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
        dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
        zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
        zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
        dzdyl = ((tz1 - tz0) << 0)/dyl;    

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
        dzdyr = ((tz2 - tz0) << 0)/dyr;   		

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
        zl = (tz0 << 0);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
        zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else


    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
        zi = zl;// + FIXP16_ROUND_UP; // ???
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
            dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
            dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
  	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v
			ui+=du;
			vi+=dv;
            zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
     		// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl;  

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else


			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,z interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		zi = zl; //  + FIXP16_ROUND_UP; // ???
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
            dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
            dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel
		       // get textel first
 			   textel = textmap[(ui >> FIXP16_SHIFT) + ((vi >> FIXP16_SHIFT) << texture_shift2)];

               // extract rgb components
               r_textel  = ((textel >> 11)       ); 
               g_textel  = ((textel >> 5)  & 0x3f); 
               b_textel =   (textel        & 0x1f);

               // modulate textel with lit background color
               r_textel*=r_base; 
               g_textel*=g_base;
               b_textel*=b_base;

               // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
               // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
               // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
               // and they all cancel out for the most part, but we will need logical anding, we will do
               // it later when we optimize more...
  	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> 5) + ((g_textel >> 6) << 5) + ((r_textel >> 5) << 11))];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,z
			ui+=du;
			vi+=dv;
            zi+=dz;
			} // end for xi

		// interpolate u,v,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
        zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
        zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag
			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dzdyl = ((tz2 - tz1) << 0)/dyl; 

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_TriangleFSINVZB_Alpha16

////////////////////////////////////////////////////////////////////////////////

void Draw_Textured_TriangleGSINVZB_Alpha16(POLYF4DV2_PTR face,   // ptr to face
                                      UCHAR *_dest_buffer, // pointer to video buffer
                                      int mem_pitch,       // bytes per line, 320, 640 etc.
                                      UCHAR *_zbuffer,       // pointer to z-buffer
                                      int zpitch,          // bytes per line of zbuffer
                                      int alpha)

{
// this function draws a textured gouraud shaded polygon, and z bufferedbased on the affine texture mapper, 
// we simply interpolate the (R,G,B) values across the polygons along with the texture coordinates
// and then modulate to get the final color 

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;


int dx,dy,dyl,dyr,      // general deltas
    u,v,w,z, s,t,
    du,dv,dw,dz, ds, dt, 
    xi,yi,             // the current interpolated x,y
	ui,vi,wi,zi, si, ti,    // the current interpolated u,v
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
	dudyl,    
	ul,
	dvdyl,   
	vl,
	dwdyl,   
	wl,
	dzdyl,   
	zl,
	dsdyl,    
	sl,
	dtdyl,   
	tl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dwdyr,
	wr,
	dzdyr,
	zr,
	dsdyr,
	sr,
	dtdyr,
	tr;

int x0,y0,tu0,tv0,tw0, tz0, ts0,tt0,    // cached vertices
	x1,y1,tu1,tv1,tw1, tz1, ts1,tt1,
	x2,y2,tu2,tv2,tw2, tz2, ts2,tt2;

int r_base0, g_base0, b_base0,
    r_base1, g_base1, b_base1,
    r_base2, g_base2, b_base2;


UINT r_textel, g_textel, b_textel;
USHORT textel;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif


// extract texture map
textmap = (USHORT *)face->texture->buffer;

// extract base 2 of texture width
int texture_shift2 = logbase2ofx[face->texture->width];

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.0);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.0);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.0);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.0);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.0);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.0);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;

// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// assume 5.6.5 format -- sorry!
// we can't afford a function call in the inner loops, so we must write 
// two hard coded versions, if we want support for both 5.6.5, and 5.5.5
_RGB565FROM16BIT(face->lit_color[v0], &r_base0, &g_base0, &b_base0);
_RGB565FROM16BIT(face->lit_color[v1], &r_base1, &g_base1, &b_base1);
_RGB565FROM16BIT(face->lit_color[v2], &r_base2, &g_base2, &b_base2);

// scale to 8 bit 
r_base0 <<= 3;
g_base0 <<= 2;
b_base0 <<= 3;

// scale to 8 bit 
r_base1 <<= 3;
g_base1 <<= 2;
b_base1 <<= 3;

// scale to 8 bit 
r_base2 <<= 3;
g_base2 <<= 2;
b_base2 <<= 3;

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);
ts0 = (int)(face->tvlist[v0].u0);
tt0 = (int)(face->tvlist[v0].v0);

tu0 = r_base0;
tv0 = g_base0; 
tw0 = b_base0; 

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);
ts1 = (int)(face->tvlist[v1].u0);
tt1 = (int)(face->tvlist[v1].v0);

tu1 = r_base1;
tv1 = g_base1; 
tw1 = b_base1; 

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

tz2 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);
ts2 = (int)(face->tvlist[v2].u0);
tt2 = (int)(face->tvlist[v2].v0);

tu2 = r_base2; 
tv2 = g_base2; 
tw2 = b_base2; 

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];


// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{

	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw2 - tw0) << FIXP16_SHIFT)/dy;  
	dzdyl = ((tz2 - tz0) << 0)/dy; 
	
    dsdyl = ((ts2 - ts0) << FIXP16_SHIFT)/dy;    
	dtdyl = ((tt2 - tt0) << FIXP16_SHIFT)/dy;  

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;   

	dsdyr = ((ts2 - ts1) << FIXP16_SHIFT)/dy;   
	dtdyr = ((tt2 - tt1) << FIXP16_SHIFT)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << 0);

		sr = dsdyr*dy + (ts1 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt1 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);


		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		wr = (tw1 << FIXP16_SHIFT);
		zr = (tz1 << 0);

		sr = (ts1 << FIXP16_SHIFT);
		tr = (tt1 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dy; 
	dzdyl = ((tz1 - tz0) << 0)/dy; 

	dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dy;    
	dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dy;   
	dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dy;   


	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		sr = dsdyr*dy + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt0 << FIXP16_SHIFT);


		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);
		zr = (tz0 << 0);

		sr = (ts0 << FIXP16_SHIFT);
		tr = (tt0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???
		
        si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			zi+=dx*dz;
			
			si+=dx*ds;
			ti+=dx*dt;

			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
            { 
		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> (FIXP16_SHIFT+8)) + 
                                              ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                                              ((r_textel >> (FIXP16_SHIFT+8)) << 11))];



            // update z-buffer
            z_ptr[xi] = zi;   

            } // end if 

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		sl+=dsdyl;
		tl+=dtdyl;

		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;
 
		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
            { 
		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> (FIXP16_SHIFT+8)) + 
                                              ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                                              ((r_textel >> (FIXP16_SHIFT+8)) << 11))];

            // update z-buffer
            z_ptr[xi] = zi;   

            } // end if 

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;

		sl+=dsdyl;
		tl+=dtdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  
		dzdyl = ((tz2 - tz1) << 0)/dyl;  

		dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;  

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;  

		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);

		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		wl = dwdyl*dyl + (tw1 << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << 0);

		sl = dsdyl*dyl + (ts1 << FIXP16_SHIFT);
		tl = dtdyl*dyl + (tt1 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);

		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dyr + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << 0);

		sr = dsdyr*dyr + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dyr + (tt0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
		
			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);

         	SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);

			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);

			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl; 
		dzdyl = ((tz1 - tz0) << 0)/dyl; 

		dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;   
		
		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;   

		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		sl = dsdyl*dy + (ts0 << FIXP16_SHIFT);
		tl = dtdyl*dy + (tt0 << FIXP16_SHIFT);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		sr = dsdyr*dy + (ts0 << FIXP16_SHIFT);
		tr = dtdyr*dy + (tt0 << FIXP16_SHIFT);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);

			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);

			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);

			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);

			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl;   
		dzdyl = ((tz1 - tz0) << 0)/dyl;  

		dsdyl = ((ts1 - ts0) << FIXP16_SHIFT)/dyl;    
		dtdyl = ((tt1 - tt0) << FIXP16_SHIFT)/dyl;   

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << 0)/dyr;

		dsdyr = ((ts2 - ts0) << FIXP16_SHIFT)/dyr;   		
		dtdyr = ((tt2 - tt0) << FIXP16_SHIFT)/dyr;

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		sl = (ts0 << FIXP16_SHIFT);
		tl = (tt0 << FIXP16_SHIFT);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);
		zr = (tz0 << 0);

		sr = (ts0 << FIXP16_SHIFT);
		tr = (tt0 << FIXP16_SHIFT);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);

			SWAP(dsdyl,dsdyr,temp);
			SWAP(dtdyl,dtdyr,temp);


			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);

			SWAP(sl,sr,temp);
			SWAP(tl,tr,temp);


			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			SWAP(ts1,ts2,temp);
			SWAP(tt1,tt2,temp);

			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			zi+=dx*dz;
			
			si+=dx*ds;
			ti+=dx*dt;

			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
            { 
		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> (FIXP16_SHIFT+8)) + 
                                              ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                                              ((r_textel >> (FIXP16_SHIFT+8)) << 11))];

            // update z-buffer
            z_ptr[xi] = zi;   

            } // end if 

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;

			si+=ds;
			ti+=dt;

			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
        ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		sl+=dsdyl;
		tl+=dtdyl;

		xr+=dxdyr;
     	ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  
			dzdyl = ((tz2 - tz1) << 0)/dyl;  

			dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;   		
			dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;  

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			sl = (ts1 << FIXP16_SHIFT);
			tl = (tt1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			zl+=dzdyl;

			sl+=dsdyl;
			tl+=dtdyl;

			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;   

			dsdyr = ((ts1 - ts2) << FIXP16_SHIFT)/dyr;   		
			dtdyr = ((tt1 - tt2) << FIXP16_SHIFT)/dyr;  

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			sr = (ts2 << FIXP16_SHIFT);
			tr = (tt2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			zr+=dzdyr;
		
			sr+=dsdyr;
			tr+=dtdyr;
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		si = sl + FIXP16_ROUND_UP;
		ti = tl + FIXP16_ROUND_UP;

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;

			ds = (sr - sl)/dx;
			dt = (tr - tl)/dx;

			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);

			ds = (sr - sl);
			dt = (tr - tl);

			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
			// write textel assume 5.6.5
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
            { 
		    // get textel first
 			textel = textmap[(si >> FIXP16_SHIFT) + ((ti >> FIXP16_SHIFT) << texture_shift2)];

            // extract rgb components
            r_textel  = ((textel >> 11)       ); 
            g_textel  = ((textel >> 5)  & 0x3f); 
            b_textel =   (textel        & 0x1f);

            // modulate textel with gouraud shading
            r_textel*=ui; 
            g_textel*=vi;
            b_textel*=wi;

            // finally write pixel, note that we did the math such that the results are r*32, g*64, b*32
            // hence we need to divide the results by 32,64,32 respetively, BUT since we need to shift
            // the results to fit into the destination 5.6.5 word, we can take advantage of the shifts
            // and they all cancel out for the most part, but we will need logical anding, we will do
            // it later when we optimize more...
            screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                             alpha_table_src2[((b_textel >> (FIXP16_SHIFT+8)) + 
                                              ((g_textel >> (FIXP16_SHIFT+8)) << 5) + 
                                              ((r_textel >> (FIXP16_SHIFT+8)) << 11))];

            // update z-buffer
            z_ptr[xi] = zi;   

            } // end if 

			// interpolate u,v
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;

			si+=ds;
			ti+=dt;
			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;

		sl+=dsdyl;
		tl+=dtdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		sr+=dsdyr;
		tr+=dtdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance zbuffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;   
			dzdyl = ((tz2 - tz1) << 0)/dyl;  

			dsdyl = ((ts2 - ts1) << FIXP16_SHIFT)/dyl;   		
			dtdyl = ((tt2 - tt1) << FIXP16_SHIFT)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			sl = (ts1 << FIXP16_SHIFT);
			tl = (tt1 << FIXP16_SHIFT);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			zl+=dzdyl;

			sl+=dsdyl;
			tl+=dtdyl;

			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   
			dzdyr = ((tz1 - tz2) << 0)/dyr;   

			dsdyr = ((ts1 - ts2) << FIXP16_SHIFT)/dyr;   		
			dtdyr = ((tt1 - tt2) << FIXP16_SHIFT)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			sr = (ts2 << FIXP16_SHIFT);
			tr = (tt2 << FIXP16_SHIFT);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			zr+=dzdyr;

			sr+=dsdyr;
			tr+=dtdyr;

			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Textured_TriangleGSINVZB_Alpha16

///////////////////////////////////////////////////////////////////////////////

void Draw_Gouraud_TriangleINVZB_Alpha16(POLYF4DV2_PTR face,   // ptr to face
                                    UCHAR *_dest_buffer,   // pointer to video buffer
                                    int mem_pitch,         // bytes per line, 320, 640 etc.
                                    UCHAR *_zbuffer,       // pointer to z-buffer
                                    int zpitch,            // bytes per line of zbuffer
                                    int alpha)
{
// this function draws a gouraud shaded polygon, based on the affine texture mapper, instead
// of interpolating the texture coordinates, we simply interpolate the (R,G,B) values across
// the polygons, I simply needed at another interpolant, I have mapped u->red, v->green, w->blue
// also a new interpolant for z buffering has been added

int v0=0,
    v1=1,
	v2=2,
	temp=0,
	tri_type = TRI_TYPE_NONE,
	irestart = INTERP_LHS;

int dx,dy,dyl,dyr,      // general deltas
    u,v,w,z,
    du,dv,dw,dz,
    xi,yi,              // the current interpolated x,y
	ui,vi,wi,zi,        // the current interpolated u,v,w,z
	index_x,index_y,    // looping vars
	x,y,                // hold general x,y
	xstart,
	xend,
	ystart,
	yrestart,
	yend,
	xl,                 
	dxdyl,              
	xr,
	dxdyr,             
    dudyl,    
	ul,
	dvdyl,   
	vl,
	dwdyl,   
	wl,
	dzdyl,   
	zl,
	dudyr,
	ur,
	dvdyr,
	vr,
	dwdyr,
	wr,
	dzdyr,
	zr;

int x0,y0,tu0,tv0,tw0,tz0,    // cached vertices
	x1,y1,tu1,tv1,tw1,tz1,
	x2,y2,tu2,tv2,tw2,tz2;

int r_base0, g_base0, b_base0,
    r_base1, g_base1, b_base1,
    r_base2, g_base2, b_base2;

USHORT *screen_ptr  = NULL,
	   *screen_line = NULL,
	   *textmap     = NULL,
       *dest_buffer = (USHORT *)_dest_buffer;

UINT  *z_ptr = NULL,
      *zbuffer = (UINT *)_zbuffer;

#ifdef DEBUG_ON
	// track rendering stats
    debug_polys_rendered_per_frame++;
#endif

// adjust memory pitch to words, divide by 2
mem_pitch >>=1;

// adjust zbuffer pitch for 32 bit alignment
zpitch >>= 2;

// apply fill convention to coordinates
face->tvlist[0].x = (int)(face->tvlist[0].x+0.5);
face->tvlist[0].y = (int)(face->tvlist[0].y+0.5);

face->tvlist[1].x = (int)(face->tvlist[1].x+0.5);
face->tvlist[1].y = (int)(face->tvlist[1].y+0.5);

face->tvlist[2].x = (int)(face->tvlist[2].x+0.5);
face->tvlist[2].y = (int)(face->tvlist[2].y+0.5);

// first trivial clipping rejection tests 
if (((face->tvlist[0].y < min_clip_y)  && 
	 (face->tvlist[1].y < min_clip_y)  &&
	 (face->tvlist[2].y < min_clip_y)) ||

	((face->tvlist[0].y > max_clip_y)  && 
	 (face->tvlist[1].y > max_clip_y)  &&
	 (face->tvlist[2].y > max_clip_y)) ||

	((face->tvlist[0].x < min_clip_x)  && 
	 (face->tvlist[1].x < min_clip_x)  &&
	 (face->tvlist[2].x < min_clip_x)) ||

	((face->tvlist[0].x > max_clip_x)  && 
	 (face->tvlist[1].x > max_clip_x)  &&
	 (face->tvlist[2].x > max_clip_x)))
   return;


// sort vertices
if (face->tvlist[v1].y < face->tvlist[v0].y) 
	{SWAP(v0,v1,temp);} 

if (face->tvlist[v2].y < face->tvlist[v0].y) 
	{SWAP(v0,v2,temp);}

if (face->tvlist[v2].y < face->tvlist[v1].y) 
	{SWAP(v1,v2,temp);}

// now test for trivial flat sided cases
if (FCMP(face->tvlist[v0].y, face->tvlist[v1].y))
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_TOP;

	// sort vertices left to right
	if (face->tvlist[v1].x < face->tvlist[v0].x) 
		{SWAP(v0,v1,temp);}

	} // end if
else
// now test for trivial flat sided cases
if (FCMP(face->tvlist[v1].y, face->tvlist[v2].y) )
	{ 
	// set triangle type
	tri_type = TRI_TYPE_FLAT_BOTTOM;

	// sort vertices left to right
	if (face->tvlist[v2].x < face->tvlist[v1].x) 
		{SWAP(v1,v2,temp);}
	
	} // end if
else
	{
	// must be a general triangle
	tri_type = TRI_TYPE_GENERAL;

	} // end else

// assume 5.6.5 format -- sorry!
// we can't afford a function call in the inner loops, so we must write 
// two hard coded versions, if we want support for both 5.6.5, and 5.5.5
_RGB565FROM16BIT(face->lit_color[v0], &r_base0, &g_base0, &b_base0);
_RGB565FROM16BIT(face->lit_color[v1], &r_base1, &g_base1, &b_base1);
_RGB565FROM16BIT(face->lit_color[v2], &r_base2, &g_base2, &b_base2);

// scale to 8 bit 
r_base0 <<= 3;
g_base0 <<= 2;
b_base0 <<= 3;

// scale to 8 bit 
r_base1 <<= 3;
g_base1 <<= 2;
b_base1 <<= 3;

// scale to 8 bit 
r_base2 <<= 3;
g_base2 <<= 2;
b_base2 <<= 3;

// extract vertices for processing, now that we have order
x0  = (int)(face->tvlist[v0].x+0.0);
y0  = (int)(face->tvlist[v0].y+0.0);

tz0 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v0].z+0.5);
tu0 = r_base0;
tv0 = g_base0; 
tw0 = b_base0; 

x1  = (int)(face->tvlist[v1].x+0.0);
y1  = (int)(face->tvlist[v1].y+0.0);

tz1 = (1 << FIXP28_SHIFT) / (int)(face->tvlist[v1].z+0.5);
tu1 = r_base1;
tv1 = g_base1; 
tw1 = b_base1; 

x2  = (int)(face->tvlist[v2].x+0.0);
y2  = (int)(face->tvlist[v2].y+0.0);

tz2 = (1 <<FIXP28_SHIFT) / (int)(face->tvlist[v2].z+0.5);
tu2 = r_base2; 
tv2 = g_base2; 
tw2 = b_base2; 

// degenerate triangle
if ( ((x0 == x1) && (x1 == x2)) || ((y0 ==  y1) && (y1 == y2)))
   return;

// assign both source1 and source2 alpha tables based on polygon alpha level
USHORT *alpha_table_src1 = (USHORT *)&rgb_alpha_table[(NUM_ALPHA_LEVELS-1) - alpha][0];
USHORT *alpha_table_src2 = (USHORT *)&rgb_alpha_table[alpha][0];


// set interpolation restart value
yrestart = y1;

// what kind of triangle
if (tri_type & TRI_TYPE_FLAT_MASK)
	{
	if (tri_type == TRI_TYPE_FLAT_TOP)
	{
	// compute all deltas
	dy = (y2 - y0);

	dxdyl = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv2 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw2 - tw0) << FIXP16_SHIFT)/dy;  
	dzdyl = ((tz2 - tz0) << 0)/dy; 

	dxdyr = ((x2 - x1)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu1) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv1) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw1) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz1) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x1  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu1 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv1 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw1 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz1 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x1 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu1 << FIXP16_SHIFT);
		vr = (tv1 << FIXP16_SHIFT);
		wr = (tw1 << FIXP16_SHIFT);
		zr = (tz1 << 0);

		// set starting y
		ystart = y0;

		} // end else

	} // end if flat top
	else
	{
	// must be flat bottom

	// compute all deltas
	dy = (y1 - y0);

	dxdyl = ((x1 - x0)   << FIXP16_SHIFT)/dy;
	dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dy;    
	dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dy; 
	dzdyl = ((tz1 - tz0) << 0)/dy; 

	dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dy;
	dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dy;  
	dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dy;   
	dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dy;   
	dzdyr = ((tz2 - tz0) << 0)/dy;   

	// test for y clipping
	if (y0 < min_clip_y)
		{
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		} // end if
	else
		{
		// no clipping

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		} // end else	

	} // end else flat bottom

	// test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);

		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???

		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			zi+=dx*dz;
			
			// reset vars
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel assume 5.6.5
 	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[((ui >> (FIXP16_SHIFT+3)) << 11) + 
                                                 ((vi >> (FIXP16_SHIFT+2)) << 5) + 
                                                 (wi >> (FIXP16_SHIFT+3))];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,w,z
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;
			} // end for xi

		// interpolate u,v,w,z,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;
 
		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if clip
	else
	{
	// non-clip version

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel 5.6.5
 	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[((ui >> (FIXP16_SHIFT+3)) << 11) + 
                                                 ((vi >> (FIXP16_SHIFT+2)) << 5) + 
                                                 (wi >> (FIXP16_SHIFT+3))];

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if


			// interpolate u,v,w,z
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;
			} // end for xi

		// interpolate u,v,w,x along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		} // end for y

	} // end if non-clipped

	} // end if
else
if (tri_type==TRI_TYPE_GENERAL)
	{

	// first test for bottom clip, always
	if ((yend = y2) > max_clip_y)
		yend = max_clip_y;

	// pre-test y clipping status
	if (y1 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y2 - y1);

		dxdyl = ((x2  - x1)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  
		dzdyl = ((tz2 - tz1) << 0)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;  
		
		// compute overclip
		dyr = (min_clip_y - y0);
		dyl = (min_clip_y - y1);

		// computer new LHS starting values
		xl = dxdyl*dyl + (x1  << FIXP16_SHIFT);

		ul = dudyl*dyl + (tu1 << FIXP16_SHIFT);
		vl = dvdyl*dyl + (tv1 << FIXP16_SHIFT);
		wl = dwdyl*dyl + (tw1 << FIXP16_SHIFT);
		zl = dzdyl*dyl + (tz1 << 0);

		// compute new RHS starting values
		xr = dxdyr*dyr + (x0  << FIXP16_SHIFT);

		ur = dudyr*dyr + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dyr + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dyr + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dyr + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr > dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
	if (y0 < min_clip_y)
		{
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl; 
		dzdyl = ((tz1 - tz0) << 0)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2  - x0)  << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;   
		dzdyr = ((tz2 - tz0) << 0)/dyr;  
		
		// compute overclip
		dy = (min_clip_y - y0);

		// computer new LHS starting values
		xl = dxdyl*dy + (x0  << FIXP16_SHIFT);
		ul = dudyl*dy + (tu0 << FIXP16_SHIFT);
		vl = dvdyl*dy + (tv0 << FIXP16_SHIFT);
		wl = dwdyl*dy + (tw0 << FIXP16_SHIFT);
		zl = dzdyl*dy + (tz0 << 0);

		// compute new RHS starting values
		xr = dxdyr*dy + (x0  << FIXP16_SHIFT);
		ur = dudyr*dy + (tu0 << FIXP16_SHIFT);
		vr = dvdyr*dy + (tv0 << FIXP16_SHIFT);
		wr = dwdyr*dy + (tw0 << FIXP16_SHIFT);
		zr = dzdyr*dy + (tz0 << 0);

		// compute new starting y
		ystart = min_clip_y;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end if
	else
		{
		// no initial y clipping
	
		// compute all deltas
		// LHS
		dyl = (y1 - y0);

		dxdyl = ((x1  - x0)  << FIXP16_SHIFT)/dyl;
		dudyl = ((tu1 - tu0) << FIXP16_SHIFT)/dyl;  
		dvdyl = ((tv1 - tv0) << FIXP16_SHIFT)/dyl;    
		dwdyl = ((tw1 - tw0) << FIXP16_SHIFT)/dyl;   
		dzdyl = ((tz1 - tz0) << 0)/dyl; 

		// RHS
		dyr = (y2 - y0);	

		dxdyr = ((x2 - x0)   << FIXP16_SHIFT)/dyr;
		dudyr = ((tu2 - tu0) << FIXP16_SHIFT)/dyr;  
		dvdyr = ((tv2 - tv0) << FIXP16_SHIFT)/dyr;   		
		dwdyr = ((tw2 - tw0) << FIXP16_SHIFT)/dyr;
		dzdyr = ((tz2 - tz0) << 0)/dyr;

		// no clipping y

		// set starting values
		xl = (x0 << FIXP16_SHIFT);
		xr = (x0 << FIXP16_SHIFT);

		ul = (tu0 << FIXP16_SHIFT);
		vl = (tv0 << FIXP16_SHIFT);
		wl = (tw0 << FIXP16_SHIFT);
		zl = (tz0 << 0);

		ur = (tu0 << FIXP16_SHIFT);
		vr = (tv0 << FIXP16_SHIFT);
		wr = (tw0 << FIXP16_SHIFT);
		zr = (tz0 << 0);

		// set starting y
		ystart = y0;

		// test if we need swap to keep rendering left to right
		if (dxdyr < dxdyl)
			{
			SWAP(dxdyl,dxdyr,temp);
			SWAP(dudyl,dudyr,temp);
			SWAP(dvdyl,dvdyr,temp);
			SWAP(dwdyl,dwdyr,temp);
			SWAP(dzdyl,dzdyr,temp);
			SWAP(xl,xr,temp);
			SWAP(ul,ur,temp);
			SWAP(vl,vr,temp);
			SWAP(wl,wr,temp);
			SWAP(zl,zr,temp);
			SWAP(x1,x2,temp);
			SWAP(y1,y2,temp);
			SWAP(tu1,tu2,temp);
			SWAP(tv1,tv2,temp);
			SWAP(tw1,tw2,temp);
			SWAP(tz1,tz2,temp);
		
			// set interpolation restart
			irestart = INTERP_RHS;

			} // end if

		} // end else

    // test for horizontal clipping
	if ((x0 < min_clip_x) || (x0 > max_clip_x) ||
		(x1 < min_clip_x) || (x1 > max_clip_x) ||
		(x2 < min_clip_x) || (x2 > max_clip_x))
	{
    // clip version
	// x clipping	

	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);
			} // end else

		///////////////////////////////////////////////////////////////////////

		// test for x clipping, LHS
		if (xstart < min_clip_x)
			{
			// compute x overlap
			dx = min_clip_x - xstart;

			// slide interpolants over
			ui+=dx*du;
			vi+=dx*dv;
			wi+=dx*dw;
			zi+=dx*dz;
			
			// set x to left clip edge
			xstart = min_clip_x;

			} // end if
		
		// test for x clipping RHS
		if (xend > max_clip_x)
			xend = max_clip_x;

		///////////////////////////////////////////////////////////////////////

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel assume 5.6.5
 	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[((ui >> (FIXP16_SHIFT+3)) << 11) + 
                                                 ((vi >> (FIXP16_SHIFT+2)) << 5) + 
                                                 (wi >> (FIXP16_SHIFT+3))];
               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,w,z
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;
			} // end for xi

		// interpolate u,v,w,z,x along right and left edge
		xl+=dxdyl;
        ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
     	ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
		    // test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;  
			dzdyl = ((tz2 - tz1) << 0)/dyl;  

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   		
			dzdyr = ((tz1 - tz2) << 0)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			zr+=dzdyr;
		
			} // end else

			} // end if

		} // end for y

	} // end if
	else
	{
	// no x clipping
	// point screen ptr to starting line
	screen_ptr = dest_buffer + (ystart * mem_pitch);

    // point zbuffer to starting line
    z_ptr = zbuffer + (ystart * zpitch);

	for (yi = ystart; yi < yend; yi++)
		{
		// compute span endpoints
		xstart = ((xl + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		xend   = ((xr + FIXP16_ROUND_UP) >> FIXP16_SHIFT);
		
		// compute starting points for u,v,w,z interpolants
		ui = ul + FIXP16_ROUND_UP;
		vi = vl + FIXP16_ROUND_UP;
		wi = wl + FIXP16_ROUND_UP;
		zi = zl;// + FIXP16_ROUND_UP; // ???
	
		// compute u,v interpolants
		if ((dx = (xend - xstart))>0)
			{
			du = (ur - ul)/dx;
			dv = (vr - vl)/dx;
			dw = (wr - wl)/dx;
			dz = (zr - zl)/dx;
			} // end if
		else
			{
			du = (ur - ul);
			dv = (vr - vl);
			dw = (wr - wl);
			dz = (zr - zl);
			} // end else

		// draw span
		for (xi=xstart; xi < xend; xi++)
			{
            // test if z of current pixel is nearer than current z buffer value
            if (zi > z_ptr[xi])
               {
			   // write textel assume 5.6.5
 	           screen_ptr[xi] = alpha_table_src1[screen_ptr[xi]] + 
                                alpha_table_src2[((ui >> (FIXP16_SHIFT+3)) << 11) + 
                                                 ((vi >> (FIXP16_SHIFT+2)) << 5) + 
                                                 (wi >> (FIXP16_SHIFT+3))]; 

               // update z-buffer
               z_ptr[xi] = zi;           
               } // end if

			// interpolate u,v,w,z
			ui+=du;
			vi+=dv;
			wi+=dw;
			zi+=dz;
			} // end for xi

		// interpolate u,v,w,x,z along right and left edge
		xl+=dxdyl;
		ul+=dudyl;
		vl+=dvdyl;
		wl+=dwdyl;
		zl+=dzdyl;
	
		xr+=dxdyr;
		ur+=dudyr;
		vr+=dvdyr;
		wr+=dwdyr;
		zr+=dzdyr;

		// advance screen ptr
		screen_ptr+=mem_pitch;

        // advance z-buffer ptr
        z_ptr+=zpitch;

		// test for yi hitting second region, if so change interpolant
		if (yi==yrestart)
			{
			// test interpolation side change flag

			if (irestart == INTERP_LHS)
			{
			// LHS
			dyl = (y2 - y1);	

			dxdyl = ((x2 - x1)   << FIXP16_SHIFT)/dyl;
			dudyl = ((tu2 - tu1) << FIXP16_SHIFT)/dyl;  
			dvdyl = ((tv2 - tv1) << FIXP16_SHIFT)/dyl;   		
			dwdyl = ((tw2 - tw1) << FIXP16_SHIFT)/dyl;   
			dzdyl = ((tz2 - tz1) << 0)/dyl;   

			// set starting values
			xl = (x1  << FIXP16_SHIFT);
			ul = (tu1 << FIXP16_SHIFT);
			vl = (tv1 << FIXP16_SHIFT);
			wl = (tw1 << FIXP16_SHIFT);
			zl = (tz1 << 0);

			// interpolate down on LHS to even up
			xl+=dxdyl;
			ul+=dudyl;
			vl+=dvdyl;
			wl+=dwdyl;
			zl+=dzdyl;
			} // end if
			else
			{
			// RHS
			dyr = (y1 - y2);	

			dxdyr = ((x1 - x2)   << FIXP16_SHIFT)/dyr;
			dudyr = ((tu1 - tu2) << FIXP16_SHIFT)/dyr;  
			dvdyr = ((tv1 - tv2) << FIXP16_SHIFT)/dyr;   		
			dwdyr = ((tw1 - tw2) << FIXP16_SHIFT)/dyr;   
			dzdyr = ((tz1 - tz2) << 0)/dyr;   

			// set starting values
			xr = (x2  << FIXP16_SHIFT);
			ur = (tu2 << FIXP16_SHIFT);
			vr = (tv2 << FIXP16_SHIFT);
			wr = (tw2 << FIXP16_SHIFT);
			zr = (tz2 << 0);

			// interpolate down on RHS to even up
			xr+=dxdyr;
			ur+=dudyr;
			vr+=dvdyr;
			wr+=dwdyr;
			zr+=dzdyr;
			} // end else

			} // end if

		} // end for y

  	} // end else	

	} // end if

} // end Draw_Gouraud_TriangleINVZB_Alpha16

///////////////////////////////////////////////////////////////////////////////

void Draw_RENDERLIST4DV2_SolidINVZB_Alpha16(RENDERLIST4DV2_PTR rend_list, 
                                         UCHAR *video_buffer, 
	        					         int lpitch,
                                         UCHAR *zbuffer,
                                         int zpitch,
                                         int alpha_override)
{
// 16-bit version
// this function "executes" the render list or in other words
// draws all the faces in the list, the function will call the 
// proper rasterizer based on the lighting model of the polygons
// only call the alpha rasterizer for polys with the POLY4DV2_ATTR_TRANSPARENT
// flag set

POLYF4DV2 face; // temp face used to render polygon
int alpha;      // alpha of the face


// at this point, all we have is a list of polygons and it's time
// to draw them
for (int poly=0; poly < rend_list->num_polys; poly++)
    {
    // render this polygon if and only if it's not clipped, not culled,
    // active, and visible, note however the concecpt of "backface" is 
    // irrelevant in a wire frame engine though
    if (!(rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_ACTIVE) ||
         (rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_CLIPPED ) ||
         (rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_BACKFACE) )
       continue; // move onto next poly

    // test for alpha override
    if (alpha_override >= 0)
       {
       // set alpha to override value
       alpha = alpha_override;
       }  // end if 
    else
        {
        // extract alpha (even if there isn't any)
        alpha = ((rend_list->poly_ptrs[poly]->color & 0xff000000) >> 24);
        } // end else

    // need to test for textured first, since a textured poly can either
    // be emissive, or flat shaded, hence we need to call different
    // rasterizers    
    if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_TEXTURE)
       {

       // set the vertices
       face.tvlist[0].x = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;
       face.tvlist[0].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[0].u0;
       face.tvlist[0].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[0].v0;

       face.tvlist[1].x = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;
       face.tvlist[1].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[1].u0;
       face.tvlist[1].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[1].v0;

       face.tvlist[2].x = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;
       face.tvlist[2].u0 = (float)rend_list->poly_ptrs[poly]->tvlist[2].u0;
       face.tvlist[2].v0 = (float)rend_list->poly_ptrs[poly]->tvlist[2].v0;
    
       // assign the texture
       face.texture = rend_list->poly_ptrs[poly]->texture;
       
       // is this a plain emissive texture?
       if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT)
          {
          // draw the textured triangle as emissive
          if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || alpha_override >=0)
               Draw_Textured_Perspective_Triangle_INVZB_Alpha16(&face, video_buffer, lpitch,zbuffer,zpitch, alpha);
          else
             Draw_Textured_TriangleINVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);
          } // end if
       else
      if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT)
          {
          // draw as flat shaded
          face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];

          // test for transparency
          if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || alpha_override >=0)
               Draw_Textured_TriangleFSINVZB_Alpha16(&face, video_buffer, lpitch,zbuffer,zpitch, alpha);
          else
             Draw_Textured_TriangleFSINVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);
          } // end else if
      else
         { // POLY4DV2_ATTR_SHADE_MODE_GOURAUD

          // must be gouraud POLY4DV2_ATTR_SHADE_MODE_GOURAUD
          face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];
          face.lit_color[1] = rend_list->poly_ptrs[poly]->lit_color[1];
          face.lit_color[2] = rend_list->poly_ptrs[poly]->lit_color[2];

          // test for transparency
          if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || alpha_override >=0)
             Draw_Textured_TriangleGSINVZB_Alpha16(&face, video_buffer, lpitch,zbuffer,zpitch,alpha);
          else
             Draw_Textured_TriangleGSINVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);

         } // end else

       } // end if      
    else
    if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT) || 
        (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT) )
       {
       // draw as constant shaded
       face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];
       
       // set the vertices
       face.tvlist[0].x = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;

       face.tvlist[1].x = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;

       face.tvlist[2].x = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;

       // draw the triangle with basic flat rasterizer
       // test for transparency
       if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || alpha_override >=0)
          Draw_Triangle_2DINVZB_Alpha16(&face, video_buffer, lpitch,zbuffer,zpitch,alpha);
       else
          Draw_Triangle_2DINVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);

       } // end if
    else
    if (rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_GOURAUD)
       {
        // {andre take advantage of the data structures later..}
        // set the vertices
        face.tvlist[0].x  = (float)rend_list->poly_ptrs[poly]->tvlist[0].x;
        face.tvlist[0].y  = (float)rend_list->poly_ptrs[poly]->tvlist[0].y;
        face.tvlist[0].z  = (float)rend_list->poly_ptrs[poly]->tvlist[0].z;
        face.lit_color[0] = rend_list->poly_ptrs[poly]->lit_color[0];

        face.tvlist[1].x  = (float)rend_list->poly_ptrs[poly]->tvlist[1].x;
        face.tvlist[1].y  = (float)rend_list->poly_ptrs[poly]->tvlist[1].y;
        face.tvlist[1].z  = (float)rend_list->poly_ptrs[poly]->tvlist[1].z;
        face.lit_color[1] = rend_list->poly_ptrs[poly]->lit_color[1];

        face.tvlist[2].x  = (float)rend_list->poly_ptrs[poly]->tvlist[2].x;
        face.tvlist[2].y  = (float)rend_list->poly_ptrs[poly]->tvlist[2].y;
        face.tvlist[2].z  = (float)rend_list->poly_ptrs[poly]->tvlist[2].z;
        face.lit_color[2] = rend_list->poly_ptrs[poly]->lit_color[2];

	    // draw the gouraud shaded triangle
        // test for transparency
        if ((rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || alpha_override >=0)
            Draw_Gouraud_TriangleINVZB_Alpha16(&face, video_buffer, lpitch,zbuffer,zpitch,alpha);
        else
            Draw_Gouraud_TriangleINVZB_16(&face, video_buffer, lpitch,zbuffer,zpitch);

       } // end if gouraud

    } // end for poly+

} // end Draw_RENDERLIST4DV2_SolidINVZB_Alpha16


/////////////////////////////////////////////////////////////////////////////////////////////

int DDraw_Init2(int width, int height, int bpp, int windowed, int backbuffer_enable)
{
// this function initializes directdraw, but allows for a non flippable pure
// memory backbuffer even in full screen mode, this is to override an anomaly
// with new directdraw that does not like us reading from the backbuffer in a chained
// complex surface, thus we have to create a secondary offscreen surface just like in
// windowed mode for this case, so the alpha blending code will work fast, otherwise
// its' like 30 times slower! Alas, if you don't want to use the complex chained backbuffer
// then send a 0 for the last parameter, or in other words for alpha bleding support with
// speed send a zero if you're going to do full screen mode, otherwise send a 1 as the last 
// parameter which is the default, hence you can call this function as you have the first
// version in that case

int index; // looping variable

// create IDirectDraw interface 7.0 object and test for error
if (FAILED(DirectDrawCreateEx(NULL, (void **)&lpdd, IID_IDirectDraw7, NULL)))
   return(0);

// based on windowed or fullscreen set coorperation level
if (windowed)
   {
   // set cooperation level to windowed mode 
   if (FAILED(lpdd->SetCooperativeLevel(main_window_handle,DDSCL_NORMAL)))
       return(0);

   } // end if
else
   {
   // set cooperation level to fullscreen mode 
   if (FAILED(lpdd->SetCooperativeLevel(main_window_handle,
              DDSCL_ALLOWMODEX | DDSCL_FULLSCREEN | 
              DDSCL_EXCLUSIVE | DDSCL_ALLOWREBOOT | DDSCL_MULTITHREADED )))
       return(0);

   // set the display mode
   if (FAILED(lpdd->SetDisplayMode(width,height,bpp,0,0)))
      return(0);

   } // end else

// set globals
screen_height            = height;
screen_width             = width;
screen_bpp               = bpp;
screen_windowed          = windowed;
screen_backbuffer_enable = backbuffer_enable;

// Create the primary surface
memset(&ddsd,0,sizeof(ddsd));
ddsd.dwSize = sizeof(ddsd);

// we need to let dd know that we want a complex 
// flippable surface structure, set flags for that
if (!screen_windowed)
   {
   // test for backbuffer enabled
   if (screen_backbuffer_enable)
      {
      // fullscreen mode
      ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT;
      ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_FLIP | DDSCAPS_COMPLEX;
   
      // set the backbuffer count to 0 for windowed mode
      // 1 for fullscreen mode, 2 for triple buffering
      ddsd.dwBackBufferCount = 1;
      } // end if
    else
      {
      // user is requested no back buffer and wants to use a plain offscreen memory
      // surface to speed up reading for alpha blending
      // fullscreen mode
      ddsd.dwFlags = DDSD_CAPS;
      ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

      // set the backbuffer count to 0 for windowed mode
      // 1 for fullscreen mode, 2 for triple buffering
      ddsd.dwBackBufferCount = 0;
  
      } // end else

   } // end if
else
   {
   // windowed mode
   ddsd.dwFlags = DDSD_CAPS;
   ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

   // set the backbuffer count to 0 for windowed mode
   // 1 for fullscreen mode, 2 for triple buffering
   ddsd.dwBackBufferCount = 0;
   } // end else

// create the primary surface
lpdd->CreateSurface(&ddsd,&lpddsprimary,NULL);

// get the pixel format of the primary surface
DDPIXELFORMAT ddpf; // used to get pixel format

// initialize structure
DDRAW_INIT_STRUCT(ddpf);

// query the format from primary surface
lpddsprimary->GetPixelFormat(&ddpf);

// based on masks determine if system is 5.6.5 or 5.5.5
//RGB Masks for 5.6.5 mode
//DDPF_RGB  16 R: 0x0000F800  
//             G: 0x000007E0  
//             B: 0x0000001F  

//RGB Masks for 5.5.5 mode
//DDPF_RGB  16 R: 0x00007C00  
//             G: 0x000003E0  
//             B: 0x0000001F  
// test for 6 bit green mask)
//if (ddpf.dwGBitMask == 0x000007E0)
//   dd_pixel_format = DD_PIXEL_FORMAT565;

// use number of bits, better method
dd_pixel_format = ddpf.dwRGBBitCount;

Write_Error("\npixel format = %d",dd_pixel_format);

// set up conversion macros, so you don't have to test which one to use
if (dd_pixel_format == DD_PIXEL_FORMAT555)
   {
   RGB16Bit = RGB16Bit555;
   Write_Error("\npixel format = 5.5.5");
   } // end if
else
   {
   RGB16Bit = RGB16Bit565;
   Write_Error("\npixel format = 5.6.5");
   } // end else

// only need a backbuffer for fullscreen modes
if (!screen_windowed)
   {
   // test for backbuffer enabled
   if (screen_backbuffer_enable)
      {
      // query for the backbuffer i.e the secondary surface
      ddscaps.dwCaps = DDSCAPS_BACKBUFFER;

      if (FAILED(lpddsprimary->GetAttachedSurface(&ddscaps,&lpddsback)))
         return(0);
      } // end if
    else
       {
       // must be requesting this for high performance alpha blending
       lpddsback = DDraw_Create_Surface(width, height, DDSCAPS_SYSTEMMEMORY); // int mem_flags, USHORT color_key_flag);
       } // end else

   } // end if
else
   {
   // must be windowed, so create a double buffer that will be blitted
   // rather than flipped as in full screen mode
   lpddsback = DDraw_Create_Surface(width, height, DDSCAPS_SYSTEMMEMORY); // int mem_flags, USHORT color_key_flag);

   } // end else

// create a palette only if 8bit mode
if (screen_bpp==DD_PIXEL_FORMAT8)
{
// create and attach palette
// clear all entries, defensive programming
memset(palette,0,MAX_COLORS_PALETTE*sizeof(PALETTEENTRY));

// load a pre-made "good" palette off disk
Load_Palette_From_File(DEFAULT_PALETTE_FILE, palette);

// load and attach the palette, test for windowed mode
if (screen_windowed)
   {
   // in windowed mode, so the first 10 and last 10 entries have
   // to be slightly modified as does the call to createpalette
   // reset the peFlags bit to PC_EXPLICIT for the "windows" colors
   for (index=0; index < 10; index++)
       palette[index].peFlags = palette[index+246].peFlags = PC_EXPLICIT;         

   // now create the palette object, but disable access to all 256 entries
   if (FAILED(lpdd->CreatePalette(DDPCAPS_8BIT | DDPCAPS_INITIALIZE,
                                  palette,&lpddpal,NULL)))
   return(0);

   } // end 
else
   {
   // in fullscreen mode, so simple create the palette with the default palette
   // and fill in all 256 entries
   if (FAILED(lpdd->CreatePalette(DDPCAPS_8BIT | DDPCAPS_INITIALIZE | DDPCAPS_ALLOW256,
                                  palette,&lpddpal,NULL)))
      return(0);

   } // end if

// now attach the palette to the primary surface
if (FAILED(lpddsprimary->SetPalette(lpddpal)))
   return(0);

} // end if attach palette for 8bit mode

// clear out both primary and secondary surfaces
if (screen_windowed)
   {
   // only clear backbuffer
   DDraw_Fill_Surface(lpddsback,0);

   } // end if
else
   {
   // fullscreen, simply clear everything
   DDraw_Fill_Surface(lpddsprimary,0);
   DDraw_Fill_Surface(lpddsback,0);
   } // end else

// set software algorithmic clipping region
min_clip_x = 0;
max_clip_x = screen_width - 1;
min_clip_y = 0;
max_clip_y = screen_height - 1;

// setup backbuffer clipper always
RECT screen_rect = {0,0,screen_width,screen_height};
lpddclipper = DDraw_Attach_Clipper(lpddsback,1,&screen_rect);

// set up windowed mode clipper
if (screen_windowed)
   {
   // set windowed clipper
   if (FAILED(lpdd->CreateClipper(0,&lpddclipperwin,NULL)))
       return(0);

   if (FAILED(lpddclipperwin->SetHWnd(0, main_window_handle)))
       return(0);

   if (FAILED(lpddsprimary->SetClipper(lpddclipperwin)))
       return(0);
   } // end if screen windowed

// return success
return(1);

} // end DDraw_Init2

///////////////////////////////////////////////////////////

int DDraw_Flip2(void)
{
// this function flip the primary surface with the secondary surface

// test if either of the buffers are locked
if (primary_buffer || back_buffer)
   return(0);

// flip pages
if (!screen_windowed)
   {
   // test for backbuffer enabled
   if (screen_backbuffer_enable)
      {
      while(FAILED(lpddsprimary->Flip(NULL, DDFLIP_WAIT)));
      } // end if
   else
      {
      // must have an overrided off screen memory backbuffer for alpha blending speed
      RECT    dest_rect;    // used to compute destination rectangle

      // get the window's rectangle in screen coordinates
      GetWindowRect(main_window_handle, &dest_rect);   

      // compute the destination rectangle
      dest_rect.left   +=window_client_x0;
      dest_rect.top    +=window_client_y0;

      dest_rect.right  =dest_rect.left+screen_width-1;
      dest_rect.bottom =dest_rect.top +screen_height-1;

      // clip the screen coords 
       
      // blit the entire back surface to the primary
      if (FAILED(lpddsprimary->Blt(&dest_rect, lpddsback,NULL,DDBLT_WAIT,NULL)))
          return(0); 

      } // end else
   } // end if
else
   {
   RECT    dest_rect;    // used to compute destination rectangle

   // get the window's rectangle in screen coordinates
   GetWindowRect(main_window_handle, &dest_rect);   

   // compute the destination rectangle
   dest_rect.left   +=window_client_x0;
   dest_rect.top    +=window_client_y0;

   dest_rect.right  =dest_rect.left+screen_width-1;
   dest_rect.bottom =dest_rect.top +screen_height-1;

   // clip the screen coords 
       
   // blit the entire back surface to the primary
   if (FAILED(lpddsprimary->Blt(&dest_rect, lpddsback,NULL,DDBLT_WAIT,NULL)))
       return(0);    

   } // end if

// return success
return(1);

} // end DDraw_Flip2

///////////////////////////////////////////////////////////   

int Generate_Mipmaps(BITMAP_IMAGE_PTR source,    // source bitmap for mipmap
                     BITMAP_IMAGE_PTR *mipmaps, // pointer to array to store mipmap chain
                     float gamma)                // gamma correction factor 
{
// this functions creates a mip map chain of bitmap textures
// on entry source should point to the bottom level d = 0 texture
// and on exit mipmap will point to an array of pointers that holds
// all the mip levels including source as entry 0, additionally the
// function will return the total number of levels or -1 if there 
// is a problem, the last param gamma is used to brighten each mip level up
// since averaging has the effect of darkening, a value of 1.01 is usually 
// good, values greater that 1.0 brighten each mip map, values less than
// 1.0 darken each mip map, and 1.0 has no effect

BITMAP_IMAGE_PTR *tmipmaps; // local temporary pointer to array of pointers

// step 1: compute number of mip levels total
int num_mip_levels = logbase2ofx[source->width] + 1; 

// allocate array of pointers to mip maps
tmipmaps = (BITMAP_IMAGE_PTR *)malloc(num_mip_levels * sizeof(BITMAP_IMAGE_PTR) );

// point element 0 (level 0) to entry source
tmipmaps[0] = source;

// set width and height (same actually)
int mip_width  = source->width;
int mip_height = source->height;

// iterate thru and generate pyramid mipmap levels using averaging filter
for (int mip_level = 1; mip_level <  num_mip_levels; mip_level++)
    {
    // scale size of mip map down one level
    mip_width  = mip_width  / 2;
    mip_height = mip_height / 2;

    // allocate memory for bitmap object
    tmipmaps[mip_level] =  (BITMAP_IMAGE_PTR)malloc(sizeof(BITMAP_IMAGE) );  
 
    // create a bitmap to hold mip map
    Create_Bitmap(tmipmaps[mip_level],0,0, mip_width, mip_height, 16);

    // enable the bitmap for rendering  
    SET_BIT(tmipmaps[mip_level]->attr, BITMAP_ATTR_LOADED);

    // now interate thru previous level's mipmap and average down to create this level
    for (int x = 0; x < tmipmaps[mip_level]->width; x++)
        {
        for (int y = 0; y < tmipmaps[mip_level]->height; y++)
            {
            // we need to average the 4 pixel located at:
            // (x*2, y*2), (x*2+1, y*2), (x*2,y*2+1), (x*2+1,y*2+1)
            // in previous mipmap level, and then write them
            // to x,y in this mipmap level :) easy!
            float r0, g0, b0,        // r,g,b components of 4 sample pixels
                  r1, g1, b1,
                  r2, g2, b2,
                  r3, g3, b3;
              
            int r_avg, g_avg, b_avg; // used to compute averages

            USHORT *src_buffer  = (USHORT *)tmipmaps[mip_level-1]->buffer,
                   *dest_buffer = (USHORT *)tmipmaps[mip_level]->buffer;

            // extract rgb components of each pixel
            _RGB565FROM16BIT( src_buffer[(x*2+0) + (y*2+0)*mip_width*2] , &r0, &g0, &b0);
            _RGB565FROM16BIT( src_buffer[(x*2+1) + (y*2+0)*mip_width*2] , &r1, &g1, &b1);
            _RGB565FROM16BIT( src_buffer[(x*2+0) + (y*2+1)*mip_width*2] , &r2, &g2, &b2);
            _RGB565FROM16BIT( src_buffer[(x*2+1) + (y*2+1)*mip_width*2] , &r3, &g3, &b3);
       
            // compute average, take gamma into consideration
            r_avg = (int)(0.5f + gamma*(r0+r1+r2+r3)/4);
            g_avg = (int)(0.5f + gamma*(g0+g1+g2+g3)/4);
            b_avg = (int)(0.5f + gamma*(b0+b1+b2+b3)/4);

            // clamp values to max r, g, b values for 5.6.5 format
            if (r_avg > 31) r_avg = 31;
            if (g_avg > 63) g_avg = 63;
            if (b_avg > 31) b_avg = 31;
  
            // write data
            dest_buffer[x + y*mip_width] = _RGB16BIT565(r_avg,g_avg,b_avg);

            } // end for y

        } // end for x

    } // end for mip_level

// now assign array of pointers to exit 
*mipmaps = (BITMAP_IMAGE_PTR)tmipmaps;

// return success
return(num_mip_levels);

} // end Generate_Mipmaps

///////////////////////////////////////////////////////////////////////////////
 
int Delete_Mipmaps(BITMAP_IMAGE_PTR *mipmaps, int leave_level_0)
{
// this function deletes all the mipmaps in the chain
// that each pointer in the array mipmaps points to and 
// then releases the array memory itself, the function has the
// ability to leave the top level 0 bitmap in place if 
// leave_level_0 flag is 1

BITMAP_IMAGE_PTR *tmipmaps = (BITMAP_IMAGE_PTR *)*mipmaps;

// are there any mipmaps
if (!tmipmaps)
   return(0);

// step 1: compute number of mip levels total
int num_mip_levels = logbase2ofx[tmipmaps[0]->width] + 1; 

// iterate thru delete each bitmap
for (int mip_level = 1; mip_level < num_mip_levels; mip_level++)
    {
    // release the memory for the bitmap buffer
    Destroy_Bitmap(tmipmaps[mip_level]);
 
    // now release the bitmap object itself
    free(tmipmaps[mip_level]);

    } // end for mip_level

// now depending on the leave_level_0 flag delete everything or leave the 
// original level 0 in place
if (leave_level_0 == 1)
   {
   // we need a temp pointer to the level 0 bitmap
   BITMAP_IMAGE_PTR temp = tmipmaps[0];

   // and the array storage too
   //free(*tmipmaps);

   // and assign mipmaps to the original level 0
   *tmipmaps = temp;
   } // end if     
else 
   {
   // delete everything!
   Destroy_Bitmap(tmipmaps[0]);

   // now release the bitmap object itself
   free(tmipmaps[0]);

   // and the array storage too
   //free(*tmipmaps);
   } // end else

// return success
return(1);

} // end Delete_Mipmaps


///////////////////////////////////////////////////////////////////////////////

void Draw_RENDERLIST4DV2_RENDERCONTEXTV1_16(RENDERCONTEXTV1_PTR rc)
{
// this function renders the rendering list, it's based on the new
// rendering context data structure which is container for everything
// we need to consider when rendering, z, 1/z buffering, alpha, mipmapping,
// perspective, bilerp, etc. the function is basically a merge of all the functions
// we have written thus far, so its rather long, but better than having 
// 20-30 rendering functions for all possible permutations!

POLYF4DV2 face; // temp face used to render polygon
int alpha;      // alpha of the face

// we need to try and separate as much conditional logic as possible
// at the beginning of the function, so we can minimize it inline during
// the traversal of the polygon list, let's start by subclassing which
// kind of rendering we are doing none, z buffered, or 1/z buffered
                                      
if (rc->attr & RENDER_ATTR_NOBUFFER) ////////////////////////////////////
{
// no buffering at all

// at this point, all we have is a list of polygons and it's time
// to draw them
for (int poly=0; poly < rc->rend_list->num_polys; poly++)
    {
    // render this polygon if and only if it's not clipped, not culled,
    // active, and visible, note however the concecpt of "backface" is 
    // irrelevant in a wire frame engine though
    if (!(rc->rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_ACTIVE) ||
         (rc->rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_CLIPPED ) ||
         (rc->rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_BACKFACE) )
       continue; // move onto next poly

    // test for alpha override
    if (rc->alpha_override>= 0)
       {
       // set alpha to override value
       alpha = rc->alpha_override;
       }  // end if 
    else
        {
        // extract alpha (even if there isn't any)
        alpha = ((rc->rend_list->poly_ptrs[poly]->color & 0xff000000) >> 24);
        } // end else


    // need to test for textured first, since a textured poly can either
    // be emissive, or flat shaded, hence we need to call different
    // rasterizers    
    if (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_TEXTURE)
       {
       // set the vertices
       face.tvlist[0].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].z;
       face.tvlist[0].u0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].u0;
       face.tvlist[0].v0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].v0;

       face.tvlist[1].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].z;
       face.tvlist[1].u0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].u0;
       face.tvlist[1].v0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].v0;

       face.tvlist[2].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].z;
       face.tvlist[2].u0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].u0;
       face.tvlist[2].v0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].v0;

       // test if this is a mipmapped polygon?
       if (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_MIPMAP)
          {
          // determine if mipmapping is desired at all globally
          if (rc->attr & RENDER_ATTR_MIPMAP)
             {
             // determine mip level for this polygon

             // first determine how many miplevels there are in mipchain for this polygon
             int tmiplevels = logbase2ofx[((BITMAP_IMAGE_PTR *)(rc->rend_list->poly_ptrs[poly]->texture))[0]->width];

             // now based on the requested linear miplevel fall off distance, cut
             // the viewdistance into segments, determine what segment polygon is
             // in and select mip level -- simple! later you might want something more
             // robust, also note I only use a single vertex, you might want to find the average
             // since for long walls perpendicular to view direction this might causing mip
             // popping mid surface
             int miplevel = (tmiplevels * rc->rend_list->poly_ptrs[poly]->tvlist[0].z / rc->mip_dist);
          
             // clamp miplevel
             if (miplevel > tmiplevels) miplevel = tmiplevels;

             // based on miplevel select proper texture
             face.texture = ((BITMAP_IMAGE_PTR *)(rc->rend_list->poly_ptrs[poly]->texture))[miplevel];

             // now we must divide each texture coordinate by 2 per miplevel
             for (int ts = 0; ts < miplevel; ts++)
                 {
                 face.tvlist[0].u0*=.5;
                 face.tvlist[0].v0*=.5;

                 face.tvlist[1].u0*=.5;
                 face.tvlist[1].v0*=.5;

                 face.tvlist[2].u0*=.5;
                 face.tvlist[2].v0*=.5;
                } // end for

             } // end if mipmmaping enabled globally
          else // mipmapping not selected globally
             {
             // in this case the polygon IS mipmapped, but the caller has requested NO
             // mipmapping, so we will support this by selecting mip level 0 since the
             // texture pointer is pointing to a mip chain regardless
             face.texture = ((BITMAP_IMAGE_PTR *)(rc->rend_list->poly_ptrs[poly]->texture))[0];
 
             // note: texture coordinate manipulation is unneeded

             } // end else

          } // end if
       else
          {
          // assign the texture without change
          face.texture = rc->rend_list->poly_ptrs[poly]->texture;
          } // end if
       
       // is this a plain emissive texture?
       if (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT)
          {
          // draw the textured triangle as emissive

          if ((rc->attr & RENDER_ATTR_ALPHA) &&
              ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || rc->alpha_override>=0) )
             {
             // alpha version
             
             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                Draw_Textured_Triangle_Alpha16(&face, rc->video_buffer, rc->lpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                // not supported yet!
                Draw_Textured_Triangle_Alpha16(&face, rc->video_buffer, rc->lpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                // not supported yet
                Draw_Textured_Triangle_Alpha16(&face, rc->video_buffer, rc->lpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_Triangle_Alpha16(&face, rc->video_buffer, rc->lpitch, alpha);
                    } // end if
                else
                    {
                    // use perspective linear
                    // not supported yet
                    Draw_Textured_Triangle_Alpha16(&face, rc->video_buffer, rc->lpitch, alpha);
                    } // end if

                 } // end if

             } // end if
          else
             {
             // non alpha
             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                // use bilerp?
                if (rc->attr & RENDER_ATTR_BILERP)
                   Draw_Textured_Bilerp_Triangle_16(&face, rc->video_buffer, rc->lpitch);               
                else
                   Draw_Textured_Triangle2_16(&face, rc->video_buffer, rc->lpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                // not supported yet
                Draw_Textured_Triangle2_16(&face, rc->video_buffer, rc->lpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                // not supported yet
                Draw_Textured_Triangle2_16(&face, rc->video_buffer, rc->lpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_Triangle2_16(&face, rc->video_buffer, rc->lpitch);
                    } // end if
                else
                    {
                    // use perspective linear
                    // not supported yet
                    Draw_Textured_Triangle2_16(&face, rc->video_buffer, rc->lpitch);
                    } // end if

                } // end if

             } // end if

          } // end if
       else
       if (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT)
          {
          // draw as flat shaded
          face.lit_color[0] = rc->rend_list->poly_ptrs[poly]->lit_color[0];

          if ((rc->attr & RENDER_ATTR_ALPHA) &&
              ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || rc->alpha_override>=0) )
             {
             // alpha version
             
             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                Draw_Textured_TriangleFS_Alpha16(&face, rc->video_buffer, rc->lpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                // not supported yet!
                Draw_Textured_TriangleFS_Alpha16(&face, rc->video_buffer, rc->lpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                // not supported yet
                Draw_Textured_TriangleFS_Alpha16(&face, rc->video_buffer, rc->lpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_TriangleFS_Alpha16(&face, rc->video_buffer, rc->lpitch, alpha);
                    } // end if
                else
                    {
                    // use perspective linear
                    // not supported yet
                    Draw_Textured_TriangleFS_Alpha16(&face, rc->video_buffer, rc->lpitch, alpha);
                    } // end if

                 } // end if

             } // end if
          else
             {
             // non alpha
             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                Draw_Textured_TriangleFS2_16(&face, rc->video_buffer, rc->lpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                // not supported yet
                Draw_Textured_TriangleFS2_16(&face, rc->video_buffer, rc->lpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                // not supported yet
                Draw_Textured_TriangleFS2_16(&face, rc->video_buffer, rc->lpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_TriangleFS2_16(&face, rc->video_buffer, rc->lpitch);
                    } // end if
                else
                    {
                    // use perspective linear
                    // not supported yet
                    Draw_Textured_TriangleFS2_16(&face, rc->video_buffer, rc->lpitch);
                    } // end if

                } // end if

             } // end if

          } // end else
       else
          {
          // must be gouraud POLY4DV2_ATTR_SHADE_MODE_GOURAUD
          face.lit_color[0] = rc->rend_list->poly_ptrs[poly]->lit_color[0];
          face.lit_color[1] = rc->rend_list->poly_ptrs[poly]->lit_color[1];
          face.lit_color[2] = rc->rend_list->poly_ptrs[poly]->lit_color[2];

          if ((rc->attr & RENDER_ATTR_ALPHA) &&
              ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || rc->alpha_override>=0) )
             {
             // alpha version
             
             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                Draw_Textured_TriangleGS_Alpha16(&face, rc->video_buffer, rc->lpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                // not supported yet!
                Draw_Textured_TriangleGS_Alpha16(&face, rc->video_buffer, rc->lpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                // not supported yet
                Draw_Textured_TriangleGS_Alpha16(&face, rc->video_buffer, rc->lpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_TriangleGS_Alpha16(&face, rc->video_buffer, rc->lpitch, alpha);
                    } // end if
                else
                    {
                    // use perspective linear
                    // not supported yet
                    Draw_Textured_TriangleGS_Alpha16(&face, rc->video_buffer, rc->lpitch, alpha);
                    } // end if

                 } // end if

             } // end if
          else
             {
             // non alpha
             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                Draw_Textured_TriangleGS_16(&face, rc->video_buffer, rc->lpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                // not supported yet
                Draw_Textured_TriangleGS_16(&face, rc->video_buffer, rc->lpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                // not supported yet
                Draw_Textured_TriangleGS_16(&face, rc->video_buffer, rc->lpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_TriangleGS_16(&face, rc->video_buffer, rc->lpitch);
                    } // end if
                else
                    {
                    // use perspective linear
                    // not supported yet
                    Draw_Textured_TriangleGS_16(&face, rc->video_buffer, rc->lpitch);
                    } // end if

                } // end if

             } // end if

          } // end else

       } // end if      
    else
    if ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT) || 
        (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT) )
       {
       // draw as constant shaded
       face.lit_color[0] = rc->rend_list->poly_ptrs[poly]->lit_color[0];
       
       // set the vertices
       face.tvlist[0].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].z;

       face.tvlist[1].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].z;

       face.tvlist[2].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].z;

       // draw the triangle with basic flat rasterizer

       // test for transparent
       if ((rc->attr & RENDER_ATTR_ALPHA) &&
              ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || rc->alpha_override>=0) )
          {
          Draw_Triangle_2D_Alpha16(&face, rc->video_buffer, rc->lpitch,alpha);
          } // end if
       else
          {
          Draw_Triangle_2D3_16(&face, rc->video_buffer, rc->lpitch);
          } // end if
                          
       } // end if                    
    else
    if (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_GOURAUD)
       {
        // {andre take advantage of the data structures later..}
        // set the vertices
        face.tvlist[0].x  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].x;
        face.tvlist[0].y  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].y;
        face.tvlist[0].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].z;
        face.lit_color[0] = rc->rend_list->poly_ptrs[poly]->lit_color[0];

        face.tvlist[1].x  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].x;
        face.tvlist[1].y  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].y;
        face.tvlist[1].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].z;
        face.lit_color[1] = rc->rend_list->poly_ptrs[poly]->lit_color[1];

        face.tvlist[2].x  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].x;
        face.tvlist[2].y  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].y;
        face.tvlist[2].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].z;
        face.lit_color[2] = rc->rend_list->poly_ptrs[poly]->lit_color[2];

	    // draw the gouraud shaded triangle
        // test for transparent
          if ((rc->attr & RENDER_ATTR_ALPHA) &&
              ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || rc->alpha_override>=0) )
           {
           Draw_Gouraud_Triangle_Alpha16(&face, rc->video_buffer, rc->lpitch,alpha);
           } // end if
        else
           {
           Draw_Gouraud_Triangle2_16(&face, rc->video_buffer, rc->lpitch);
           } // end if

       } // end if gouraud

    } // end for poly

} // end if RENDER_ATTR_NOBUFFER

else
if (rc->attr & RENDER_ATTR_ZBUFFER) ////////////////////////////////////
{
// use the z buffer

// we have is a list of polygons and it's time draw them
for (int poly=0; poly < rc->rend_list->num_polys; poly++)
    {
    // render this polygon if and only if it's not clipped, not culled,
    // active, and visible, note however the concecpt of "backface" is 
    // irrelevant in a wire frame engine though
    if (!(rc->rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_ACTIVE) ||
         (rc->rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_CLIPPED ) ||
         (rc->rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_BACKFACE) )
       continue; // move onto next poly

    // test for alpha override
    if (rc->alpha_override>= 0)
       {
       // set alpha to override value
       alpha = rc->alpha_override;
       }  // end if 
    else
        {
        // extract alpha (even if there isn't any)
        alpha = ((rc->rend_list->poly_ptrs[poly]->color & 0xff000000) >> 24);
        } // end else

    // need to test for textured first, since a textured poly can either
    // be emissive, or flat shaded, hence we need to call different
    // rasterizers    
    if (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_TEXTURE)
       {
       // set the vertices
       face.tvlist[0].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].z;
       face.tvlist[0].u0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].u0;
       face.tvlist[0].v0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].v0;

       face.tvlist[1].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].z;
       face.tvlist[1].u0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].u0;
       face.tvlist[1].v0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].v0;

       face.tvlist[2].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].z;
       face.tvlist[2].u0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].u0;
       face.tvlist[2].v0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].v0;
    
       // test if this is a mipmapped polygon?
       if (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_MIPMAP)
          {
          // determine if mipmapping is desired at all globally
          if (rc->attr & RENDER_ATTR_MIPMAP)
             {
             // determine mip level for this polygon

             // first determine how many miplevels there are in mipchain for this polygon
             int tmiplevels = logbase2ofx[((BITMAP_IMAGE_PTR *)(rc->rend_list->poly_ptrs[poly]->texture))[0]->width];

             // now based on the requested linear miplevel fall off distance, cut
             // the viewdistance into segments, determine what segment polygon is
             // in and select mip level -- simple! later you might want something more
             // robust, also note I only use a single vertex, you might want to find the average
             // since for long walls perpendicular to view direction this might causing mip
             // popping mid surface
             int miplevel = (tmiplevels * rc->rend_list->poly_ptrs[poly]->tvlist[0].z / rc->mip_dist);
          
             // clamp miplevel
             if (miplevel > tmiplevels) miplevel = tmiplevels;

             // based on miplevel select proper texture
             face.texture = ((BITMAP_IMAGE_PTR *)(rc->rend_list->poly_ptrs[poly]->texture))[miplevel];

             // now we must divide each texture coordinate by 2 per miplevel
             for (int ts = 0; ts < miplevel; ts++)
                 {
                 face.tvlist[0].u0*=.5;
                 face.tvlist[0].v0*=.5;

                 face.tvlist[1].u0*=.5;
                 face.tvlist[1].v0*=.5;

                 face.tvlist[2].u0*=.5;
                 face.tvlist[2].v0*=.5;
                } // end for

             } // end if mipmmaping enabled globally
          else // mipmapping not selected globally
             {
             // in this case the polygon IS mipmapped, but the caller has requested NO
             // mipmapping, so we will support this by selecting mip level 0 since the
             // texture pointer is pointing to a mip chain regardless
             face.texture = ((BITMAP_IMAGE_PTR *)(rc->rend_list->poly_ptrs[poly]->texture))[0];
 
             // note: texture coordinate manipulation is unneeded

             } // end else

          } // end if
       else
          {
          // assign the texture without change
          face.texture = rc->rend_list->poly_ptrs[poly]->texture;
          } // end if
       
       // is this a plain emissive texture?
       if (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT)
          {
          // draw the textured triangle as emissive
          if ((rc->attr & RENDER_ATTR_ALPHA) &&
              ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || rc->alpha_override>=0) )
             {
             // alpha version
             
             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                Draw_Textured_TriangleZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                // not supported yet!
                Draw_Textured_TriangleZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                // not supported yet
                Draw_Textured_TriangleZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_TriangleZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                    } // end if
                else
                    {
                    // use perspective linear
                    // not supported yet
                    Draw_Textured_TriangleZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                    } // end if

                 } // end if

             } // end if
          else
             {
             // non alpha
             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                // use bilerp?
                if (rc->attr & RENDER_ATTR_BILERP)
                   Draw_Textured_Bilerp_TriangleZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);               
                else
                   Draw_Textured_TriangleZB2_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);

                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                // not supported yet
                Draw_Textured_TriangleZB2_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                // not supported yet
                Draw_Textured_TriangleZB2_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_TriangleZB2_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                    } // end if
                else
                    {
                    // use perspective linear
                    // not supported yet
                    Draw_Textured_TriangleZB2_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                    } // end if

                } // end if

             } // end if

          } // end if
       else
       if (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT)
          {
          // draw as flat shaded
          face.lit_color[0] = rc->rend_list->poly_ptrs[poly]->lit_color[0];

          // test for transparency
          if ((rc->attr & RENDER_ATTR_ALPHA) &&
              ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || rc->alpha_override>=0) )
             {
             // alpha version

             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                Draw_Textured_TriangleFSZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                // not supported yet
                Draw_Textured_TriangleFSZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                // not supported yet
                Draw_Textured_TriangleFSZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_TriangleFSZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                    } // end if
                else
                    {
                    // use perspective linear
                    // not supported yet
                    Draw_Textured_TriangleFSZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                    } // end if

                 } // end if

             } // end if
          else
             {
             // non alpha
             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                Draw_Textured_TriangleFSZB2_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                // not supported yet
                Draw_Textured_TriangleFSZB2_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                // not supported yet
                Draw_Textured_TriangleFSZB2_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_TriangleFSZB2_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                    } // end if
                else
                    {
                    // use perspective linear
                    // not supported yet
                    Draw_Textured_TriangleFSZB2_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                    } // end if

                 } // end if

             } // end if

          } // end else if
      else
         { // POLY4DV2_ATTR_SHADE_MODE_GOURAUD

          // must be gouraud POLY4DV2_ATTR_SHADE_MODE_GOURAUD
          face.lit_color[0] = rc->rend_list->poly_ptrs[poly]->lit_color[0];
          face.lit_color[1] = rc->rend_list->poly_ptrs[poly]->lit_color[1];
          face.lit_color[2] = rc->rend_list->poly_ptrs[poly]->lit_color[2];

         // test for transparency
         if ((rc->attr & RENDER_ATTR_ALPHA) &&
              ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || rc->alpha_override>=0) )
             {
             // alpha version

             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                Draw_Textured_TriangleGSZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                // not supported yet :)
                Draw_Textured_TriangleGSZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                // not supported yet :)
                Draw_Textured_TriangleGSZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_TriangleGSZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                    } // end if
                else
                    {
                    // use perspective linear
                    // not supported yet :)
                    Draw_Textured_TriangleGSZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                    } // end if

                 } // end if

             } // end if
          else
             {
             // non alpha
             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                Draw_Textured_TriangleGSZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                // not supported yet :)
                Draw_Textured_TriangleGSZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                // not supported yet :)
                Draw_Textured_TriangleGSZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_TriangleGSZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                    } // end if
                else
                    {
                    // use perspective linear
                    // not supported yet :)
                    Draw_Textured_TriangleGSZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                    } // end if

                 } // end if

             } // end if

         } // end else

       } // end if      
    else
    if ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT) || 
        (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT) )
       {
       // draw as constant shaded
       face.lit_color[0] = rc->rend_list->poly_ptrs[poly]->lit_color[0];
       
       // set the vertices
       face.tvlist[0].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].z;

       face.tvlist[1].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].z;

       face.tvlist[2].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].z;

       // draw the triangle with basic flat rasterizer
       // test for transparency
       if ((rc->attr & RENDER_ATTR_ALPHA) &&
              ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || rc->alpha_override>=0) )
          {
          // alpha version
          Draw_Triangle_2DZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch,alpha);
          } // end if
       else
          {
          // non alpha version
          Draw_Triangle_2DZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
          }  // end if

       } // end if
    else
    if (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_GOURAUD)
       {
        // {andre take advantage of the data structures later..}
        // set the vertices
        face.tvlist[0].x  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].x;
        face.tvlist[0].y  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].y;
        face.tvlist[0].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].z;
        face.lit_color[0] = rc->rend_list->poly_ptrs[poly]->lit_color[0];

        face.tvlist[1].x  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].x;
        face.tvlist[1].y  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].y;
        face.tvlist[1].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].z;
        face.lit_color[1] = rc->rend_list->poly_ptrs[poly]->lit_color[1];

        face.tvlist[2].x  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].x;
        face.tvlist[2].y  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].y;
        face.tvlist[2].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].z;
        face.lit_color[2] = rc->rend_list->poly_ptrs[poly]->lit_color[2];

	    // draw the gouraud shaded triangle
        // test for transparency
        if ((rc->attr & RENDER_ATTR_ALPHA) &&
              ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || rc->alpha_override>=0) )
           {
           // alpha version
           Draw_Gouraud_TriangleZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch,alpha);
           } // end if
        else
           { 
           // non alpha
           Draw_Gouraud_TriangleZB2_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
           } // end if

       } // end if gouraud

    } // end for poly

} // end if RENDER_ATTR_ZBUFFER
else
if (rc->attr & RENDER_ATTR_INVZBUFFER) ////////////////////////////////////
{
// use the inverse z buffer

// we have is a list of polygons and it's time draw them
for (int poly=0; poly < rc->rend_list->num_polys; poly++)
    {
    // render this polygon if and only if it's not clipped, not culled,
    // active, and visible, note however the concecpt of "backface" is 
    // irrelevant in a wire frame engine though
    if (!(rc->rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_ACTIVE) ||
         (rc->rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_CLIPPED ) ||
         (rc->rend_list->poly_ptrs[poly]->state & POLY4DV2_STATE_BACKFACE) )
       continue; // move onto next poly

    // test for alpha override
    if (rc->alpha_override>= 0)
       {
       // set alpha to override value
       alpha = rc->alpha_override;
       }  // end if 
    else
       {
       // extract alpha (even if there isn't any)
       alpha = ((rc->rend_list->poly_ptrs[poly]->color & 0xff000000) >> 24);
       } // end else

    // need to test for textured first, since a textured poly can either
    // be emissive, or flat shaded, hence we need to call different
    // rasterizers    
    if (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_TEXTURE)
       {
       // set the vertices
       face.tvlist[0].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].z;
       face.tvlist[0].u0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].u0;
       face.tvlist[0].v0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].v0;

       face.tvlist[1].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].z;
       face.tvlist[1].u0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].u0;
       face.tvlist[1].v0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].v0;

       face.tvlist[2].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].z;
       face.tvlist[2].u0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].u0;
       face.tvlist[2].v0 = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].v0;
    
    
       // test if this is a mipmapped polygon?
       if (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_MIPMAP)
          {
          // determine if mipmapping is desired at all globally
          if (rc->attr & RENDER_ATTR_MIPMAP)
             {
             // determine mip level for this polygon

             // first determine how many miplevels there are in mipchain for this polygon
             int tmiplevels = logbase2ofx[((BITMAP_IMAGE_PTR *)(rc->rend_list->poly_ptrs[poly]->texture))[0]->width];

             // now based on the requested linear miplevel fall off distance, cut
             // the viewdistance into segments, determine what segment polygon is
             // in and select mip level -- simple! later you might want something more
             // robust, also note I only use a single vertex, you might want to find the average
             // since for long walls perpendicular to view direction this might causing mip
             // popping mid surface
             int miplevel = (tmiplevels * rc->rend_list->poly_ptrs[poly]->tvlist[0].z / rc->mip_dist);
          
             // clamp miplevel
             if (miplevel > tmiplevels) miplevel = tmiplevels;

             // based on miplevel select proper texture
             face.texture = ((BITMAP_IMAGE_PTR *)(rc->rend_list->poly_ptrs[poly]->texture))[miplevel];

             // now we must divide each texture coordinate by 2 per miplevel
             for (int ts = 0; ts < miplevel; ts++)
                 {
                 face.tvlist[0].u0*=.5;
                 face.tvlist[0].v0*=.5;

                 face.tvlist[1].u0*=.5;
                 face.tvlist[1].v0*=.5;

                 face.tvlist[2].u0*=.5;
                 face.tvlist[2].v0*=.5;
                } // end for

             } // end if mipmmaping enabled globally
          else // mipmapping not selected globally
             {
             // in this case the polygon IS mipmapped, but the caller has requested NO
             // mipmapping, so we will support this by selecting mip level 0 since the
             // texture pointer is pointing to a mip chain regardless
             face.texture = ((BITMAP_IMAGE_PTR *)(rc->rend_list->poly_ptrs[poly]->texture))[0];
 
             // note: texture coordinate manipulation is unneeded

             } // end else

          } // end if
       else
          {
          // assign the texture without change
          face.texture = rc->rend_list->poly_ptrs[poly]->texture;
          } // end if
              
       // is this a plain emissive texture?
       if (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT)
          {
          // draw the textured triangle as emissive
          if ((rc->attr & RENDER_ATTR_ALPHA) &&
              ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || rc->alpha_override>=0) )
             {
             // alpha version
             
             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                Draw_Textured_TriangleINVZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                Draw_Textured_Perspective_Triangle_INVZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                Draw_Textured_PerspectiveLP_Triangle_INVZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_TriangleINVZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                    } // end if
                else
                    {
                    // use perspective linear
                    Draw_Textured_PerspectiveLP_Triangle_INVZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                    } // end if

                 } // end if

             } // end if
          else
             {
             // non alpha
             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                // use bilerp?
                if (rc->attr & RENDER_ATTR_BILERP)
                    Draw_Textured_Bilerp_TriangleINVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);             
                else
                    Draw_Textured_TriangleINVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);

                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                Draw_Textured_Perspective_Triangle_INVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                Draw_Textured_PerspectiveLP_Triangle_INVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_TriangleINVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                    } // end if
                else
                    {
                    // use perspective linear
                    Draw_Textured_PerspectiveLP_Triangle_INVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                    } // end if

                } // end if

             } // end if

          } // end if
       else
       if (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT)
          {
          // draw as flat shaded
          face.lit_color[0] = rc->rend_list->poly_ptrs[poly]->lit_color[0];

          // test for transparency
          if ((rc->attr & RENDER_ATTR_ALPHA) &&
              ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || rc->alpha_override>=0) )
             {
             // alpha version

             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                Draw_Textured_TriangleFSINVZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                Draw_Textured_Perspective_Triangle_FSINVZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                Draw_Textured_PerspectiveLP_Triangle_FSINVZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_TriangleFSINVZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                    } // end if
                else
                    {
                    // use perspective linear
                    Draw_Textured_PerspectiveLP_Triangle_FSINVZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                    } // end if

                 } // end if

             } // end if
          else
             {
             // non alpha
             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                Draw_Textured_TriangleFSINVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                Draw_Textured_Perspective_Triangle_FSINVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                Draw_Textured_PerspectiveLP_Triangle_FSINVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_TriangleFSINVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                    } // end if
                else
                    {
                    // use perspective linear
                    Draw_Textured_PerspectiveLP_Triangle_FSINVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                    } // end if

                 } // end if

             } // end if

          } // end else if
      else
         { // POLY4DV2_ATTR_SHADE_MODE_GOURAUD

          // must be gouraud POLY4DV2_ATTR_SHADE_MODE_GOURAUD
          face.lit_color[0] = rc->rend_list->poly_ptrs[poly]->lit_color[0];
          face.lit_color[1] = rc->rend_list->poly_ptrs[poly]->lit_color[1];
          face.lit_color[2] = rc->rend_list->poly_ptrs[poly]->lit_color[2];

         // test for transparency
         if ((rc->attr & RENDER_ATTR_ALPHA) &&
              ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || rc->alpha_override>=0) )
             {
             // alpha version

             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                Draw_Textured_TriangleGSINVZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                // not supported yet :)
                Draw_Textured_TriangleGSINVZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                // not supported yet :)
                Draw_Textured_TriangleGSINVZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_TriangleGSINVZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                    } // end if
                else
                    {
                    // use perspective linear
                    // not supported yet :)
                    Draw_Textured_TriangleGSINVZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch, alpha);
                    } // end if

                 } // end if

             } // end if
          else
             {
             // non alpha
             // which texture mapper?
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_AFFINE)
                {
                Draw_Textured_TriangleGSINVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_CORRECT)
                {
                // not supported yet :)
                Draw_Textured_TriangleGSINVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_LINEAR)
                {
                // not supported yet :)
                Draw_Textured_TriangleGSINVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                } // end if
             else
             if (rc->attr & RENDER_ATTR_TEXTURE_PERSPECTIVE_HYBRID1)
                {
                // test z distance again perspective transition gate
                if (rc->rend_list->poly_ptrs[poly]->tvlist[0].z > rc-> texture_dist)
                    {
                    // default back to affine
                    Draw_Textured_TriangleFSINVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                    } // end if
                else
                    {
                    // use perspective linear
                    // not supported yet :)
                    Draw_Textured_TriangleGSINVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
                    } // end if

                 } // end if

             } // end if

         } // end else

       } // end if      
    else
    if ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_FLAT) || 
        (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_CONSTANT) )
       {
       // draw as constant shaded
       face.lit_color[0] = rc->rend_list->poly_ptrs[poly]->lit_color[0];
       
       // set the vertices
       face.tvlist[0].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].x;
       face.tvlist[0].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].y;
       face.tvlist[0].z = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].z;

       face.tvlist[1].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].x;
       face.tvlist[1].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].y;
       face.tvlist[1].z = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].z;

       face.tvlist[2].x = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].x;
       face.tvlist[2].y = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].y;
       face.tvlist[2].z = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].z;

       // draw the triangle with basic flat rasterizer
       // test for transparency
       if ((rc->attr & RENDER_ATTR_ALPHA) &&
              ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || rc->alpha_override>=0) )
          {
          // alpha version
          Draw_Triangle_2DINVZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch,alpha);
          } // end if
       else
          {
          // non alpha version
          Draw_Triangle_2DINVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
          }  // end if

       } // end if
    else
    if (rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_SHADE_MODE_GOURAUD)
       {
        // {andre take advantage of the data structures later..}
        // set the vertices
        face.tvlist[0].x  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].x;
        face.tvlist[0].y  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].y;
        face.tvlist[0].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[0].z;
        face.lit_color[0] = rc->rend_list->poly_ptrs[poly]->lit_color[0];

        face.tvlist[1].x  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].x;
        face.tvlist[1].y  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].y;
        face.tvlist[1].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[1].z;
        face.lit_color[1] = rc->rend_list->poly_ptrs[poly]->lit_color[1];

        face.tvlist[2].x  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].x;
        face.tvlist[2].y  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].y;
        face.tvlist[2].z  = (float)rc->rend_list->poly_ptrs[poly]->tvlist[2].z;
        face.lit_color[2] = rc->rend_list->poly_ptrs[poly]->lit_color[2];

	    // draw the gouraud shaded triangle
        // test for transparency
        if ((rc->attr & RENDER_ATTR_ALPHA) &&
              ((rc->rend_list->poly_ptrs[poly]->attr & POLY4DV2_ATTR_TRANSPARENT) || rc->alpha_override>=0) )
           {
           // alpha version
           Draw_Gouraud_TriangleINVZB_Alpha16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch,alpha);
           } // end if
        else
           { 
           // non alpha
           Draw_Gouraud_TriangleINVZB_16(&face, rc->video_buffer, rc->lpitch,rc->zbuffer,rc->zpitch);
           } // end if

       } // end if gouraud

    } // end for poly

} // end if RENDER_ATTR_INVZBUFFER

} // end Draw_RENDERLIST4DV2_RENDERCONTEXTV1_16

////////////////////////////////////////////////////////////////////////////////////////

void Transform_RENDERLIST4DV2(RENDERLIST4DV2_PTR rend_list, // render list to transform
                              MATRIX4X4_PTR mt,   // transformation matrix
                              int coord_select)   // selects coords to transform
{
// this function simply transforms all of the polygons vertices in the local or trans
// array of the render list by the sent matrix

// what coordinates should be transformed?
switch(coord_select)
      {
      case TRANSFORM_LOCAL_ONLY:
      {
      for (int poly = 0; poly < rend_list->num_polys; poly++)
          {
          // acquire current polygon
          POLYF4DV2_PTR curr_poly = rend_list->poly_ptrs[poly];

          // is this polygon valid?
          // transform this polygon if and only if it's not clipped, not culled,
          // active, and visible, note however the concept of "backface" is 
          // irrelevant in a wire frame engine though
          if ((curr_poly==NULL) || !(curr_poly->state & POLY4DV2_STATE_ACTIVE) ||
              (curr_poly->state & POLY4DV2_STATE_CLIPPED ) ||
              (curr_poly->state & POLY4DV2_STATE_BACKFACE) )
             continue; // move onto next poly

          // all good, let's transform 
          for (int vertex = 0; vertex < 3; vertex++)
              {
              // transform the vertex by mt
              POINT4D presult; // hold result of each transformation

              // transform point
              Mat_Mul_VECTOR4D_4X4(&curr_poly->vlist[vertex].v, mt, &presult);

              // store result back
              VECTOR4D_COPY(&curr_poly->vlist[vertex].v, &presult); 
              } // end for vertex
 
          } // end for poly

      } break;
 
      case TRANSFORM_TRANS_ONLY:
      {
      // transform each "transformed" vertex of the render list
      // remember, the idea of the tvlist[] array is to accumulate
      // transformations
      for (int poly = 0; poly < rend_list->num_polys; poly++)
          {
          // acquire current polygon
          POLYF4DV2_PTR curr_poly = rend_list->poly_ptrs[poly];

          // is this polygon valid?
          // transform this polygon if and only if it's not clipped, not culled,
          // active, and visible, note however the concept of "backface" is 
          // irrelevant in a wire frame engine though
          if ((curr_poly==NULL) || !(curr_poly->state & POLY4DV2_STATE_ACTIVE) ||
              (curr_poly->state & POLY4DV2_STATE_CLIPPED ) ||
              (curr_poly->state & POLY4DV2_STATE_BACKFACE) )
             continue; // move onto next poly

          // all good, let's transform 
          for (int vertex = 0; vertex < 3; vertex++)
              {
              // transform the vertex by mt
              POINT4D presult; // hold result of each transformation

              // transform point
              Mat_Mul_VECTOR4D_4X4(&curr_poly->tvlist[vertex].v, mt, &presult);

              // store result back
              VECTOR4D_COPY(&curr_poly->tvlist[vertex].v, &presult); 
              } // end for vertex
 
          } // end for poly

      } break;

      case TRANSFORM_LOCAL_TO_TRANS:
      {
      // transform each local/model vertex of the render list and store result
      // in "transformed" vertex list
      for (int poly = 0; poly < rend_list->num_polys; poly++)
          {
          // acquire current polygon
          POLYF4DV2_PTR curr_poly = rend_list->poly_ptrs[poly];

          // is this polygon valid?
          // transform this polygon if and only if it's not clipped, not culled,
          // active, and visible, note however the concept of "backface" is 
          // irrelevant in a wire frame engine though
          if ((curr_poly==NULL) || !(curr_poly->state & POLY4DV2_STATE_ACTIVE) ||
              (curr_poly->state & POLY4DV2_STATE_CLIPPED ) ||
              (curr_poly->state & POLY4DV2_STATE_BACKFACE) )
             continue; // move onto next poly

          // all good, let's transform 
          for (int vertex = 0; vertex < 3; vertex++)
              {
              // transform the vertex by mt
              Mat_Mul_VECTOR4D_4X4(&curr_poly->vlist[vertex].v, mt, &curr_poly->tvlist[vertex].v);
              } // end for vertex
 
          } // end for poly

      } break;

      default: break;

} // end switch

} // end Transform_RENDERLIST4DV2

/////////////////////////////////////////////////////////////////////////