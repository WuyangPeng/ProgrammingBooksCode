#include "../Framework/Common.h"
#include "Application_OGL.h"

// vertex buffer object
PFNGLGENBUFFERSARBPROC glGenBuffersARB = NULL;
PFNGLBINDBUFFERARBPROC glBindBufferARB = NULL;
PFNGLBUFFERDATAARBPROC glBufferDataARB = NULL;
PFNGLDELETEBUFFERSARBPROC glDeleteBuffersARB = NULL;

// multi-texturing
PFNGLACTIVETEXTUREARBPROC glActiveTextureARB = NULL;

// GLSL
PFNGLCREATESHADEROBJECTARBPROC glCreateShaderObjectARB = NULL;
PFNGLSHADERSOURCEARBPROC glShaderSourceARB = NULL;
PFNGLCOMPILESHADERARBPROC glCompileShaderARB = NULL;
PFNGLCREATEPROGRAMOBJECTARBPROC glCreateProgramObjectARB = NULL;
PFNGLATTACHOBJECTARBPROC glAttachObjectARB = NULL;
PFNGLLINKPROGRAMARBPROC glLinkProgramARB = NULL;
PFNGLUSEPROGRAMOBJECTARBPROC glUseProgramObjectARB = NULL;
PFNGLGETINFOLOGARBPROC glGetInfoLogARB = NULL;
PFNGLGETOBJECTPARAMETERIVARBPROC glGetObjectParameterivARB = NULL;
PFNGLDELETEOBJECTARBPROC glDeleteObjectARB = NULL;
PFNGLGETUNIFORMLOCATIONARBPROC glGetUniformLocation = NULL;
PFNGLUNIFORM4FARBPROC glUniform4fARB = NULL;
PFNGLUNIFORM3FARBPROC glUniform3fARB = NULL;
PFNGLUNIFORM1IARBPROC glUniform1iARB = NULL;
PFNGLUNIFORM1IVARBPROC glUniform1ivARB = NULL;
PFNGLUNIFORM1FVARBPROC glUniform1fvARB = NULL;
PFNGLUNIFORMMATRIX4FVARBPROC glUniformMatrix4fvARB = NULL;
PFNGLPROGRAMPARAMETERIEXTPROC glProgramParameteriEXT = NULL;

// instancing
PFNGLDRAWELEMENTSINSTANCEDEXTPROC glDrawElementsInstancedEXT = NULL;

// shadow mapping
PFNGLGENFRAMEBUFFERSEXTPROC glGenFramebuffersEXT = NULL;
PFNGLBINDFRAMEBUFFEREXTPROC glBindFramebufferEXT = NULL;
PFNGLFRAMEBUFFERTEXTURE2DEXTPROC glFramebufferTexture2DEXT = NULL;
PFNGLFRAMEBUFFERTEXTUREEXTPROC glFramebufferTextureEXT = NULL;
PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC glCheckFramebufferStatusEXT = NULL;
PFNGLDELETEFRAMEBUFFERSEXTPROC glDeleteFramebuffersEXT = NULL;
PFNGLTEXIMAGE3DPROC glTexImage3D = NULL;

#define LOADFUNCTION(fname, ftype) fname = (ftype) wglGetProcAddress(#fname); \
  if(fname == NULL) { MessageBoxA(NULL, "Could not find address for function: "#fname, "Error!", MB_OK); return false; }

#define REQUIRE_EXTENSION(ext) if(strstr(strExtensions, ext) == NULL) \
  { MessageBoxA(NULL, "Extension "ext" not supported!", "Error!", MB_OK); return false; }

#define EXTENSION_SUPPORTED(ext) (strstr(strExtensions, ext) != NULL)
#define WGL_EXTENSION_SUPPORTED(ext) (strstr(strWGLExtensions, ext) != NULL)

bool LoadExtensions(void)
{
  char *strExtensions = (char *)glGetString(GL_EXTENSIONS);

  // vertex buffer object
  REQUIRE_EXTENSION("GL_ARB_vertex_buffer_object");
	LOADFUNCTION(glGenBuffersARB, PFNGLGENBUFFERSARBPROC);
	LOADFUNCTION(glBindBufferARB, PFNGLBINDBUFFERARBPROC);
	LOADFUNCTION(glBufferDataARB, PFNGLBUFFERDATAARBPROC);
	LOADFUNCTION(glDeleteBuffersARB, PFNGLDELETEBUFFERSARBPROC);

  // multi-texturing
  REQUIRE_EXTENSION("GL_ARB_multitexture");
  LOADFUNCTION(glActiveTextureARB, PFNGLACTIVETEXTUREARBPROC);

  // GLSL
  REQUIRE_EXTENSION("GL_ARB_shader_objects");
  REQUIRE_EXTENSION("GL_ARB_vertex_shader");
  REQUIRE_EXTENSION("GL_ARB_fragment_shader");
  {
    LOADFUNCTION(glCreateShaderObjectARB, PFNGLCREATESHADEROBJECTARBPROC);
    LOADFUNCTION(glShaderSourceARB, PFNGLSHADERSOURCEARBPROC);
    LOADFUNCTION(glCompileShaderARB, PFNGLCOMPILESHADERARBPROC);
    LOADFUNCTION(glCreateProgramObjectARB, PFNGLCREATEPROGRAMOBJECTARBPROC);
    LOADFUNCTION(glAttachObjectARB, PFNGLATTACHOBJECTARBPROC);
    LOADFUNCTION(glLinkProgramARB, PFNGLLINKPROGRAMARBPROC);
    LOADFUNCTION(glUseProgramObjectARB, PFNGLUSEPROGRAMOBJECTARBPROC);
    LOADFUNCTION(glGetInfoLogARB, PFNGLGETINFOLOGARBPROC);
    LOADFUNCTION(glGetObjectParameterivARB, PFNGLGETOBJECTPARAMETERIVARBPROC);
    LOADFUNCTION(glDeleteObjectARB, PFNGLDELETEOBJECTARBPROC);
    LOADFUNCTION(glUniform4fARB, PFNGLUNIFORM4FARBPROC);
    LOADFUNCTION(glUniform3fARB, PFNGLUNIFORM3FARBPROC);
    LOADFUNCTION(glUniform1fvARB, PFNGLUNIFORM1FVARBPROC);
    LOADFUNCTION(glUniform1iARB, PFNGLUNIFORM1IARBPROC);
    LOADFUNCTION(glUniform1ivARB, PFNGLUNIFORM1IVARBPROC);
    LOADFUNCTION(glUniformMatrix4fvARB, PFNGLUNIFORMMATRIX4FVARBPROC);
    LOADFUNCTION(glGetUniformLocation, PFNGLGETUNIFORMLOCATIONARBPROC);
  }

  // shadow mapping
  REQUIRE_EXTENSION("GL_ARB_depth_texture");
  REQUIRE_EXTENSION("GL_ARB_shadow");

  // frame buffer object
  //
  REQUIRE_EXTENSION("GL_EXT_framebuffer_object");
  {
    LOADFUNCTION(glGenFramebuffersEXT, PFNGLGENFRAMEBUFFERSEXTPROC);
    LOADFUNCTION(glBindFramebufferEXT, PFNGLBINDFRAMEBUFFEREXTPROC);
    LOADFUNCTION(glFramebufferTexture2DEXT, PFNGLFRAMEBUFFERTEXTURE2DEXTPROC);
    LOADFUNCTION(glCheckFramebufferStatusEXT, PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC);
    LOADFUNCTION(glDeleteFramebuffersEXT, PFNGLDELETEFRAMEBUFFERSEXTPROC);
  }

  // geometry shaders
  if(EXTENSION_SUPPORTED("GL_EXT_gpu_shader4") && EXTENSION_SUPPORTED("GL_EXT_geometry_shader4"))
  {
    LOADFUNCTION(glProgramParameteriEXT, PFNGLPROGRAMPARAMETERIEXTPROC);
    GetApp()->m_bGeometryShadersSupported = true;
  }

  // texture arrays
  if(EXTENSION_SUPPORTED("GL_EXT_texture_array"))
  {
    LOADFUNCTION(glFramebufferTextureEXT, PFNGLFRAMEBUFFERTEXTUREEXTPROC);
    LOADFUNCTION(glTexImage3D, PFNGLTEXIMAGE3DPROC);
    GetApp()->m_bTextureArraysSupported = true;
  }

  // instancing
  if(EXTENSION_SUPPORTED("GL_EXT_draw_instanced"))
  {
    LOADFUNCTION(glDrawElementsInstancedEXT, PFNGLDRAWELEMENTSINSTANCEDEXTPROC);
    GetApp()->m_bInstancingSupported = true;
  }

  return true;
}