/**
 * @file	xfeedback_aes.cc
 * @brief	AES cipher on NV_transform_feedback
 * @author	Yamanouchi_Takeshi@sega.co.jp
 *
 */

#define GL_GLEXT_PROTOTYPES

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <sys/time.h>
#include <GL/gl.h>
#include <GL/glext.h>
#include <GL/glu.h>
#include <GL/glx.h>
#include <GL/glut.h>

#include "rijndael.h"


/**
 * AES table for GPU (set to program env parameter)
 * (x,y,z,w) = (s_box, inv_s_box, mix_col, inv_mix_col)
 */
const uint32_t aes_tab[256*4] = {
    0x63, 0x52, 0x00000000, 0x00000000, 0x7c, 0x09, 0x03010102, 0x0b0d090e, 
    0x77, 0x6a, 0x06020204, 0x161a121c, 0x7b, 0xd5, 0x05030306, 0x1d171b12, 
    0xf2, 0x30, 0x0c040408, 0x2c342438, 0x6b, 0x36, 0x0f05050a, 0x27392d36, 
    0x6f, 0xa5, 0x0a06060c, 0x3a2e3624, 0xc5, 0x38, 0x0907070e, 0x31233f2a, 
    0x30, 0xbf, 0x18080810, 0x58684870, 0x01, 0x40, 0x1b090912, 0x5365417e, 
    0x67, 0xa3, 0x1e0a0a14, 0x4e725a6c, 0x2b, 0x9e, 0x1d0b0b16, 0x457f5362, 
    0xfe, 0x81, 0x140c0c18, 0x745c6c48, 0xd7, 0xf3, 0x170d0d1a, 0x7f516546, 
    0xab, 0xd7, 0x120e0e1c, 0x62467e54, 0x76, 0xfb, 0x110f0f1e, 0x694b775a, 
    0xca, 0x7c, 0x30101020, 0xb0d090e0, 0x82, 0xe3, 0x33111122, 0xbbdd99ee, 
    0xc9, 0x39, 0x36121224, 0xa6ca82fc, 0x7d, 0x82, 0x35131326, 0xadc78bf2, 
    0xfa, 0x9b, 0x3c141428, 0x9ce4b4d8, 0x59, 0x2f, 0x3f15152a, 0x97e9bdd6, 
    0x47, 0xff, 0x3a16162c, 0x8afea6c4, 0xf0, 0x87, 0x3917172e, 0x81f3afca, 
    0xad, 0x34, 0x28181830, 0xe8b8d890, 0xd4, 0x8e, 0x2b191932, 0xe3b5d19e, 
    0xa2, 0x43, 0x2e1a1a34, 0xfea2ca8c, 0xaf, 0x44, 0x2d1b1b36, 0xf5afc382, 
    0x9c, 0xc4, 0x241c1c38, 0xc48cfca8, 0xa4, 0xde, 0x271d1d3a, 0xcf81f5a6, 
    0x72, 0xe9, 0x221e1e3c, 0xd296eeb4, 0xc0, 0xcb, 0x211f1f3e, 0xd99be7ba, 
    0xb7, 0x54, 0x60202040, 0x7bbb3bdb, 0xfd, 0x7b, 0x63212142, 0x70b632d5, 
    0x93, 0x94, 0x66222244, 0x6da129c7, 0x26, 0x32, 0x65232346, 0x66ac20c9, 
    0x36, 0xa6, 0x6c242448, 0x578f1fe3, 0x3f, 0xc2, 0x6f25254a, 0x5c8216ed, 
    0xf7, 0x23, 0x6a26264c, 0x41950dff, 0xcc, 0x3d, 0x6927274e, 0x4a9804f1, 
    0x34, 0xee, 0x78282850, 0x23d373ab, 0xa5, 0x4c, 0x7b292952, 0x28de7aa5, 
    0xe5, 0x95, 0x7e2a2a54, 0x35c961b7, 0xf1, 0x0b, 0x7d2b2b56, 0x3ec468b9, 
    0x71, 0x42, 0x742c2c58, 0x0fe75793, 0xd8, 0xfa, 0x772d2d5a, 0x04ea5e9d, 
    0x31, 0xc3, 0x722e2e5c, 0x19fd458f, 0x15, 0x4e, 0x712f2f5e, 0x12f04c81, 
    0x04, 0x08, 0x50303060, 0xcb6bab3b, 0xc7, 0x2e, 0x53313162, 0xc066a235, 
    0x23, 0xa1, 0x56323264, 0xdd71b927, 0xc3, 0x66, 0x55333366, 0xd67cb029, 
    0x18, 0x28, 0x5c343468, 0xe75f8f03, 0x96, 0xd9, 0x5f35356a, 0xec52860d, 
    0x05, 0x24, 0x5a36366c, 0xf1459d1f, 0x9a, 0xb2, 0x5937376e, 0xfa489411, 
    0x07, 0x76, 0x48383870, 0x9303e34b, 0x12, 0x5b, 0x4b393972, 0x980eea45, 
    0x80, 0xa2, 0x4e3a3a74, 0x8519f157, 0xe2, 0x49, 0x4d3b3b76, 0x8e14f859, 
    0xeb, 0x6d, 0x443c3c78, 0xbf37c773, 0x27, 0x8b, 0x473d3d7a, 0xb43ace7d, 
    0xb2, 0xd1, 0x423e3e7c, 0xa92dd56f, 0x75, 0x25, 0x413f3f7e, 0xa220dc61, 
    0x09, 0x72, 0xc0404080, 0xf66d76ad, 0x83, 0xf8, 0xc3414182, 0xfd607fa3, 
    0x2c, 0xf6, 0xc6424284, 0xe07764b1, 0x1a, 0x64, 0xc5434386, 0xeb7a6dbf, 
    0x1b, 0x86, 0xcc444488, 0xda595295, 0x6e, 0x68, 0xcf45458a, 0xd1545b9b, 
    0x5a, 0x98, 0xca46468c, 0xcc434089, 0xa0, 0x16, 0xc947478e, 0xc74e4987, 
    0x52, 0xd4, 0xd8484890, 0xae053edd, 0x3b, 0xa4, 0xdb494992, 0xa50837d3, 
    0xd6, 0x5c, 0xde4a4a94, 0xb81f2cc1, 0xb3, 0xcc, 0xdd4b4b96, 0xb31225cf, 
    0x29, 0x5d, 0xd44c4c98, 0x82311ae5, 0xe3, 0x65, 0xd74d4d9a, 0x893c13eb, 
    0x2f, 0xb6, 0xd24e4e9c, 0x942b08f9, 0x84, 0x92, 0xd14f4f9e, 0x9f2601f7, 
    0x53, 0x6c, 0xf05050a0, 0x46bde64d, 0xd1, 0x70, 0xf35151a2, 0x4db0ef43, 
    0x00, 0x48, 0xf65252a4, 0x50a7f451, 0xed, 0x50, 0xf55353a6, 0x5baafd5f, 
    0x20, 0xfd, 0xfc5454a8, 0x6a89c275, 0xfc, 0xed, 0xff5555aa, 0x6184cb7b, 
    0xb1, 0xb9, 0xfa5656ac, 0x7c93d069, 0x5b, 0xda, 0xf95757ae, 0x779ed967, 
    0x6a, 0x5e, 0xe85858b0, 0x1ed5ae3d, 0xcb, 0x15, 0xeb5959b2, 0x15d8a733, 
    0xbe, 0x46, 0xee5a5ab4, 0x08cfbc21, 0x39, 0x57, 0xed5b5bb6, 0x03c2b52f, 
    0x4a, 0xa7, 0xe45c5cb8, 0x32e18a05, 0x4c, 0x8d, 0xe75d5dba, 0x39ec830b, 
    0x58, 0x9d, 0xe25e5ebc, 0x24fb9819, 0xcf, 0x84, 0xe15f5fbe, 0x2ff69117, 
    0xd0, 0x90, 0xa06060c0, 0x8dd64d76, 0xef, 0xd8, 0xa36161c2, 0x86db4478, 
    0xaa, 0xab, 0xa66262c4, 0x9bcc5f6a, 0xfb, 0x00, 0xa56363c6, 0x90c15664, 
    0x43, 0x8c, 0xac6464c8, 0xa1e2694e, 0x4d, 0xbc, 0xaf6565ca, 0xaaef6040, 
    0x33, 0xd3, 0xaa6666cc, 0xb7f87b52, 0x85, 0x0a, 0xa96767ce, 0xbcf5725c, 
    0x45, 0xf7, 0xb86868d0, 0xd5be0506, 0xf9, 0xe4, 0xbb6969d2, 0xdeb30c08, 
    0x02, 0x58, 0xbe6a6ad4, 0xc3a4171a, 0x7f, 0x05, 0xbd6b6bd6, 0xc8a91e14, 
    0x50, 0xb8, 0xb46c6cd8, 0xf98a213e, 0x3c, 0xb3, 0xb76d6dda, 0xf2872830, 
    0x9f, 0x45, 0xb26e6edc, 0xef903322, 0xa8, 0x06, 0xb16f6fde, 0xe49d3a2c, 
    0x51, 0xd0, 0x907070e0, 0x3d06dd96, 0xa3, 0x2c, 0x937171e2, 0x360bd498, 
    0x40, 0x1e, 0x967272e4, 0x2b1ccf8a, 0x8f, 0x8f, 0x957373e6, 0x2011c684, 
    0x92, 0xca, 0x9c7474e8, 0x1132f9ae, 0x9d, 0x3f, 0x9f7575ea, 0x1a3ff0a0, 
    0x38, 0x0f, 0x9a7676ec, 0x0728ebb2, 0xf5, 0x02, 0x997777ee, 0x0c25e2bc, 
    0xbc, 0xc1, 0x887878f0, 0x656e95e6, 0xb6, 0xaf, 0x8b7979f2, 0x6e639ce8, 
    0xda, 0xbd, 0x8e7a7af4, 0x737487fa, 0x21, 0x03, 0x8d7b7bf6, 0x78798ef4, 
    0x10, 0x01, 0x847c7cf8, 0x495ab1de, 0xff, 0x13, 0x877d7dfa, 0x4257b8d0, 
    0xf3, 0x8a, 0x827e7efc, 0x5f40a3c2, 0xd2, 0x6b, 0x817f7ffe, 0x544daacc, 
    0xcd, 0x3a, 0x9b80801b, 0xf7daec41, 0x0c, 0x91, 0x98818119, 0xfcd7e54f, 
    0x13, 0x11, 0x9d82821f, 0xe1c0fe5d, 0xec, 0x41, 0x9e83831d, 0xeacdf753, 
    0x5f, 0x4f, 0x97848413, 0xdbeec879, 0x97, 0x67, 0x94858511, 0xd0e3c177, 
    0x44, 0xdc, 0x91868617, 0xcdf4da65, 0x17, 0xea, 0x92878715, 0xc6f9d36b, 
    0xc4, 0x97, 0x8388880b, 0xafb2a431, 0xa7, 0xf2, 0x80898909, 0xa4bfad3f, 
    0x7e, 0xcf, 0x858a8a0f, 0xb9a8b62d, 0x3d, 0xce, 0x868b8b0d, 0xb2a5bf23, 
    0x64, 0xf0, 0x8f8c8c03, 0x83868009, 0x5d, 0xb4, 0x8c8d8d01, 0x888b8907, 
    0x19, 0xe6, 0x898e8e07, 0x959c9215, 0x73, 0x73, 0x8a8f8f05, 0x9e919b1b, 
    0x60, 0x96, 0xab90903b, 0x470a7ca1, 0x81, 0xac, 0xa8919139, 0x4c0775af, 
    0x4f, 0x74, 0xad92923f, 0x51106ebd, 0xdc, 0x22, 0xae93933d, 0x5a1d67b3, 
    0x22, 0xe7, 0xa7949433, 0x6b3e5899, 0x2a, 0xad, 0xa4959531, 0x60335197, 
    0x90, 0x35, 0xa1969637, 0x7d244a85, 0x88, 0x85, 0xa2979735, 0x7629438b, 
    0x46, 0xe2, 0xb398982b, 0x1f6234d1, 0xee, 0xf9, 0xb0999929, 0x146f3ddf, 
    0xb8, 0x37, 0xb59a9a2f, 0x097826cd, 0x14, 0xe8, 0xb69b9b2d, 0x02752fc3, 
    0xde, 0x1c, 0xbf9c9c23, 0x335610e9, 0x5e, 0x75, 0xbc9d9d21, 0x385b19e7, 
    0x0b, 0xdf, 0xb99e9e27, 0x254c02f5, 0xdb, 0x6e, 0xba9f9f25, 0x2e410bfb, 
    0xe0, 0x47, 0xfba0a05b, 0x8c61d79a, 0x32, 0xf1, 0xf8a1a159, 0x876cde94, 
    0x3a, 0x1a, 0xfda2a25f, 0x9a7bc586, 0x0a, 0x71, 0xfea3a35d, 0x9176cc88, 
    0x49, 0x1d, 0xf7a4a453, 0xa055f3a2, 0x06, 0x29, 0xf4a5a551, 0xab58faac, 
    0x24, 0xc5, 0xf1a6a657, 0xb64fe1be, 0x5c, 0x89, 0xf2a7a755, 0xbd42e8b0, 
    0xc2, 0x6f, 0xe3a8a84b, 0xd4099fea, 0xd3, 0xb7, 0xe0a9a949, 0xdf0496e4, 
    0xac, 0x62, 0xe5aaaa4f, 0xc2138df6, 0x62, 0x0e, 0xe6abab4d, 0xc91e84f8, 
    0x91, 0xaa, 0xefacac43, 0xf83dbbd2, 0x95, 0x18, 0xecadad41, 0xf330b2dc, 
    0xe4, 0xbe, 0xe9aeae47, 0xee27a9ce, 0x79, 0x1b, 0xeaafaf45, 0xe52aa0c0, 
    0xe7, 0xfc, 0xcbb0b07b, 0x3cb1477a, 0xc8, 0x56, 0xc8b1b179, 0x37bc4e74, 
    0x37, 0x3e, 0xcdb2b27f, 0x2aab5566, 0x6d, 0x4b, 0xceb3b37d, 0x21a65c68, 
    0x8d, 0xc6, 0xc7b4b473, 0x10856342, 0xd5, 0xd2, 0xc4b5b571, 0x1b886a4c, 
    0x4e, 0x79, 0xc1b6b677, 0x069f715e, 0xa9, 0x20, 0xc2b7b775, 0x0d927850, 
    0x6c, 0x9a, 0xd3b8b86b, 0x64d90f0a, 0x56, 0xdb, 0xd0b9b969, 0x6fd40604, 
    0xf4, 0xc0, 0xd5baba6f, 0x72c31d16, 0xea, 0xfe, 0xd6bbbb6d, 0x79ce1418, 
    0x65, 0x78, 0xdfbcbc63, 0x48ed2b32, 0x7a, 0xcd, 0xdcbdbd61, 0x43e0223c, 
    0xae, 0x5a, 0xd9bebe67, 0x5ef7392e, 0x08, 0xf4, 0xdabfbf65, 0x55fa3020, 
    0xba, 0x1f, 0x5bc0c09b, 0x01b79aec, 0x78, 0xdd, 0x58c1c199, 0x0aba93e2, 
    0x25, 0xa8, 0x5dc2c29f, 0x17ad88f0, 0x2e, 0x33, 0x5ec3c39d, 0x1ca081fe, 
    0x1c, 0x88, 0x57c4c493, 0x2d83bed4, 0xa6, 0x07, 0x54c5c591, 0x268eb7da, 
    0xb4, 0xc7, 0x51c6c697, 0x3b99acc8, 0xc6, 0x31, 0x52c7c795, 0x3094a5c6, 
    0xe8, 0xb1, 0x43c8c88b, 0x59dfd29c, 0xdd, 0x12, 0x40c9c989, 0x52d2db92, 
    0x74, 0x10, 0x45caca8f, 0x4fc5c080, 0x1f, 0x59, 0x46cbcb8d, 0x44c8c98e, 
    0x4b, 0x27, 0x4fcccc83, 0x75ebf6a4, 0xbd, 0x80, 0x4ccdcd81, 0x7ee6ffaa, 
    0x8b, 0xec, 0x49cece87, 0x63f1e4b8, 0x8a, 0x5f, 0x4acfcf85, 0x68fcedb6, 
    0x70, 0x60, 0x6bd0d0bb, 0xb1670a0c, 0x3e, 0x51, 0x68d1d1b9, 0xba6a0302, 
    0xb5, 0x7f, 0x6dd2d2bf, 0xa77d1810, 0x66, 0xa9, 0x6ed3d3bd, 0xac70111e, 
    0x48, 0x19, 0x67d4d4b3, 0x9d532e34, 0x03, 0xb5, 0x64d5d5b1, 0x965e273a, 
    0xf6, 0x4a, 0x61d6d6b7, 0x8b493c28, 0x0e, 0x0d, 0x62d7d7b5, 0x80443526, 
    0x61, 0x2d, 0x73d8d8ab, 0xe90f427c, 0x35, 0xe5, 0x70d9d9a9, 0xe2024b72, 
    0x57, 0x7a, 0x75dadaaf, 0xff155060, 0xb9, 0x9f, 0x76dbdbad, 0xf418596e, 
    0x86, 0x93, 0x7fdcdca3, 0xc53b6644, 0xc1, 0xc9, 0x7cdddda1, 0xce366f4a, 
    0x1d, 0x9c, 0x79dedea7, 0xd3217458, 0x9e, 0xef, 0x7adfdfa5, 0xd82c7d56, 
    0xe1, 0xa0, 0x3be0e0db, 0x7a0ca137, 0xf8, 0xe0, 0x38e1e1d9, 0x7101a839, 
    0x98, 0x3b, 0x3de2e2df, 0x6c16b32b, 0x11, 0x4d, 0x3ee3e3dd, 0x671bba25, 
    0x69, 0xae, 0x37e4e4d3, 0x5638850f, 0xd9, 0x2a, 0x34e5e5d1, 0x5d358c01, 
    0x8e, 0xf5, 0x31e6e6d7, 0x40229713, 0x94, 0xb0, 0x32e7e7d5, 0x4b2f9e1d, 
    0x9b, 0xc8, 0x23e8e8cb, 0x2264e947, 0x1e, 0xeb, 0x20e9e9c9, 0x2969e049, 
    0x87, 0xbb, 0x25eaeacf, 0x347efb5b, 0xe9, 0x3c, 0x26ebebcd, 0x3f73f255, 
    0xce, 0x83, 0x2fececc3, 0x0e50cd7f, 0x55, 0x53, 0x2cededc1, 0x055dc471, 
    0x28, 0x99, 0x29eeeec7, 0x184adf63, 0xdf, 0x61, 0x2aefefc5, 0x1347d66d, 
    0x8c, 0x17, 0x0bf0f0fb, 0xcadc31d7, 0xa1, 0x2b, 0x08f1f1f9, 0xc1d138d9, 
    0x89, 0x04, 0x0df2f2ff, 0xdcc623cb, 0x0d, 0x7e, 0x0ef3f3fd, 0xd7cb2ac5, 
    0xbf, 0xba, 0x07f4f4f3, 0xe6e815ef, 0xe6, 0x77, 0x04f5f5f1, 0xede51ce1, 
    0x42, 0xd6, 0x01f6f6f7, 0xf0f207f3, 0x68, 0x26, 0x02f7f7f5, 0xfbff0efd, 
    0x41, 0xe1, 0x13f8f8eb, 0x92b479a7, 0x99, 0x69, 0x10f9f9e9, 0x99b970a9, 
    0x2d, 0x14, 0x15fafaef, 0x84ae6bbb, 0x0f, 0x63, 0x16fbfbed, 0x8fa362b5, 
    0xb0, 0x55, 0x1ffcfce3, 0xbe805d9f, 0x54, 0x21, 0x1cfdfde1, 0xb58d5491, 
    0xbb, 0x0c, 0x19fefee7, 0xa89a4f83, 0x16, 0x7d, 0x1affffe5, 0xa397468d, 
};


/*
 * check error macro
 *
 */
#if 1
#define CHECK_GL_ERROR() \
{ \
    int ogl_err;				 \
    if ((ogl_err = glGetError()) != GL_NO_ERROR) \
	printf("OGL error: %s in %d\n", gluErrorString(ogl_err), __LINE__); \
}
#else
#define CHECK_GL_ERROR()
#endif


/*
 * load GPU program
 *
 */
GLuint load_program(GLenum target, const char *code)
{
    GLuint	prog;
    int		errpos;

    glGenProgramsARB(1, &prog);
    glBindProgramARB(target, prog);
    glProgramStringARB(target, GL_PROGRAM_FORMAT_ASCII_ARB, strlen(code), code);
    glGetIntegerv(GL_PROGRAM_ERROR_POSITION_ARB, &errpos);
    if (errpos != -1) {
	printf("%s\n", glGetString(GL_PROGRAM_ERROR_STRING_ARB));
	return 0;
    }
    glBindProgramARB(target, 0);

    return prog;
}

GLuint load_program_file(GLenum target, const char *fname)
{
    FILE	*fp;
    int		fsize;
    char	*code, c;
    GLuint	prog;
    int		i;

    if ((fp=fopen(fname,"r"))==NULL) {
	printf("cannot open '%s'\n", fname);
	return 0;
    }
    fseek(fp, 0, SEEK_END);
    fsize = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    code = new char [fsize+1];
    fread(code, fsize, 1, fp);
    fclose(fp);
    code[fsize] = '\0';
    for (i=0; c=code[i], ((c=='\n') || (c=='\t') || (c==' ')); i++);	// skip white space

    prog = load_program(target, &code[i]);

    delete [] code;
    return prog;
}


/*
 * AES cipher class
 *
 */
#define USE_PINGPONG_BUF 0	// 0: single buffer, 1: double buffers
class AesTransform {
    size_t	tf_buf_size;
    GLuint	tf_buf[2];	// ping pong buffer
    GLuint	vert_prog;
    bool	transfer_only;

public:
    AesTransform() {}
    ~AesTransform() {}

    void init(size_t tfsz, bool xfer);
    void dest(void);

    void set_param(int mode, int num_key, const char *key);
    bool transform(void *transform_dst, const void *transform_src, size_t transform_size);
};


/**
 * generate transform feedback buffers and a vertex program
 *	@param	tf_buf_size_arg		size of the buffer
 *	@param	transfer_only_arg	true: transfer only, false: with AES cipher
 */
void AesTransform::init(size_t tf_buf_size_arg, bool transfer_only_arg = false)
{
    this->tf_buf_size   = tf_buf_size_arg;
    this->transfer_only = transfer_only_arg;

    // gen buffers
    glGenBuffers(2, this->tf_buf);
    for (int i=0; i<2; i++) {
	glBindBuffer(GL_TRANSFORM_FEEDBACK_BUFFER_NV, this->tf_buf[i]);
	glBufferData(GL_TRANSFORM_FEEDBACK_BUFFER_NV, this->tf_buf_size, NULL, GL_STREAM_READ);
    }
    glBindBuffer(GL_TRANSFORM_FEEDBACK_BUFFER_NV, 0);

    // set readback attributes
    const int	attribs [] = {
	GL_TEXTURE_COORD_NV,	4,	0,
    };
    glTransformFeedbackAttribsNV(sizeof(attribs)/sizeof(int)/3, attribs, GL_INTERLEAVED_ATTRIBS_NV);
    CHECK_GL_ERROR();

    // discard rasterizer
    glEnable(GL_RASTERIZER_DISCARD_NV);
    CHECK_GL_ERROR();

    // set AES tables
    glProgramEnvParametersI4uivNV(GL_VERTEX_PROGRAM_ARB, 0, 256, aes_tab);

    // load vertex code
    if (this->transfer_only) {
	// transfer only
	const char	*vert_code = 
	    "!!NVvp4.0\n"
	    "ATTRIB in    = vertex.attrib[0];\n"
	    "OUTPUT out   = result.texcoord[0];\n"
	    "MOV.U  out, in;\n"
	    "END";
 	if ((this->vert_prog = load_program(GL_VERTEX_PROGRAM_ARB, vert_code)) == 0) exit(-1);
    } else {
	// AES cipher
	const char	*vert_fname = "aes.vp";
	if ((this->vert_prog = load_program_file(GL_VERTEX_PROGRAM_ARB, vert_fname)) == 0) exit(-1);
    }
    glEnable(GL_VERTEX_PROGRAM_ARB);
    glBindProgramARB(GL_VERTEX_PROGRAM_ARB, this->vert_prog);
}


/**
 * delete buffers and a program
 *
 */
void AesTransform::dest(void)
{
    glDisable(GL_RASTERIZER_DISCARD_NV);
    glDisable(GL_VERTEX_PROGRAM_ARB);
    glDeleteBuffers(2, this->tf_buf);
    glDeleteProgramsARB(1, &this->vert_prog);
}


/**
 * set AES parameters
 *	@param	mode	0: encrypt, 1: decrypt
 *	@param	num_key	cipher key length(4, 6, 8)
 *	@param	key	cipher key
 */
void AesTransform::set_param(int mode, int num_key, const char *key)
{
    if (this->transfer_only) return;

    // expand key
    RijnKeyParam kp;
    rijn_expand_key(&kp, 4, num_key, key);
    glProgramLocalParameterI4iNV(GL_VERTEX_PROGRAM_ARB, MODE, mode, 0, 0, 0);
    glProgramLocalParameterI4iNV(GL_VERTEX_PROGRAM_ARB, NUM_ROUND, kp.num_round, 0, 0, 0);
    glProgramLocalParametersI4uivNV(GL_VERTEX_PROGRAM_ARB, ENC_KEY_BEGIN, 15, kp.enc_key);
    glProgramLocalParametersI4uivNV(GL_VERTEX_PROGRAM_ARB, DEC_KEY_BEGIN, 15, kp.dec_key);
    CHECK_GL_ERROR();
}

/**
 * transform src to dst
 *
 */
bool AesTransform::transform(void *transform_dst, const void *transform_src, size_t transform_size)
{
    size_t	size[2];
    uint32_t	*result;
    const char	*src;
    char	*dst;
    size_t	src_size, dst_size;
    int		idx = 0;
    bool	res = true;
#if USE_PINGPONG_BUF
    bool	first_time = true;
#else
    bool	first_time = false;
#endif

    if (transform_size & 0xf) return false;	// check 16 bytes alignment
    idx = 0;
    src = (const char *)transform_src;
    dst = (char *)transform_dst;
    src_size = dst_size = transform_size;

    while (dst_size > 0) {
	// draw
	if (src_size > 0) {
	    size[idx] = this->tf_buf_size;
	    if (src_size <= this->tf_buf_size) {
		size[idx] = src_size;
	    }
	    glBindBufferRangeNV(GL_TRANSFORM_FEEDBACK_BUFFER_NV, 0, this->tf_buf[idx], 0, size[idx]);
	    glBeginTransformFeedbackNV(GL_POINTS);			CHECK_GL_ERROR();
	    glEnableVertexAttribArray(0);
	    glVertexAttribIPointerEXT(0, 4, GL_UNSIGNED_INT, 0, src);
	    glDrawArrays(GL_POINTS, 0, size[idx]/sizeof(uint32_t)/4);	CHECK_GL_ERROR();
	    glEndTransformFeedbackNV();					CHECK_GL_ERROR();

	    src += size[idx];
	    src_size -= size[idx];
	}

#if USE_PINGPONG_BUF
	// flip buffer
	idx = (idx + 1) & 1;
#endif

	// readback
	if (first_time) {
	    first_time = false;
	} else {
	    glBindBuffer(GL_TRANSFORM_FEEDBACK_BUFFER_NV, this->tf_buf[idx]);
	    result = (uint32_t *)glMapBuffer(GL_TRANSFORM_FEEDBACK_BUFFER_NV, GL_READ_ONLY);
	    if (result) {
		memcpy(dst, result, size[idx]);
	    } else {
		res = false;
		dst_size = size[idx];	// break loop
	    }
	    glUnmapBuffer(GL_TRANSFORM_FEEDBACK_BUFFER_NV);

	    dst += size[idx];
	    dst_size -= size[idx];
	}
    }

    glBindBufferBaseNV(GL_TRANSFORM_FEEDBACK_BUFFER_NV, 0, 0);
    glBindBuffer(GL_TRANSFORM_FEEDBACK_BUFFER_NV, 0);
    return res;
}





void usage(const char *av0)
{
    printf("usage: %%%s <test | bench>\n", av0);
    exit(0);
}

void print_bytes(const char *mes, const void *bin_arg, size_t size)
{
    const uint8_t *bin = (const uint8_t *)bin_arg;
    printf("%s", mes);
    for (size_t i=0; i<size; i++) {
	printf("%02x", bin[i]);
	if ((i & 0xf) == 0xf) printf(" ");
    }
    printf("\n");
}


/*
 * test cipher (FIPS-197, Appendix C - Example Vectors)
 *
 * each ciphertexts have to be followings:
 *	128bit	69c4e0d86a7b0430d8cdb78070b4c55a
 *	192bit	dda97ca4864cdfe06eaf70a0ec0d7191
 *	256bit	8ea2b7ca516745bfeafc49904b496089
 */
void test_cipher(void)
{
    AesTransform	aes;
    const char	key[] = {
	 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31
    };
    const char plain_data[] = {
	0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
    };
    char	plaintext[sizeof(plain_data)];
    char	ciphertext[sizeof(plain_data)];
    int		nk;

    // init AES system
    aes.init(16);

    // print plaintext
    print_bytes("plaintext ", plain_data, sizeof(plain_data));

    for (nk=4; nk<=8; nk+=2) {
	// symmetric key
	printf("%d bit key\n", nk*32);
	print_bytes("key       ", key, nk*4);

	// encrypt
	aes.set_param(0, nk, key);
	aes.transform(ciphertext, plain_data, sizeof(ciphertext));
	print_bytes("encrypt   ", ciphertext, sizeof(ciphertext));

	// decrypt
	aes.set_param(1, nk, key);
	aes.transform(plaintext, ciphertext, sizeof(plaintext));
	print_bytes("decrypt   ", plaintext, sizeof(plaintext));
    }

    // dest AES system
    aes.dest();
}


/*
 * benchmark
 *
 */
void benchmark(bool transfer_only)
{
    const size_t buf_size[] = { 4*1024, 16*1024, 64*1024, 256*1024, 1*1024*1024, 4*1024*1024, 16*1024*1024 };
    const size_t data_size = 128*1024*1024;
    const size_t loop = 10;

    struct timeval tv0, tv1;
    double	sum;
    size_t	i, j;
    char	*src, *dst;

    AesTransform	aes;
    const char	key[] = {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
			  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 };
    const int	nk = 4;

    src = (char *)malloc(data_size);
    dst = (char *)malloc(data_size);
    memset(src, 0xaa, data_size);

    printf("measuring %dMB %s time --------\n",
	   data_size/1024/1024,
	   transfer_only ? "transfer" : "encryption");

    for (i=0; i<sizeof(buf_size)/sizeof(buf_size[0]); i++) {
	printf("batch size %dKB\n", buf_size[i]/1024);
	aes.init(buf_size[i], transfer_only);
	aes.set_param(0, nk, key);
	sum = 0.0;
	for (j=0; j<loop; j++) {
	    gettimeofday(&tv0, NULL);
	    if (aes.transform(dst, src, data_size) == false) {
		printf("failure in encryption.\n");
		exit(-1);
	    }
	    gettimeofday(&tv1, NULL);
	    timersub(&tv1, &tv0, &tv1);
	    sum += (double)(tv1.tv_sec * 1000000 + tv1.tv_usec);
	}
	sum /= (double)loop * 1000000.0;
	printf("avg-time %5.2f sec, throughput %6.2f MB/sec\n\n", sum, (double)data_size/1024.0/1024.0/sum);
	aes.dest();
    }

    free(src);
    free(dst);
}


int main(int argc, char *argv[])
{
    glutInit(&argc, argv);
    glutCreateWindow(argv[0]);

    if (argc < 2) usage(argv[0]);

    int		i=1;
    if (strcmp(argv[i], "test")==0) {
	test_cipher();
    } else if (strcmp(argv[i], "bench")==0) {
	benchmark(0);	// encryption
	benchmark(1);	// transfer
    } else {
	usage(argv[0]);
    }

    return 0;
}
