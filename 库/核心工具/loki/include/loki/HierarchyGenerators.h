////////////////////////////////////////////////////////////////////////////////
// The Loki Library
// Copyright (c) 2001 by Andrei Alexandrescu
// This code accompanies the book:
// Alexandrescu, Andrei. "Modern C++ Design: Generic Programming and Design
//     Patterns Applied". Copyright (c) 2001. Addison-Wesley.
// Permission to use, copy, modify, distribute and sell this software for any
//     purpose is hereby granted without fee, provided that the above copyright
//     notice appear in all copies and that both that copyright notice and this
//     permission notice appear in supporting documentation.
// The author or Addison-Wesley Longman make no representations about the
//     suitability of this software for any purpose. It is provided "as is"
//     without express or implied warranty.
////////////////////////////////////////////////////////////////////////////////
#ifndef LOKI_HIERARCHYGENERATORS_INC_
#define LOKI_HIERARCHYGENERATORS_INC_

// $Id: HierarchyGenerators.h 751 2006-10-17 19:50:37Z syntheticpp $
// 层次生成器

#include "EmptyType.h"
#include "TypeTraits.h"
#include "Typelist.h"

namespace Loki
{
    ////////////////////////////////////////////////////////////////////////////////
    // class template GenScatterHierarchy
    // Generates a scattered hierarchy starting from a typelist and a template
    // Invocation (TList is a typelist, Unit is a template of one arg):
    // GenScatterHierarchy<TList, Unit>
    // The generated class inherits all classes generated by instantiating the
    // template 'Unit' with the types contained in TList
    // 从类型列表和模板调用（TList是类型列表，Unit是一个arg的模板）开始生成分散的层次结构：
    // GenScatterHierarchy<TList, Unit>
    // 生成的类继承了通过实例化模板“Unit”并生成类型的所有类包含在TList中。
    ////////////////////////////////////////////////////////////////////////////////

    namespace Private
    {
        // The following type helps to overcome subtle flaw in the original
        // implementation of GenScatterHierarchy.
        // The flaw is revealed when the input type list of GenScatterHierarchy
        // contains more then one element of the same type (e.g. LOKI_TYPELIST_2(int, int)).
        // In this case GenScatterHierarchy will contain multiple bases of the same
        // type and some of them will not be reachable (per 10.3).
        // For example before the fix the first element of Tuple<LOKI_TYPELIST_2(int, int)>
        // is not reachable in any way!
        // 以下类型有助于克服GenScatterHierarchy的原始实现中的细微缺陷。 
        // 当GenScatterHierarchy的输入类型列表中包含一个以上相同类型的元素时（例如LOKI_TYPELIST_2(int, int)），就会发现该缺陷。
        // 在这种情况下，GenScatterHierarchy将包含多个相同类型的多个基类，并且其中一些将无法访问。 （根据10.3）。
        // 例如，在修复之前，Tuple<LOKI_TYPELIST_2(int, int)>的第一个元素无论如何都无法访问！
        template <class, class>
        struct ScatterHierarchyTag;
    }

    template <class TList, template <class> class Unit>
    class GenScatterHierarchy;

    template <class T1, class T2, template <class> class Unit>
    class GenScatterHierarchy<Typelist<T1, T2>, Unit> : public GenScatterHierarchy<Private::ScatterHierarchyTag<T1, T2>, Unit>, public GenScatterHierarchy<T2, Unit>
    {
    public:
        typedef Typelist<T1, T2> TList;
        // Insure that LeftBase is unique and therefore reachable
        // 确保LeftBase是唯一的并且因此可以访问
        typedef GenScatterHierarchy<Private::ScatterHierarchyTag<T1, T2>, Unit> LeftBase;
        typedef GenScatterHierarchy<T2, Unit> RightBase;
        template <typename T>
        struct Rebind
        {
            typedef Unit<T> Result;
        };
    };

    // In the middle *unique* class that resolve possible ambiguity
    // 在中间的*unique*类中，解决了可能的歧义
    template <class T1, class T2, template <class> class Unit>
    class GenScatterHierarchy<Private::ScatterHierarchyTag<T1, T2>, Unit> : public GenScatterHierarchy<T1, Unit>
    {
    };

    template <class AtomicType, template <class> class Unit>
    class GenScatterHierarchy : public Unit<AtomicType>
    {
        typedef Unit<AtomicType> LeftBase;
        template <typename T>
        struct Rebind
        {
            typedef Unit<T> Result;
        };
    };

    template <template <class> class Unit>
    class GenScatterHierarchy<NullType, Unit>
    {
        template <typename T>
        struct Rebind
        {
            typedef Unit<T> Result;
        };
    };

    ////////////////////////////////////////////////////////////////////////////////
    // function template Field
    // Accesses a field in an object of a type generated with GenScatterHierarchy
    // Invocation (obj is an object of a type H generated with GenScatterHierarchy,
    //     T is a type in the typelist used to generate H):
    // Field<T>(obj)
    // returns a reference to Unit<T>, where Unit is the template used to generate H
    // 函数模板字段
    // 访问用GenScatterHierarchy调用生成的类型的对象中的字段
    // （obj是用GenScatterHierarchy生成的类型H的对象，T是用于生成H的类型列表中的类型）：
    // Field<T>(obj)
    // 返回对Unit<T>，其中Unit是用于生成H的模板。
    ////////////////////////////////////////////////////////////////////////////////

    template <class T, class H>
    typename H::template Rebind<T>::Result& Field(H& obj)
    {
        return obj;
    }

    template <class T, class H>
    const typename H::template Rebind<T>::Result& Field(const H& obj)
    {
        return obj;
    }

    ////////////////////////////////////////////////////////////////////////////////
    // function template TupleUnit
    // The building block of tuples
    // 元组的组成部分
    ////////////////////////////////////////////////////////////////////////////////

    template <class T>
    struct TupleUnit
    {
        T value_;
        operator T&()
        {
            return value_;
        }
        operator const T&() const
        {
            return value_;
        }
    };

    ////////////////////////////////////////////////////////////////////////////////
    // class template Tuple
    // Implements a tuple class that holds a number of values and provides field
    //     access to them via the Field function (below)
    // 实现一个包含多个值的元组类，并通过Field函数（以下）提供对它们的字段访问
    ////////////////////////////////////////////////////////////////////////////////

    template <class TList>
    struct Tuple : public GenScatterHierarchy<TList, TupleUnit>
    {
    };

    ////////////////////////////////////////////////////////////////////////////////
    // helper class template FieldHelper
    // See Field below
    // 助手类模板FieldHelper
    // 参见下面的字段
    ////////////////////////////////////////////////////////////////////////////////

    template <class H, unsigned int i>
    struct FieldHelper;

    template <class H>
    struct FieldHelper<H, 0>
    {
        typedef typename H::TList::Head ElementType;
        typedef typename H::template Rebind<ElementType>::Result UnitType;

        enum
        {
            isTuple = Conversion<UnitType, TupleUnit<ElementType>>::sameType,
            isConst = TypeTraits<H>::isConst
        };

        typedef const typename H::LeftBase ConstLeftBase;

        typedef typename Select<isConst, ConstLeftBase, typename H::LeftBase>::Result LeftBase;

        typedef typename Select<isTuple, ElementType, UnitType>::Result UnqualifiedResultType;

        typedef typename Select<isConst, const UnqualifiedResultType, UnqualifiedResultType>::Result ResultType;

        static ResultType& Do(H& obj)
        {
            LeftBase& leftBase = obj;
            return leftBase;
        }
    };

    template <class H, unsigned int i>
    struct FieldHelper
    {
        typedef typename TL::TypeAt<typename H::TList, i>::Result ElementType;
        typedef typename H::template Rebind<ElementType>::Result UnitType;

        enum
        {
            isTuple = Conversion<UnitType, TupleUnit<ElementType>>::sameType,
            isConst = TypeTraits<H>::isConst
        };

        typedef const typename H::RightBase ConstRightBase;

        typedef typename Select<isConst, ConstRightBase, typename H::RightBase>::Result RightBase;

        typedef typename Select<isTuple, ElementType, UnitType>::Result UnqualifiedResultType;

        typedef typename Select<isConst, const UnqualifiedResultType, UnqualifiedResultType>::Result ResultType;

        static ResultType& Do(H& obj)
        {
            RightBase& rightBase = obj;
            return FieldHelper<RightBase, i - 1>::Do(rightBase);
        }
    };

    ////////////////////////////////////////////////////////////////////////////////
    // function template Field
    // Accesses a field in an object of a type generated with GenScatterHierarchy
    // Invocation (obj is an object of a type H generated with GenScatterHierarchy,
    //     i is the index of a type in the typelist used to generate H):
    // Field<i>(obj)
    // returns a reference to Unit<T>, where Unit is the template used to generate H
    //     and T is the i-th type in the typelist
    // 功能模板字段
    // 访问用GenScatterHierarchy调用生成的类型的对象中的字段
    // （obj是用GenScatterHierarchy生成的类型H的对象，i是用于生成H的类型列表中类型的索引）：
    // Field<i>(obj)
    // 返回对Unit<T>的引用，其中Unit是用于生成H的模板，而T是类型列表中的第i个类型
    ////////////////////////////////////////////////////////////////////////////////

    template <int i, class H>
    typename FieldHelper<H, i>::ResultType& Field(H& obj)
    {
        return FieldHelper<H, i>::Do(obj);
    }

    //    template <int i, class H>
    //    const typename FieldHelper<H, i>::ResultType&
    //    Field(const H& obj)
    //    {
    //        return FieldHelper<H, i>::Do(obj);
    //    }

    ////////////////////////////////////////////////////////////////////////////////
    // class template GenLinearHierarchy
    // Generates a linear hierarchy starting from a typelist and a template
    // Invocation (TList is a typelist, Unit is a template of two args):
    // GenScatterHierarchy<TList, Unit>
    // 从类型列表和模板调用生成线性层次结构（TList是类型列表，Unit是两个参数的模板）：GenScatterHierarchy<TList, Unit>。
    ////////////////////////////////////////////////////////////////////////////////

    template <class TList, template <class AtomicType, class Base> class Unit, class Root = EmptyType>
    class GenLinearHierarchy;

    template <class T1, class T2, template <class, class> class Unit, class Root>
    class GenLinearHierarchy<Typelist<T1, T2>, Unit, Root> : public Unit<T1, GenLinearHierarchy<T2, Unit, Root>>
    {
    };

    template <class T, template <class, class> class Unit, class Root>
    class GenLinearHierarchy<Typelist<T, NullType>, Unit, Root> : public Unit<T, Root>
    {
    };

    template <template <class, class> class Unit, class Root>
    class GenLinearHierarchy<NullType, Unit, Root> : public Root  // is this better: Unit<NullType, Root> ?
    {
    };

}  // namespace Loki

#endif  // end file guardian
