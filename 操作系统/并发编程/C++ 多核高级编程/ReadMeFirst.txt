Chapters 1, 2, and 3 and Appendixes A, B, C and D have no accompanying code download.

This book contains both code listings and code examples. 

--Code listings are complete programs that are compilable and runnable. In most cases they are accompanied by a program profile that tells you the environment the program was written in and gives you a description and the compile and link instructions, and so forth. 
--Code examples are snippets. They do not run as is. They are used to focus on showing how something is called or used, but the code cannot run as seen.

We want to emphasize that the code from this book is for POSIX-compliant platforms. Our complete program examples will compile and run on any environment that uses an ISO Standard C++ compiler and is compliant with the IEEE POSIX Standard for operating systems. This should include SOLARIS, AIX, DARWIN, Windows, ZOS, and Linux. But also note that though all the code is compilable, some need files, create queues, etc., before running. The code is primarily for "exposition" purposes. It was written for the purpose of demonstrating some concept. It is not code that we recommend you paste into some application, etc. Rather it is designed to demonstrate the syntax of a concept we are explaining in the book. You may notice that a number of the programs have no output.
If you do wish to pursue running this code on platforms that are not fully POSIX compliant, you can find information about POSIX support like translation libraries, etc., at the following URLs:

--http://en.wikipedia.org/wiki/POSIX
--http://www.mail-archive.com/cygwin-announce@cygwin.com/msg02232.html
--http://ericboutin.blogspot.com/2005/03/transforming-windows-box-into-posix.html

Why This Approach?

First, we recognize that not every software solution requires multiprocessing or multithreading. Some software solutions are better implemented using sequential programming techniques (even if the target platform is multicore). Our approach is solution and model driven. First, develop the model or solution for the problem. If the solution requires that some instructions, procedures, or tasks need to execute concurrently then determine which is the best set of techniques to use. This approach is in contrast to forcing the solution or model to fit some preselected library or development tool. The technique should follow the solution. Although this book discusses libraries and development tools, it does not advocate any specific vendor library or tool set. Although we include examples that take advantage of particular hardware platforms, we rely on cross-platform approaches. POSIX standard operating system calls and libraries are used. Only features of C++ that are supported by the International C++ standard are used. We advocate a component approach to the challenges and obstacles found in multiprocessing and multithreading. Our primary objective is to take advantage of framework classes as building blocks for concurrency. The framework classes are supported by object-oriented mutexes, semaphores, pipes, queues, and sockets. The complexity of task synchronization and communication is significantly reduced through the use of interface classes. The control mechanism in our multithreaded and multiprocessing applications is primarily agent-driven. This means that the application architectures that you will see in this book support the multiple paradigm approach to software development.
We use object-oriented programming techniques for component implementation and primarily agent-oriented programming techniques for the control mechanism. The agent-oriented programming ideas are sometimes supported by logic programming techniques. As the number of available cores on the processor increase, software development models will need to rely more on agent-oriented and logic programming. This book includes an introduction to this multiparadigm approach for software development.

Why C++?

There are C++ compilers available for virtually every platform and operating environment. The ANSI American National Standards Institute (ANSI) and International Organization for Standardization (ISO) have defined standards for the C++ language and its library. There are robust open-source implementations as well as commercial implementations of the language. The language has to be widely adopted by researchers, designers, and professional developers around the world. The C++ language has been used to solve problems of all sizes and shapes from device drivers to large-scale industrial applications. The language supports a multiparadigm approach to software development. We can implement object-oriented designs, logic programming designs, and agent-oriented designs seamlessly in C++. We can also use structured programming techniques or low-level programming techniques where necessary. This flexibility is exactly what's needed to take advantage of the new multicore world. Further, C++ compilers provide the software developer with a direct interface to the new features of the multicore processors.
