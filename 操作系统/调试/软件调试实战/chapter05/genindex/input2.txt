Algorithmic and Automatic Debugging Home Page

This document contains pointers to information relevant to Algorithmic and Automatic Debugging available around the world on the World Wide Web. The page was developed by Mikhail Auguston and is currently maintained by Clint Jeffery. We can not guarantee that all links are still valid, but we are trying to detect and delete broken links when appropriate.

This page was updated on 11/15/2006 23:20:15 
Items marked with this icon have been added most recently.


Enter your e-mail address to receive e-mail when this page is updated.

Your Internet e-mail address:

Lady Augusta Ada Lovelace (1815-1852) was the world's first programmer.

If debugging is the process of removing bugs, then programming must be the process of putting them in...

This beautiful picture of Lady Ada was painted by Latvian artist Inta Dobraja in 1986 and currently decorates the Department of Computer Science at Latvia University, Riga, Latvia.

According to Grace Murray Hopper, one of the computer science pioneers, here is the origin of the term debugging. In the early 1950s, the programmers at Harvard University spent weeks in an unsuccessful attempt to find the error in one of their programs. Finally, an investigation of the computer's insides revealed that an insect had died there, and its remains kept a relay from closing. Once this bug was removed, the program worked perfectly. Since then, the process of removing errors from programs has been known as "debugging".

But, according to Edsgar Dijkstra, another pioneer in computer science, the term is irresponsible. Debugging suggests that the programmer is not to blame for the error. It's as if the bug crept into the code while the programmer was looking the other way.

Citation from http://www.lafayette.edu:80/cs/cs102/lab17/debug.htm
Bibliography and WWW archives

    * Computer Science Bibliography Collection. This is a reach collection of CS bibliographies supported by a search mechanism.
    * The Computing Research Repository at Los Alamos e-print Archive sponsored by ACM
    * compilers & interpreters archive (debugging), maintained by Jon Hill.
    * functional programming archive (debugging and profiling), maintained by Jon Hill.
    *
      Formal Methods
          o The World Wide Web Virtual Library: Formal Methods, maintained by Jonathan Bowen.
          o Formal Methods Europe Information Resources. FME Applications Database: Indices
            This page gives access to the latest edition of the FME Formal Methods Applications Database. The database is maintained by Nico Plat. of Cap Volmac. The Web page is maintained by John Fitzgerald at the Centre for Software Reliability.
          o The recently released NASA guidebook "Formal Methods Specification and Analysis Guidebook for the Verification of Software and Computer Systems, Volume II: A Practitioner's Companion" [NASA-GB-001-97, 245 pages, May 1997] is now available via the web.
            This guidebook is a product of the NASA Software Program and was cooperatively developed by three NASA centers (Jet Propulsion Laboratory, Johnson Space Center, and Langley Research Center) with support from SRI International, ViGYAN, and Lockheed Martin. This volume of the guidebook is designed to:
            - Help transition formal methods from experimental use into practical application for critical software requirements and design,
            - Discuss technical issues involved in applying these techniques to aerospace and avionics software systems, and
            - Provide an overview of the current status of formal methods techniques.
          o An On-Line Repository of Formal Methods Educational Materials maintained by Kathi Fisler at Rice University.
            "We are collecting materials from courses, seminars, and course modules in areas such as

                - computer-aided verification
                - theorem proving
                - programming languages
                - logic
                - software engineering
                - security

            Pointers to innovative materials that adopt a formal approach to other areas of computer science and system design are also welcome! The site contains pointers to

                - course web pages (including syllabi and handouts)
                - tools that have been used successfully in courses
                - suggested reading materials
                - project and example suggestions
                - events and workshops related to formal methods education

          o Formal Methods Research at Carnegie Mellon University
          o Formal methods Around the World, maintained at the Laboratory for Applied Logic at Brigham Young University 

    * Parallel Debugger Bibliography This online bibliography, maintained by Cherri Pancake (Oregon State) and Robert Netzer (Brown University) includes technical reports, journal and conference papers, and Ph.D. dissertations dealing with parallel debuggers. Ftp site also at Brown University.
    * Program Slicing
          o Program Slicing References, maintained by Jim Lyle.
          o Program Slicing Internet Resources, maintained by Mark Harman.
          o Program Slicing home page, maintained by Jens Krinke. 
    * Program Static Analysis
          o List of static analysis tools, maintained by Brian Maric
          o LCLint static property checker at University of Virginia 

    * Model Checking at CMU. Model checking is a method for formally verifying finite-state concurrent systems. Specifications about the system are expressed as temporal logic formulas, and efficient symbolic algorithms are used to traverse the model defined by the system and check if the specification holds or not. Extremely large state-spaces can often be traversed in minutes. The technique has been applied to several complex industrial systems such as the Futurebus+ and the PCI local bus protocols.
    * Program Result-Checking . This link leads to Hal Wasserman's home page containing a survey of an approach to program checking and correcting developed in the works of Manuel Blum et al. , a bibliography on Result-Checking, and a list of researchers in Result -Checking.
    * Semantics-Based Program Analysis and Manipulation, maintained by W. Scherlis.
    * Program Testing
          o STORM - Software Testing Online Resources, maintained by Roland H. Untch 

    * High Performance Debugging Forum
    * Links to real-time software debugging and testing info, maintained by Jon Eliot Stroemme
    * ParaSoft Technical Papers Archive
    * Microsoft Windows NT and Windows 2000 Debugging Resources
    * Software Systems Dept.: Seminar »Automatisches Debugging« Universität Passau
      Lehrstuhl für Softwaresysteme
    * Haskell Debugging Technologies, mainatained by Andy Gill

    * Debugging Tools for Dynamic Storage Allocation and Memory Management

      This list is maintained by Ben Zorn, who is now working at Microsoft Research, in Redmond, WA.

Books and Special Journal Issues

    *

      Andreas Zeller,
      "WHY PROGRAMS FAIL: A Guide to Systematic Debugging", Morgan Kaufman, 2005
    *

      Monitoring and Debugging of Distributed and Real-Time Systems,
      (Eds. Jeffrey J.P.Tsai, Steve J.H.Yang), IEEE Computer Society Press, 1995, pp.430,
      This is a collection of 25 papers and a bibliography on related topics.
    *

      Debugging and Performance Tuning for Parallel Computing Sysytems, (Eds. Margaret L.Simmons, Ann H.Hayes, Jeffrey S.Brown, and Daniel A.Reed), IEEE Computer Society Press, 1996, pp.403.
    *

      Communications of the ACM, Vol. 40, #4, April 1997, A Special Issue with the subtitle "The Debugging Scandal"
    *

      Raimondas Lencevicius,
      "Advanced Debugging Methods", The Kluver International Series in Engineering and Computer Science, 2000
    *

      Clinton L. Jeffery,
      "Program Monitoring and Visualization: An Exploratory Approach", Springer, New York, 1999.

    *

      Automated Software Engineering: An International Journal (Kluwer Academic Publishers,USA)
      Volume 9, Issue 1, January, 2002:
          o Extension Language Automation of Embedded System Debugging, Dale Parson, Bryan Schlieder, Paul Beatty
          o Slicing of Constraint Logic Programs, Gyongyi Szilagyi, Tibor Gyimothy, Jan Maluszynski
          o Kima -- an Automated Error Correction System for Concurrent Logic Programs, Yasuhiro Ajiro, Kazunori Ueda
          o Non-intrusive on-the-fly data race detection using execution replay, Michiel Ronsse and Koen De Bosschere

      Volume 10, Issue 1, January, 2003:
          o Query-Based Debugging, R. Lencevicius, U. Holzle, A.K. Singh
          o Support for Debugging Automatically Parallellized Programs, Gabriele Jost and Robert Hood

Conferences and workshops on Debugging and related topics

    * AADEBUG 2007, April 23-25, 2007, Graz, Austria

    * AADEBUG 2005, September 19-21, 2005, Monterey, CA

    * Workshop on the Evaluation of Software Defect Detection Tools June 12, 2005, co-located with PLDI 2005, Chicago, IL.

    * VMCAI'04, January 11-13, 2004, Venice, Italy
          o Call for papers at http://www.dsi.unive.it/~vmcai04/cfp.htm 

    * AADEBUG 2003, September 8-10, 2003, Ghent, Belgium

    * Workshop on Specification and Verification of Component-Based Systems (SAVCVS'03), September 1-2 2003 at ESEC/FSE 2003, Helsinki, Finland
    * Workshop on Advancing the State-of-the-Art in Runtime Inspection, 22 July 2003 at ECOOP 2003, Darmstadt, Germany
    * Third Workshop on Runtime Verification, 13 July 2003 at CAV'03, Boulder, Colorado
    * AVOCS'03, Automatic Verification of Critical Systems, April 2-3, 2003, Southhampton, England
    * AADEBUG' 2000, August 28-30, 2000, Munich, Germany
          o On-line Proceedings of the AADEBUG'2000 
    * The First International Workshop on Automated Program Analysis, Testing and Verification, June 4-5, 2000, Limerick, Ireland
    * AADEBUG'97 , May 26-27, 1997, Linköping, Sweden
          o On-line Proceedings of the AADEBUG'97 
    * AADEBUG'95 , May 1995, Saint-Malo, France
    * AADEBUG'93 and AADEBUG'95

Testing and Debugging tool design projects

Disclaimer: this list is not exhaustive! Please let me know if you would like to be added to this list , or if you would like an existing entry modified or deleted.

    * Dyninst is a dynamic instrumentation API for C/C++, built atop technology developed originally for Paradyn.
    * GUP Linz - Debugging of Distributed Memory Machines
    * Declarative debugging of lazy functional programs, Lee Naish,
      Dept. of Computer Science Melbourne University
    * Centre d'Etude et de Recherche en Informatique du CNAM
    * LRR-TUM
    * Stanford University, Program Analysis and Verification Group, The Stanford Rapide Project, ANNA annotation language for Ada, TSL annotation language for Ada
    * GUARD (Griffith University Relative Debugger) Project. GUARD uses a paradigm called relative debugging, which allows a user to test a program by comparing data structures between the debugged code and a reference version. (the link has changed!)
    * Poet - The Shoshin Debugger, Department of Computer Science at the University of Waterloo
    * Ariadne Project Home Page, University of Oregon
    * Several projects at Saarland University, Saarbrücken:
          o Delta Debugging Project. Delta Debugging automatically isolates cause-effect chains from real programs with real bugs.
          o DDD - The Data Display Debugger. The Data Display Debugger (DDD) is a popular graphical user interface to command-line debuggers such as GDB, DBX, or XDB. DDD displays data structures as graphs. 
    * DiSCiPl Debugging Systems for Constraint Programming. Academic partners: INRIA, University of Bristol, Linkoping University, Technical University of Madrid, COSYTEC, ICON, OM Partners, PrologIA.
    * MrSpidey - an interactive static debugger for Scheme
    * SmartGDB project at the University of Kansas
    * VeriSoft is a tool for software developers and testers of concurrent/reactive/real-time systems developed in the Software Production Research Department, Bell Laboratories, Lucent Technologies. For more information on other research projects related to VeriSoft, see Patrice Godefroid's home-page.
    * GDB: The GNU Project Debugger
    * Software Visualization Research at GVU
    * buddha, a declarative debugger for Haskell from University of Melbourne.
    * Stabilizer, an approach to quickly stabilizing (helping users avoid the bugs within) GUI programs. 



Testing and Debugging Tools and Services

    * ADL -- Better Software by Assertion from SUN Microsystems. ADL (Assertion Definition Language) is a specification language for programming interfaces. It can be used to describe the programmer's interface to any C-callable function, library or system call.
    * Pilot C/C++/CHILL tester, ongoing work Kvatro Telecom, Trondheim, Norway,
      The Pilot is an asynchronous, real-time debugger and test execution engine for multiple networked multi-threaded programs written in C, C++ or CHILL. It is suitable for regression testing, conformance testing and on-line extension as well as fault finding.
    * Developed by PARASOFT Corporation.


      Insure++ is an automatic runtime error detection tool for C and C++ programming;






      Code Wizard is a comprehensive tool for Code Analysis in C++ programs. CodeWizard is based on the popular programmer reference - "Effective C++" by Scott Meyers. It provides software enforcement of the rules/items discussed in the book.


      For more information and a free evaluation, please contact Bernie Green at
      bernie@parasoft.com, or call toll-free 1-888-305-0041x153.
    * Assure: Automatic debugging tool for multithreaded parallel Java programs by KAI company.

    * MicroSoft WinDbg Debugger

    * TotalView debugger by Etnus

    * Let's debug portal
      Provides a forum for programmers to submit their buggy code and have the team at Let's Debug.com have a shot at debugging it. If permitted by the owners of the code, the code will be made public for programmers at large to have a go at debugging it.

    * TESTING TOOLS FOR EMBEDDED APPLICATIONS by PolySpace Technologies

    * VALGRIND and CACHEGRIND an Open Source equivalent to Purify or Insure, works only under Linux.
      Valgrind is a GPL'd tool to help you find memory-management problems in your programs. When a program is run under Valgrind's supervision, all reads and writes of memory are checked, and calls to malloc/new/free/delete are intercepted. As a result, Valgrind can detect problems such as:
          o Use of uninitialised memory
          o Reading/writing memory after it has been free'd
          o Reading/writing off the end of malloc'd blocks
          o Reading/writing inappropriate areas on the stack
          o Memory leaks -- where pointers to malloc'd blocks are lost forever
          o Passing of uninitialised and/or unaddressible memory to system calls
          o Mismatched use of malloc/new/new [] vs free/delete/delete []
          o Some misuses of the POSIX pthreads API
      Valgrind contains built-in support for doing very detailed cache profiling. Since we already intercept every read and write, and have all the debugging information for your program close to hand, it's not too hard to also do a detailed simulation of your CPU's L1-D, L1-I and unified L2 caches. The supplied vg_annotate program will show your source code with these counts attached to every line. The cache arrangement of your CPU is auto-detected using the CPUID instruction. If that doesn't work or you want to override it, you can specify custom cache parameters on the command line. The manual contains full documentation of this new feature.
      You just need to put cachegrind in front of your program invocations, rather than valgrind.

    * AskIgor (http://www.askigor.org/) is an experimental automated debugging server that tells you why your program fails. Just submit the program to get the diagnosis.

    * Verifysoft Technology GmbH offers tools for automated unit testing, test coverage analysis, and complexity measures for C, C++, and Java.

    * Dynamic Memory Solutions' Dynamic Suite is a set of tools for leak detection, garbage collection, code coverage, memory debugging and application profiling. All of the tools can be used without recompiling or relinking of source code. The focus of the Dynamic Suite is Unix and C/C++ programs. The Dynamic Suite is a commercial product, limited-time evaluation copies are available.
      Contact Person: Dynamic Memory Solutions (sales@dynamic-memory.com).
      WWW Site: http://www.dynamic-memory.com

    * DebugLab is a Korean-language site focusing on debugging. The site is operated by a Microsoft .NET MVP.

    * Ebenezer Enterprises offers some free services aimed at helping C++ developers, including a C++ Debug Tool that automates the building of logging software. 

Some home pages of researchers working on Algorithmic and Automatic Debugging theory and design, and in related areas

Disclaimer: this list is not exhaustive! Please let me know if you would like to be added to this list , or if you would like an existing entry modified or deleted.

    * David Abramson, Monash University, GUARD (Griffith University Relative Debugger) Project.

    * Mikhail Auguston , Computer Science Department of U.S. Naval Postgraduate School
      Programming Languages Design and Implementation, Testing and Debugging Automation, Assertion Languages.

    * Alessio Bechini University of Pisa, Italy - Dept. of Information Engineering
      Research interests:
         1. Analysis and design techniques for concurrent systems
         2. Analysis, evaluation and design of parallel embedded systems. 
      A. Bechini has focused his attention on the architectural design of tools to support dynamic analysis of concurrent applications in a number of diverse execution environments.

    * Karen L.Bernstein. Research interests include programming environments, programming languages, software engineering and concurrent systems. Dissertation research was concerned with the application of techniques from programming language theory to the design and implementation of debugging tools for high-level programming languages.

    * Yaodong Bi, Department of Computing Sciences University of Scranton,
      Areas of Interest: Real-time Systems, Software Testing and Debugging, Software Engineering

    * Dominic Binks , PhD thesis "Declarative Debugging in Goedel" available via WWW in gzipped postscript format.
      email: dominic@aethos.demon.co.uk
      Aethos Communication Systems Ltd., 220 Park Avenue, Bristol BS8 1SB
      Telephone: +44 1454 614455 Fax: +44 1454 620527

    * James P. Black, Department of Computer Science at the University of Waterloo Research interests: distributed debugging, network management, distributed systems, reliability and performance analysis. Director of the Shoshin distributed system group.

    * Francois Bourdoncle, École des Mines de Paris
      Direction des Recherches 60, Boulevard Saint-Michel 75272 Paris Cedex 06 FRANCE
      Research interests: Programming languages design, semantics and implementation. Compilation. Static analysis of programs. Abstract interpretation. Automatic debugging. Object-oriented programming and technologies. Type theory and type inference. Information technologies in a broad sense.

    * James C. Browne, University of Texas at Austin,
      Parallel computation with the major focus on parallel programming, high level specification languages and integration of computer science with application areas, Visual Programming and Debugging for Parallel Computing.

    * Berndt Bruegge , Technische Universität München,
      Interests
          o Distributed object-oriented systems
          o Reusable architectures
          o Diagnositics
          o Multi-project management

    * Peter Buhr - University of Waterloo
          Polymorphism, persistence, concurrency, and concurrent monitoring, visualization and debugging.

    * Miguel Calejo, Declarativa. I worked on declarative diagnosis of logic programs and Prolog between 1987 and 1991. If you're interested in optimal algorithms for both pure and impure logic programs, declarative source debugging, GUI-based implementations and other goodies you may want to read "A Framework for Declarative Prolog Debugging", PhD Thesis, Universidade Nova de Lisboa, Portugal, 1992. Available as a Word document from http://www.declarativa.com/people/mc/mcstuff/PhDthesis.zip

    * Holger Cleve at Saarland University, Saarbrücken, Germany. I work on integrating Delta Debugging with program analysis.

    * Marco Comini, PhD Student, Member of the Logic Programming Group.

    * Patrick Cousot, Département d'Informatique (DI)
      École Normale Supérieure (ENS)
      Abstract Interpretation and its applications to the semantics and verification of computer programs by static analysis. (This web page contains links to bibliography and other web resources on abstract interpretation.)

    * Janice E. Cuny, University of Oregon, Computer & Information Science
      Research Areas: Parallel Debugging, Parallel Programming Environments

    * C . Delara, Main interests are intelligent debugging systems, program understanding, and knowledge-based software engineering.

    * Laurie Dillon, Department of Computer Science, Michigan State University, East Lansing, MI 48864
      Research interests: Formal methods for specification and validation of concurrent systems; software engineering; programming languages.

    * Wlodzimierz Drabent, Logic Programming, Constraint Programming
          o Institute of Computer Science of the Polish Academy of Sciences.
          o Logic Programming Laboratory, Department of Computer and Information Science, Linköping University, Sweden.
          o Institute of Informatics, Warsaw University. 

    * Mireille Ducasse , IRISA, Research interests: Dynamic Analysis, Automated Debugging.

    * Peter Fritzson, PELAB - Programming Environments Laboratory
      Department of Computer and Information Science, Linköping University, S-581 83 Linköping, Sweden
      Programming environments for parallel and serial computers, Debugging tools and methods, e.g. semi-automatic debugging methods, and declarative debugging for lazy functional languages, High-level languages and environments for Scientific Computing, Compilation techniques, Program slicing.

    * Keith Gallager, Computer Science Department, Loyola College in Maryland
      Software Process, Program Slicing

    * Vijay Garg , UT Austin,
      Research interests: Distributed Systems, Discrete event systems and software engineering

    * Ann Q. Gates , University of Texas at El Paso, El Paso, TX
      I am interested in the use of integrity constraints in a programming language as a software development and software maintenance tool, specification languages, rapid prototyping and reusability.

    * Patrice Godefroid, Software Production Research Department, Bell Laboratories, Lucent Technologies
      Research interests include:
          o Verification and testing of communication protocols (automatic analysis methods for reactive and concurrent systems, model-checking algorithms, formal specification languages, logics of programs), program analysis, design methodologies, software engineering.
          o Methods for exploring and representing large state spaces, search techniques in artificial intelligence.
          o Automatic synthesis of reactive controllers, planning, control theory. 

    * Thomas Gross, Computer Science, Carnegie Mellon University
      I am interested in programming and software construction: compilers, the interface between hardware and software, parallel systems, distributed systems, and networks.

    * Thorsten Grötker, Ulrich Holtmann, Holger Keding, and Markus Wloka, (Email: mgwloka@gmail.com) are writing an introductory textbook on how to debug C/C++ software. The website debugging-guide.com was created to augment the book, by listing up-to-date references on the topic of software debugging: access to tools, books, journals, research papers, conferences, tutorials, and web links. It is also planned to distribute examples and other material through the website. The authors develop software and methodology for simulation and debugging, as applied to the domains of embedded systems, dataflow, SystemC, and hardware description languages such as SystemVerilog, Verilog, VHDL.

    * Mark Harman, School of Computing , University of North London .
      Research Interests: Slicing, Transformation, Metrics, Testing, Formal Methods.
      Project Project research on slicing and related technologies.

    * Tim Heyer Department of Computer and Information Science at Linköping University in Sweden. I am working at the Real-Time Systems Laboratory. My current research is about assertional programming. The aim is to conceive a method for automated support in software development and verification, especially focused on software for process control.

    * Erwan Jahier , IRISA - Project Lande. Research interest concerns dynamic analysis of Mercury programs, also have implemented Opium-M, a debugger/trace analyzer for Mercury programs within the European R & D project ARGo.

    * Clinton L. Jeffery, New Mexico State University
      Areas of Interest:
          o programming languages
          o program execution monitoring
          o program visualization 
      Current research projects include the Unicon programming language, the Godiva Programming Language, and the Alamo execution monitor architecture.

    * Mariam Kamkar, PELAB - Programming Environments Laboratory
      Department of Computer and Information Science, Linköping University, S-581 83 Linköping, Sweden
      Debugging tools and methods, Program slicing.

    * Gabriella Kokai, Ph.D. student at the Department of Computer Science Jozsef Attila University
      Research interests: Inductive Logic Programing , Program Testing, Slicing, Automated Debugging

    * Bogdan Korel, Illinois Institute of Technology,
      Research interests: Software engineering, automated software system analysis, software reliability and testing. Program Slicing.

    * Dieter Kranzlmueller, I am a research assistent at the GUP-Linz. My main job is the development of a parallel debugger for MIMD-machines.

    * Thomas Kunz, Department of Computer Science at the University of Waterloo
      The focus of my research activities so far has been in the area of distributed and parallel systems. I examined issues in load-balancing while staying as exchange student at the University of Illinois, Urbana-Champaign, in 1988/89. My master's thesis dealt with distributed object-oriented programming languages. My Ph.D. research addresses the behaviour visualization of distributed and parallel applications to facilitate the program understanding task, for example during distributed debugging.

      Currently, I am a member of the Shoshin research group. We have two major projects on the go:
          o MANDAS
          o Mobile Computing 
      Additionally, I am interested in problems of program understanding and reverse engineering in distributed applications. In particular, I am looking at ways to derive abstractions automatically to visualize the execution of parallel and distributed applications at high abstraction levels. Information for such automatic abstraction tools can come from plan libraries, static source analysis and other sources. The resulting abstractions can be read in by Poet, the visualization tool developed within the MANDAS project, to provide high-level execution visualizations.
    * Insup Lee
      Research Interests: Formal Methods and Tools, Operating Systems, Programming Languages, and Software Engineering for Distributed Systems, E-commerce Systems, Embedded Systems, Hybrid Systems, Mobile Systems, and Real-Time Systems.
      Run-time monitoring and checking project for Java

    * Raimondas Lencevicius, Nokia Research Center, Boston.
      Currently working in the areas of trace analysis, performance analysis, resource management and scheduling.
      Ph.D. thesis at University of California, Santa Barbara: "Query-Based Debugging".
      Query-based debuggers allow programmers to ask questions about object relationships during a program runtime. The debugger detects and displays broken relationships between objects while the program is running.

    * Bil Lewis - Bil@LambdaCS.com. I am working on "Omniscient Debugging" -- the idea that a debugger should maintain full knowledge of the state of a program at all times, and that programmers should be able to "revert" the debugger to display that state any time they want to. Essentially a time-machine view of debugging. Related to "Reversible Debugging," but distinct in the sense that it doesn't actually reverse anything, it just displays what used to be there. The "ODB" is a fully functional, open source implementation in Java, available at LambdaCS.com.

    * Calvin Lin, Department of Computer Sciences the University of Texas at Austin. Compilers and languages for parallel computing, parallel performance analysis, scientific computing,
      The Ariadne Debugger: Scalable Application of Event-Based Abstraction

    * Lunjin Lu , Department of Computer Science, University of Waikato, Hamilton, New Zealand. Research Interest: Constraint and logic programming, Semantics-based program analysis and manipulation, program debugging, and Intelligent tutoring systems.

    * David Luckham Stanford University, Program Analysis and Verification Group, specification languages, prototyping languages for large scale systems, and advanced programming environment support tools.

    * Sarah Mallet. I'm  actually Phd student in the  LANDE  project at IRISA under the direction of Mireille Ducassé.  I'm working on debugging and explanations for deductive databases.

    * John Mellor-Crummey Rice University - Computer Science Department
      John Mellor-Crummey's research interests focus on topics in large-scale parallel computation including architectures, operating systems, programming environments, and algorithms. Recent work with M. Scott on synchronization for shared-memory multiprocessors has led to novel algorithms for mutual exclusion, reader-writer control, and barrier synchronization. These algorithms avoid memory and network contention by exploiting locality in a multiprocessor's memory hierarchy and thus provide attractive alternatives to costly special-purpose synchronization hardware. In the area of programming environments, his work has focused on support for debugging shared-memory parallel programs. For the ParaScope programming environment, he has developed an asymptotically efficient strategy for detecting data races in program executions and is currently exploring compile-time analysis strategies to minimize the amount of instrumentation needed to guarantee that no data race will go unnoticed.

    * Barton P. Miller Computer Sciences Department University of Wisconsin 1210 W. Dayton St. Madison, WI 53706-1685
      Paradyn Parallel Performance Tools project

    * Mark Minas, Member of the research staff of the Department of Computer Science II of the University of Erlangen-Nürnberg, Germany.

      My main research interests are fault detection, debugging of parallel programs, visual languages, and programming in general. Currently, I'm involved in creating a generator for diagram editors and in parallel debugging.

    * Lee Naish Dept. of Computer Science, Melbourne University, Parkville 3052, Australia
      E-mail: lee@cs.mu.oz.au, Phone: +61 3 9344 9156, Fax: +61 3 9348 1184
      Declarative debugging and testing of logic and functional programs.

    * Henrik Nilsson, University of Nottingham. My current research interests include: lazy functional programming, implementation techniques for lazy functional languages, debugging tools for lazy functional languages.

    * Michael Oberhuber Deterministic execution of parallel programs, Replay and causal relationships of parallel programs, Development of a monitoring system for Parsytec CC/PowerXplorer systems
      (Project TO OLWORLD) , PVM Monitoring system

    * John O'Donnell - Glasgow
          Using functional programming to specify and reason about parallel systems such as digital circuits and data parallel architectures; nondeterminism; debugging; functional programming environments.

    * Ned Okie Email: nokie@rucs.faculty.cs.runet.edu
      Automatic debugging, Object-oriented programming, Functional programming languages, Programming language semantics, Parallel systems, Limits of computation

    * Harish Patil University of Wisconsin-Madison, USA

    * Norman Ramsey, Harvard University
      Particular interests include retargetability, literate programming, debugging, and formal methods.

    * David S. Rosenblum , Research interests are centered on the creation and application of powerful automated tools and techniques for building large-scale software systems, based on the use of scalable, formal program models and specification languages. His research has addressed a wide range of problems spanning the breadth of the software development life cycle, including software specification, architecture, design, testing, analysis and maintenance, as well as problems underlying the processes that guide large software projects.  His current research is focusing on the problem of validating distributed component-based software system; this research is being funded in part by a CAREER grant from the National Science Foundation.

    * Peter Rüppel Software testing with special interest in testing of object-oriented software, Quality assurance

    * Nahid Shahmehri, Intelligent Information Systems Laboratory, Department of Computer and Information Science, University of Linköping, S-581 83 Linköping, Sweden
      programming theory and languages, debugging tools, compiling technology, information management, business process modelling, CSCW, Theory and methods for advanced information systems.

    * Ehud Shapiro, Weizmann Institute, Department of Mathematics , - first publications on Algorithmic Debugging (1982)

    * Sameer Shende, CS Dept, University of Oregon, Ariadne Project

    * Tony Sloane Department of Computer Science James Cook University of North Queensland Townsville, QLD, 4811 AUSTRALIA
      The Eli compiler construction system, Performance of automatically generated programs, Program slicing, Function argument values, Debugging systems and abstraction, Attributed graphs, Generation of program analysis tools, Boomerang: reconfiguring WWW pages

    * Mary Lou Soffa Dept of Computer Science, Univ. of Pittsburgh Pittsburgh, PA 15260 Email: soffa@cs.pitt.edu
      Research Projects: Parallelizing and Optimizing Compilers, Program Analysis, Debugging of Optimized Code, Software Tools

    * Rok Sosic , Dynascope , and GUARD (Griffith University Relative Debugger) Projects.

    * Gene Spafford, Purdue University, Research interests: Computer and network security, Ethical and societal implications of computing, Software validation, verification, and debugging, Reliable distributed computer systems

    * Jan Sparud PhD student at the Computing Science Department at Chalmers University. I am interested in the design and implementation of programming languages and programming environments. I am particularly interested in lazy functional languages, such as LML and Ha s kell. My current project is the design of a debugger for lazy functional languages.

    * Jon Eliot Stroemme, Kvatro Telecom, Trondheim, Norway,
      Professional Interests: Debugging and testing networked, threaded real-time software. I am the designer and one of the implementors of the Pilot, an asynchronous, real-time debugger for multiple networked multi-threaded programs written in C, C++ or CHILL. See the Pilot Page Communication protocols. Computer languages, compiler and interpreter construction. CASE. Configuration Management. On-line extension of real-time, threaded software.

    * David Taylor Department of Computer Science at the University of Waterloo
      My research interests are in two areas: fault tolerance and distributed computing systems. At present, most of my research activity is in the latter area, concentrating on techniques and tools for debugging distributed applications. Our research group has developed a good understanding of techniques for displaying execution histories of distributed (or parallel) applications and for applying abstraction to large histories so that currently irrelevant detail can be suppressed and relevant features more easily seen. Many of our theoretical ideas have been implemented in a prototype tool presently known as POET (Partial-Order Event Tracer). We are currently beginning to explore the application of our ideas concerning debugging to systems and application management in distributed systems.

    * Frank Tip, I am a Research Staff Member at the IBM T. J. Watson Research Center in Yorktown Heights, New York.
      I work in the Program Analysis, Transformation, and Visualization group, which is part of Software Development Technology. The main focus of my work at IBM is on the development of algorithms and tools that assist programmers with the understanding and porting of object-oriented software. My primary research interests are: program analysis, program slicing, program understanding, analysis of object-oriented languages, class hierarchy transformations, program restructuring/transformation, Year2000 analysis, and compiler-optimization techniques.

    * Steve Turner, Department of Computer Science, University of Exeter, ENGLAND, Research Interests: development of algorithms, languages and environments that make the transition from sequential to parallel computing easier; use of optimistic execution techniques as a parallelization tool for general purpose object-oriented languages; development of a visual programming environment that comprises tools for visual programming, debugging and performance analysis.

    * Kazunori Ueda, Waseda University, Department of Information and Computer Science
      Current research interests include design and implementation of programming languages, logic programming, concurrency and parallelism, knowledge information processing, and interactive systems. Of particular interest are concurrent logic/constraint programming and applications of constraint-based program analysis.

    * Roland Wismüller, TU München
      Institut für Informatik, SAB
      Lehrstuhl für Rechnertechnik und Rechnerorganisation
      D-80290 München
      Research Projects:
          o On Line Monitoring Interface Specification
          o Development of an OMIS Compliant Monitoring System
          o Development of a Parallel Debugger for PVM
          o SFB 342, Teilprojekt A1
          o Development of a debugger and a monitoring system for Parix/PowerPC systems 

    * LEA D. F. WITTIE, Computer Science Ph.D. Candidate, Dartmouth College, Hanover, New Hampshire, Algorithmic and Thought Guided Debugging

    * Andreas Zeller at Saarland University, Saarbrücken, Germany. I work on Delta Debugging, a method that automatically isolates cause-effect chains from real programs with real bugs.

    * Jianjun Zhao, Department of Computer Science and Engineering, Fukuoka Institute of Technology, Japan. Email: zhao@cs.fit.ac.jp Research interests:
      (1) Architectural-level dependence analysis, slicing, testing, and debugging of software systems [ project web page ]
      (2) Analysis and testing tools for object-oriented software
      (3) Automatic debugging 



This page has been accessed times since February 16, 1996

If you need help with installing a counter on your own page, contact Web-Counter Usage Page

This page was developed by Mikhail Auguston and is maintained by Clint Jeffery

Please submit your suggestions and new links by emailing Clint Jeffery .

Surface mail address:

    Computer Science Department
    New Mexico State University
    Las Cruces, NM 88003, USA

Last updated: 11/15/2006 23:20:15 

May the source be with you,
but remember the KISS principle ;-)

Softpanorama: (slightly skeptical) Open Source Software Educational Society
Google 	
  	
Web 	www.softpanorama.org
Debugging

News
	

See also
	

Recommended
	

General
	

 Coding standards
	

C++
C++ Gotchas 	How Not to Program in C++ 	Debugging C++ 	Debugging Windows Programs 	Debugging Applications for Microsoft .NET 	Practical Debugging in C++
Softpanorama Mini Bookshop
(in cooperation with Amazon.com)

Search Amazon by keywords:

 You can use Honor System to make a contribution, supporting this site

This page was created for my students to help them in their programming assignments. To use OS/languages  effectively, you need to not just know the syntax and features of the particular language and API of the operating system, but you must develop an set of skills called debugging skills. Good books might help because they provide you some framework and a bit of the view on the problem. Among simple things not often mentioned in the books I would suggest the following:

        * No matter what problem you fighting with, rremain calm. Do not debug until you are fully exhausted. Switch activity. Take breaks.
              o Panic paralyzes your ability to think through the problem and find a solution. Slow down and calm down.
              o Understand that errors are inevitable and this is a fact of life to be lived with , not a problem to be solved.
              o Get a night's sleep and try tomorrow (cannot be done if your deadline is tonight ;-)
              o Take a pause and try it again

        * Avoid typing errors, use fully debugged prototype as a template whenever possible. Many times I see that problems arise when students try to type too quickly or type in an example what can be simply copies from the file. Most textbooks provide an archive with the examples that should be used instead of typing them in (that does not mean that those examples are always correct ;-). Get a better keyboard: full side keyboard with a nice keys feel  and a key-click (like IBM keyboards) helps to typing errors; copy constructs is you are unsure about syntax and then modify them. Remember that in programming languages typo is not always demonstrate itself in an obvious way. it much to do you bet to avoid them than to debug the program after you made one or several of them.
           
        * Use the best editor you can get and get a list of typical language errors. Get a nice editor with syntax highlighting and language help. If the editor is intagrated with the debugger (IDE environment) that's even better.
           
        * Use GUI environment. If possible do not debug programs using telnet.
          Telnet is too primitive and you should aviod it if you can. Use X windows, VNC or terminal servives. Yo wil have a better support for your keyboard and your monitor.  These may or may not work--the way the backspace and delete keys are mapped to their functions are not always done correctly.
           
        * Seek clarity. Use style books to simplify your programs and to create your own programming style.  Simplify your program  Avoid debugging everything at once. Remove non-essential modules if you face really complex problem. you can always add them later. Simplification helps you focus on a new task or way of approaching a problem.
           
        * Don't flirt with deadlines.
          If you start your work close to the deadline, you may run into trouble that you might not be able to resolve in time. In the real world, real deadlines mean either money lost or money gained. In the university world you can lower your score considerably but postponing the assignemnet till the last day. If you do something in a hurry the quality suppfers and you might experience more debugiingproblem then if you have some space to breath. If you miss a deadline, you may lose some or all points for the assignement. 
           
        * Do not strive for perfection. Understand that any OS and any language was written for humans and by humans and thus is a language, full of ambiguity, inconsistencies, history, and culture.
          The same is true about textbooks and teachers ;-).
           
        *

          The combination of hardware, networks, operating systems, and software gives rise to a high level of complexity. When problems arise, I have found it is best to try some troubleshooting techniques, then try something else, rather than trying to figure out exactly what went wrong (however, I do read error messages and look for any clues on the screen).
           
        * Try to get as much help from your previous mistakes as possible.
          People tend to repeat the same errors again and again. If you do not keep the log you can spemd a lot of type bugling you head against the same wall, when the door is nearby. Each time you have found a non-trivial error in your program, write down the program fargment, the effor messages and the solution. Next time it might save you a lot of time.
           
        * Realize that there are many paths to getting things done.
          There are usually many ways to accomplish a task. Don't get too dogmatic about finding the one and only one way to do it, nor get too over-involved in figuring out every way to do something.
           
        * Make maximum use of Intenet and your environment.
          Use GUI environment is you can and have several several windows opened at the same time. You can also use a second computer for reference if it is availble.
              o Have language help always opened.
              o Convert example from the textbook into a webpages if you can and have this site always opened too.

           Keep all of these windows up while working until you get your task done. Don't be afraid to bring up another Web browser, and keep the Web browser showing task information or reference information up. I've seen many students go through the trouble of bringing up a Web browser, following links to the assignment description, looking up a requirement for the assignment, then closing that Web browser, only to have to repeat the entire process when they need to look at the assignment description or reference information again. Don't be afraid to have as many windows open at the same time showing different information to get your work done.

Old and Very Old News ;-)

A P R E S S . C O M Books for Professionals, by Professionals ...

Software Exorcism: A Handbook for Debugging and Optimizing Legacy Code

Chapter 7: Final Words of Advice


Visual Basic .NET Debugging Handbook

Comprehensive VB .NET Debugging
General
Program style, design, efficiency, debugging, and testing
by Dennie Van Tassel
Avg. Customer Rating: 5.0 out of 5 stars
Editions: Hardcover | Unknown Binding
5 out of 5 stars "Lore of Programming" - from preface, November 4, 2000
 
  	Reviewer: engineersoftware (see more about me) from San Gabriel, CA United States
Published in 1978. Each chapter contains a well-conceived set of programming maxims and a thorough set of exercises. Excellent discussing of commenting techniques and program style. "Comments should provide something extra - not just paraphrase the code." Example code fragments are presented in COBOL, FORTRAN, ALGOL, and PL/I. The program design chapter covers simplicity, problem definition, algorithm selection, generality, modest goals, and structured programming. Discussion of issues related to programs stored on punch cards and executed by machine room operators provides a humorous historical context. "Large monolithic programs are like a plate of spaghetti: pull it here and something moves on the other side." Spaghetti code issues still appear in the object-oriented programs of the 1990's. --This text refers to an out of print or unavailable edition of this title
 

Debugging with GDB: The GNU Source-Level Debugger for GDB
by Richard M. Stallman, Cygnus Solutions

Debugging techniques in large systems

    * Unknown Binding: 148 pages
    * Publisher: Prentice-Hall; (1971)
    * ASIN: 0131973193

Books Program Debugging The Prevention and Cure of Program Errors

    * Textbook Binding
    * Publisher: Elsevier Science; (June 1973)
    * ASIN: 0444195653

 

Secrets of software debugging
Coding Standards

    * C Programming Guidelines
    * Code Complete: A Practical Handbook of Software Construction
    * More Effective C++: 35 New Ways to Improve Your Programs and Designs
    * The Elements of C Programming Style
    * The Elements of Programming Style
    * C Style: Standards and Guidelines
    * Guide to Good Programming Practice
    * Industrial Strength C++: Rules and Recommendations
    * Professional Software: Programming Practice
    * Program Style, Design, Efficiency, Debugging, and Testing
    * Programming Proverbs
    * Structured Programming
    * Taligent's Guide to Designing Programs

Refactoring: Improving the Design of Existing Code

    * Programming Pearls
    * Software Implementation
    * The Practice of Programming
    * Writing Solid Code: Microsoft's Techniques for Developing Bug-Free C Programs

 

C++
C++ Gotchas 	How Not to Program in C++ 	Debugging C++ 	Debugging Windows Programs 	Debugging Applications for Microsoft .NET 	Practical Debugging in C++
Prevention and Typical Errors

[Dewhurst2002] C++ Gotchas Avoiding Common Problems in Coding and Design

by Stephen C. Dewhurst (Author)

    * Paperback: 352 pages ; Dimensions (in inches): 0.67 x 9.34 x 7.34
    * Publisher: Addison-Wesley Pub Co; 1st edition (November 26, 2002)
    * ISBN: 0321125185
    * Average Customer Review: 3.7 out of 5 stars Based on 6 reviews.
    * Amazon.com Sales Rank: 133,001

    4 out of 5 stars Really not bad., April 14, 2003
     
      	Reviewer: A reader from Erlangen, Germany

    There are dozens books about C++ on the market and this one is clearly under the top ten. It's a wonderful book for beginners and programmers at an intermediate level. For the pros it's fun to read it, because: I made all this mistakes a few years ago. The perhaps only flaw ( I found in the whole book only one real mistake, or my compiler (gcc) is wrong , and I know it's not) of this book: it's too short. If you are making your first steps in C++, then buy this book.
     

    5 out of 5 stars A must read, February 18, 2003
     
      	Reviewer: alefinus (see more about me) from El Dorado Hills, CA United States

    This is a wonderful book. Not a usual list of trivial advices and recipes, but a collection of serious considerations on how to write code that will survive years of maintenance.

    I haven't come to this conclusion right away. At first, I was a bit irritated by what I had thought were the author's biases and self-confidence, but as I kept reading, I began appreciating and even enjoying his candid and confident style that communicated strong experience of dealing with the issues. Not since the time when the ARM ("The Annotated C++ Reference Manual" by Margaret A. Ellis and Bjarne Stroustrup) and Stroustrup's "The C++ Programming Language" were published years ago have I read a C++ book that impressed me as much! If Stroustrup's books focus on the description of C++ facilities, this book concentrates on its programming practice. The author's knowledge of the C++ standard and the compiler mechanics makes his arguments very compelling.

    Although anybody familiar with C++ will benefit from this book since it covers a wide range of C++ features, as well as programming and support issues, the book should appeal most of all to the mature audience: one has to be mature to understand the value in developing a program that will sustain years of maintenance by others rather than the one that will only run most of the time without crashing.

    4 out of 5 stars Ignore the reviewer from Sweden, January 31, 2003
     
      	Reviewer: A reader from Palo Alto, CA

    Having been in software development for many years, the last twelve using C++, I can say from experience that the author has assembled an accurate collection of problems I encounter over and over again. I have worked with legacy source code from Microsoft, Adobe Systems and other lesser known software companies that have some of the problems described in this book. These instances are not an indication of incompetence on the part of the original programmers, but rather a reflection of the realities of the business: deadlines need to be met and rarely do we have the time fiddle with code to make it into picture perfect C++. And if it works properly as it is, then don't fix something that is not broken.

    Beginning C++ programmers will get a lot out of this book. This is especially true if you are migrating from C and need to break a few bad habits. Experienced C++ developers will not get that much out of it, but the author has many interesting points that are worth checking out.

    The reviewer from Sweden is either an academic pinhead who has never participated in a large commercial software development effort that someone would actually want to pay money for, or he / she / it stopped reading the book after the first three or four sections.

    To sum this book up: If you DON'T need to ask yourself the questions the author addresses in this book, then you are not doing any serious C++ software development!

[Qualline2003 ] How Not to Program in C++ 111 Broken Programs and 3 Working Ones, or Why Does 2+2=5986
by Steve Oualline

    * Paperback: $17.47, 280 pages ; Dimensions (in inches): 0.80 x 9.18 x 7.08
    * Publisher: No Starch Press; (March 2003)
    * ISBN: 1886411956
    * Average Customer Review: 3.0 out of 5 stars Based on 3 reviews. Write a review.
       
    * Amazon.com Sales Rank: 328,276

 

    1 out of 5 stars Only for extreme novice C++ programmers, April 4, 2003
     
      	Reviewer: A reader from an undisclosed location

    The concept of this book is good, but the execution is seriously lacking.

    The "bugs" in Mr.Oualline's programs are the kinds of errors only the most unskilled novices would make: a missing space character in a format statement; accessing a 5-element array with index values of 1 thru 5; a class whose constructor allocates storage but whose destructor doesn't release the memory. Trivial, easy-to-spot errors that don't really expand anyone's grasp of C++.

    To add insult to injury, large portions of the book are filled with Mr.Oualline's tiresome war stories and aphorisms.

    A much better source of knowledge is "C++ Gotchas", any of Scott Meyers' books, or the "C++ FAQ".

    5 out of 5 stars Just Plain Fun!!!, March 31, 2003
     
      	Reviewer: Brad (see more about me) from Fishers, IN United States

    Okay, maybe I should say, just plain fun in a geeky kind of way. This book is relatively inexpensive, thus making it well worth the price. If you program in C++ (or even in C, C#, or Java), then you will most likely enjoy this book.

    Unlike most computer books, this is not a book you read in order to learn how to to something. Rather, this is a book you read (1) to see if you already know how to do something, (2) if you like solving puzzles, (3) if you want to learn about a number of typical 'gotchas'.

    This book presents listings (about 111+). Each seems to have something specifically wrong with it. You try to figure out the issue with a hint. You are can then get additional hints using a jump table. You are also given the answer as to what the gotcha is.

    The book also contains a large number of trivia type information. This is folklore, funny stories, and more.

    This is a book that I find myself picking up over and over to read just a little farther. It is fun. It is interesting. I'm even learning a thing or two. I've enjoyed it so much, I'll be writing a review on it for CodeGuru.com!

    Congratulations to Steve Oualline on putting together one of the few fun-to-read computers books.

[McKey2000]  Debugging Windows Programs Strategies, Tools, and Techniques for Visual C++ Programmers

by Everett N. McKay (Author)

    * Paperback: 592 pages ; Dimensions (in inches): 1.09 x 9.24 x 7.40
    * Publisher: Addison-Wesley Pub Co; 1st edition (January 15, 2000)
    * ISBN: 020170238X
    * Average Customer Review: 4.8 out of 5 stars Based on 10 reviews. Write a review.
       
    * Amazon.com Sales Rank: 54,188
       

5 out of 5 stars "must have" for general debugging, April 8, 2002
 
  	Reviewer: developer from England

In my experience, programmers fall into two categories: general (majority) and advanced (few); advanced ones understanding register and stack dumps etc, general ones being lost. This book covers the more general programmer, Robbins book the advanced. Comparing the two, you could write your own debugger and your own "core" dumps (which you can then examine) from Robbins book; with this one you can't, but it covers useful stuff missing from Robbins book (eg. PE format, address space partitioning). As such they have some overlap but supplement each other. Both books are essential to serious developers. I have one gripe with this and Robbins book: neither suggests outputting the mixed source/assembly/machine_code (.COD files); these are essential (without a .PDB) if a crash occurs so that the offending instruction etc. can be found, as many instructions usually follow a line of source; secondly, function locals only show in .CODs (as offsets from EBP) so making them easy to locate on a stack trace.

5 out of 5 stars No Mercy Debugging, July 26, 2001
 
  	Reviewer: dev1zero (see more about me) from Bellevue, WA United States

C++ bugs can be very difficult to find and can bring tears to the eyes of a programmer easily.(You know the bug is there but you just cant find it to save your life!)

After reading the first few chapters of this book, I knew it was a winner. This book shows ways to find bugs in different kinds of C++ programs MFC,COM etc.

The most important however is the chapter on memory bugs (a real pain)

If you need to hunt down bugs, get this book and your monitor is less likely to end up smashed from your frustrations.

This book also points the reader to a lot of other books which should make a better programmer of anyone who bothers to buy them.
 

5 out of 5 stars Hands down best book on Windows/VC++ debugging, September 7, 2001
 
  	Reviewer: dwstark (see more about me) from Santa Rosa, CA United States

If you write sofware for Windows using VC++, you cannot afford to not have this book. End of story. Everything that I'd scoured MSDN, MSJ, and news groups for the last 5 years to figure out about how Windows works from a user mode program mechanics point of view (PE format, DLL rebasing, symbols, etc) and debugging techniques is in this book (plus more stuff that I'd not yet found out about). It is well written and understandable. It works as a good overview of the topics and as a reference for dealing with a partiular problem, like post-mortem debugging, debugging memory or multi-threading problems, etc. Pick one up, you won't regret it.
 

[Robbins2003] Debugging Applications for Microsoft .NET and Microsoft Windows

by John Robbins
 
Price: 	  	$41.99

    * Hardcover: 832 pages ; Dimensions (in inches): 2.34 x 9.42 x 7.63
    * Publisher: Microsoft Press; Book and CD-ROM edition (March 12, 2003)
    * ISBN: 0735615365
    * Average Customer Review: 4.0 out of 5 stars Based on 3 reviews. Write a review.
       
    * Amazon.com Sales Rank: 22,763

    2 out of 5 stars Below the belt..., September 23, 2003
      	Reviewer: Paul Selormey (see more about me) from Toyohashi, Aichi Japan

    I bought this book to get a complete knowledge of the .NET framework debugging and got nothing. May be the .NET in the title applies to the fact that the author is using the VS.NET. If you have got the author's previous book on debugging then there is no need to waste money on this one.

    It discusses mainly C/C++ debugging in a typical MFC style (ASSERT/VERIFY etc).

    Here is the content at a glance:

    1. Bugs: Where they come From and How you Solve Them
    2. Getting Started Debugging
    3. Debugging During Coding

    4. Operating System Debugging Support and How Win32 Debuggers Work
    5. Advanced Debugger Usage with Visual Studio .NET
    6. Advanced .NET Debugging with Visual Studio .NET
    7. Advanced Native Code Techniques with Visual Studio .NET
    8. Advanced Native Code Techniques with WinDGB

    9. Extending the Visual Studio .NET IDE
    10. Managed Exception Monitoring
    11. Flow Tracing

    12. Finding Source and Line Information with Just a Crash Address
    13. Crash Handlers
    14. Debugging Windows Services and DLLs That Load into Services
    15. Multithreaded Deadlocks
    16. Automated Testing
    17. The Debug C Run-Time Library and Memory Management
    18. FastTrace: A High-Performance Tracing Tool for Server Applications
    19. Smoothing the Working Set

    Appendixes.

    As you can tell, there is hardly a .NET stuff to pay for, so for those of us owing the author's previous debugging book, this is just a second edition with .NET appended to confuse buyers!

 

[Ford&Teorey2002] Practical Debugging in C++
by Ann R. Ford (Author), Toby J. Teorey (Author)   

    * Paperback: $21.80, 112 pages ; Dimensions (in inches): 0.25 x 9.00 x 6.00
    * Publisher: Prentice Hall; 1st edition (January 15, 2002)
    * ISBN: 0130653942
    * Average Customer Review: 5.0 out of 5 stars Based on 1 review. Write a review.
       
    * Amazon.com Sales Rank: 378,445


 

[Pappas&Murray2000] Debugging C++: Troubleshooting for Programmers
by Chris H. Pappas, William H. Murray
Avg. Customer Rating: 3.7 out of 5 stars

    * Paperback: 523 pages ; Dimensions (in inches): 1.25 x 9.25 x 7.50
    * Publisher: McGraw-Hill Osborne Media; (April 21, 2000)
    * ASIN: 0072125195 | All Editions
    * Average Customer Review: 3.7 out of 5 stars Based on 10 reviews. Write a review.
       
    * Amazon.com Sales Rank: 351,186

2 out of 5 stars Decent for beginner Windows programmers, September 10, 2001
 
  	Reviewer: A reader from Vero Beach, FL United States

I was pretty excited when I first got this book, but was pretty disappointed after reading it.

First off, the title is misleading, focusing on Windows rather than C++. Since I am mainly a Windows programmer, though, this didn't phase me too much. However, the book often seemed to be a manual for the Visual C++ debugger rather than an insightful narrative on the debugging process. Although I realize examples have to be short and to the point, I was often insulted by the ridiculously simple errors the authors presented. The section on inline assembly debugging is almost useless. A much better approach would be examining the assembly language that the Visual C++ compile generates, rather than creating simple ASM programs with obvious mistakes.

I would have much rather seen a book about preventing bugs, and techniques that can be used to accomplish this goal. While this is certainly not that book, it would be useful for something just getting started with Visual C++, though anyone beyond a novice would probably be as disappointed as I was.
 

1 out of 5 stars Buy John Robbins 'Debugging Applications' instead., March 4, 2002
 
  	Reviewer: A reader from Hobart, TAS, Australia

Like I said, the above sums up my advice. I'd suggest only absolute beginners would write a good review for this book, because they don't know any better. One section alleges that a programmer who teaches themself C++ will get fired, because they would use the line

i = i + 1;

not realising they SHOULD use

i++;

This is funny on SO many levels.

1. Who would fire someone for this ?
2. Why can't people find this syntax for themselves ?
3. He crows about increased efficiency, but i++ creates a tempory, he wants ++i for this claim
4. He was talking specifically about people teaching themselves in migration from C, which, as you know, supports i++.

He goes on to list the STL containers, misses half of them and goes on to explain why STL containers are better than containers based on templates ( which is the bedrock of STL ).

His understanding is obviously lacking, but this does not stop him from writing about a topic if he thinks it will help sell his book.

John Robbins book, on the other hand, is indispensable. If you don't own it, you need to. It is everything this book could have been and more. John is the author of MSDN's 'Bugslayer' column, and he knows what he is talking about.
 

Debugging Visual C++ Windows

by Keith Bugg
Avg. Customer Rating: 2.7 out of 5 stars

Paperback
Used & new from $2.10
2 out of 5 stars A tutorial needs to tutor!!!, February 10, 1999
 
  	Reviewer: rgreen@visicom.com from Burlington, MA USA

The book could have been named: "Debugging Visual C++ for Dummies". It's contents in certain chapters are not detailed enough to actually teach you how to use to the various debugging tools to full potential. Chapters 4(The Visual C++ Debugger) and 5(Additional Debugging Tools) fit the above description. The author does provide some good suggestions to bolster your debugging process, but to be a true tutorial for the "intermediate" programmer, more code examples and actual use of the debugging features is required. Hopefully the next edition will go from an IDG "...Dummies" clone to a "Visual C++ Debugging Bible".

2 out of 5 stars Not very useful., January 25, 1999
 
  	Reviewer: A reader

While this book did offer a few pieces of good information, I was very disappointed overall. Even though the book calls itself "A Tutorial-Based Desktop Reference", very little, if any of the book was in the form of a tutorial.

The first part, which deals with Windows memory issues, did at least have some code samples, but no tutorials. Once he started talking about the Visual C++ debugger and other tools, he just gave brief descriptions without saying why or when you would want to use them.

The information in the book is about the same quantity and quality you can find in Visual C++ help. In fact, after reading one topic, I looked it up in the help and was surprised to find that it said almost exactly the same thing, word-for-word. The author added one or two sentences of his own that didn't give me any useful information.

I was looking forward to the section on third party tools, but I found that it was basically a listing of features with nothing to tell me whether the tools would be worth buying, much less instructions on how to actually use them.

There is some useful information, such as a description of how memory is managed in 32-bit Windows. But the same thing can be found in other books. And most of the rest of the book can probably be found in the Microsoft help files or on the outside of the third party tool packages. The best thing I can say about this book is that it puts all of this together.
 
0 out of 5 stars Debugging tips for intermediate-level Visual C++ developers., August 26, 1998
 
  	Reviewer: kbugg@qsystems.net from Oak Ridge, TN, USA

This book was written with the intermediate developer in mind. I discuss basic issues impacting the debugging phase of software development with Visual C++ ranging from design to testing. Topics include the ASSERT macros, the TRY-CATCH macros, using the debugger, stack probes and stack unwinding, etc. I also provide an overview of third party development tools that aid the debugging process

C++ and C Debugging, Testing, and Reliability: The Prevention, Detection, and Correction of Program Errors/Book and Disk
by David A. Spuler  

Out of Print--Limited Availability

Debugging Windows Programs: Strategies, Tools, and Techniques for Visual C++ Programmers
by Everett N. McKay (Author), et al (Paperback)
Avg. Customer Rating: 4.8 out of 5 stars
Usually ships in 24 hours
List Price:   $44.95 Buy new:   $35.84 Used & new from $16.90 6.

 Defensive Programming with C++: Program Planning, Diagnosis and Debugging: Set
by S.R. Ladd (Paperback)
 Out of stock

Defensive Programming in C++: Program Planning, Diagnosis, and Debugging
by Scott Robert Ladd  

Out of Print--Limited Availability 

Debugging COM+ Components written in Visual C++ [DOWNLOAD: PDF]
by Chris Schmidt (Author) (Digital)
Available for download now List Price:   $8.00 Buy new:   $8.00  

C++ Programmer's Companion: Designing, Testing, and Debugging
by Stephen Randy Davis (Paperback - December 1992)
Etc

Unix System V: Understanding Elf Object Files and Debugging Tools (Prentice Hall Open Systems Library)

Turbo C: The Art of Advanced Program Design, Optimization, and Debugging/Book & Disk

Copyright © 1996-2006 by Dr. Nikolai Bezroukov. www.softpanorama.org was created as a service to the UN Sustainable Development Networking Programme (SDNP) in the author free time. Submit comments

This document is an industrial compilation designed and created exclusively for educational use and is placed under the copyright of the Open Content License(OPL). Original materials copyright belong to respective owners. Quotes are made for educational purposes only in compliance with the fair use doctrine.

Standard disclaimer: The statements, views and opinions presented on this web page are those of the author and are not endorsed by, nor do they necessarily reflect, the opinions of the author present and former employers, SDNP or any other organization the author may be associated with. We do not warrant the correctness of the information provided or its fitness for any purpose.

Created May 16, 1997; Last modified: August 06, 2005


Your continued donations keep Wikipedia running!    
Debugging
From Wikipedia, the free encyclopedia
Jump to: navigation, search

Debugging is a methodical process of finding and reducing the number of bugs, or defects, in a computer program or a piece of electronic hardware thus making it behave as expected. Debugging tends to be harder when various subsystems are tightly coupled, as changes in one may cause bugs to emerge in another.


Contents
[hide]

    * 1 Origin
    * 2 Tools
    * 3 Basic steps
          o 3.1 Recognize a bug exists
          o 3.2 Isolate source of bug
          o 3.3 Identify cause of bug
          o 3.4 Determine fix for bug
          o 3.5 Fix and test
    * 4 Steps to reduce debugging
          o 4.1 The correct mindset
          o 4.2 Start at the source
          o 4.3 Treat user input with suspicion
          o 4.4 Use of log files
          o 4.5 Test suites
          o 4.6 Change one thing at a time
          o 4.7 Back out changes that have no effect
          o 4.8 Think of similar situations
    * 5 See also
    * 6 References
    * 7 External links

[edit] Origin

There is some controversy over who first used the term "debug" (see the Computer bug article for a full discussion). Some claim that the term "debugging" was first used by Glenford J Myers in his 1976 book Software Reliability: Principles and Practices where he defined it as "diagnosing the precise nature of a known error and then correcting the error", while others claim it was associated with Admiral Grace Hopper in the 1940s.

The story goes that when one of the early computers that Hopper was working with malfunctioned, it was discovered that a moth had gotten into a relay, causing it to fail. Some believe that the staff then started using the term debugging to describe the process of removing errors from computer programs.

Grace Hopper herself said that the term 'bug' was already in use, and this was why it was so amusing to find an actual one.[citation needed]

[edit] Tools

Debugging is, in general, a cumbersome and tiring task. The debugging skill of the programmer is probably the biggest factor in the ability to debug a problem, but the difficulty of software debugging varies greatly with the programming language used and the available tools, such as debuggers. Debuggers are software tools which enable the programmer to monitor the execution of a program, stop it, re-start it, run it in slow motion, change values in memory and even, in some cases, go back in time. The term debugger can also refer to the person who is doing the debugging.

Generally, high-level programming languages, such as Java, make debugging easier, because they have features such as exception handling that make real sources of erratic behaviour easier to spot. In lower-level programming languages such as C or assembly, bugs may cause silent problems such as memory corruption, and it is often difficult to see where the initial problem happened; in those cases, sophisticated debugging tools may be needed.

In certain situations, general purpose software tools that are language specific in nature can be very useful. These take the form of static code analysis tools. These tools look for a very specific set of known problems, some common and some rare, within the source code. All such issues detected by these tools would rarely be picked up by a compiler or interpreter, thus they are not syntax checkers, but more semantic checkers. Some tools claim to be able to detect 300+ unique problems. Both commercial and free tools exist in various languages. These tools can be extremely useful when checking very large source trees, where it is impractical to do code walkthroughs. A typical example of a problem detected would be a variable dereference that occurs before the variable is assigned a value. Another example would be to perform strong type checking when the language does not require such. Thus, they are better at locating likely errors, versus actual errors. As a result, these tools have a reputation of false positives. The old Unix lint program is an early example.

For debugging electronic hardware (e.g., computer hardware) as well as low-level software (eg. BIOSes, device drivers) and firmware, instruments such as oscilloscopes, logic analyzers or in-circuit emulators (ICEs) are often used, alone or in combination. An ICE may perform many of the typical software debugger's tasks on low-level software and firmware.

[edit] Basic steps

Although each debugging experience is unique, certain general principles can be applied in debugging. This section particularly addresses debugging software, although many of these principles can also be applied to debugging hardware.

The basic steps in debugging are:

    * Recognize that a bug exists
    * Isolate the source of the bug
    * Identify the cause of the bug
    * Determine a fix for the bug
    * Apply the fix and test it

[edit] Recognize a bug exists

Detection of bugs can be done proactively or passively.

An experienced programmer often knows where errors are more likely to occur, based on the complexity of sections of the program as well as possible data corruption. For example, any data obtained from a user should be treated suspiciously. Great care should be taken to verify that the format and content of the data are correct. Data obtained from transmissions should be checked to make sure the entire message (data) was received. Complex data that must be parsed and/or processed may contain unexpected combinations of values that were not anticipated, and not handled correctly. By inserting checks for likely error symptoms, the program can detect when data has been corrupted or not handled correctly.

If an error is severe enough to cause the program to terminate abnormally, the existence of a bug becomes obvious. If the program detects a less serious problem, the bug can be recognized, provided error and/or log messages are monitored. However, if the error is minor and only causes the wrong results, it becomes much more difficult to detect that a bug exists; this is especially true if it is difficult or impossible to verify the results of the program.

The goal of this step is to identify the symptoms of the bug. Observing the symptoms of the problem, under what conditions the problem is detected, and what work-arounds, if any, have been found, will greatly help the remaining steps to debugging the problem.

[edit] Isolate source of bug

This step is often the most difficult (and therefore rewarding) step in debugging. The idea is to identify what portion of the system is causing the error. Unfortunately, the source of the problem isn't always the same as the source of the symptoms. For example, if an input record is corrupted, an error may not occur until the program is processing a different record, or performing some action based on the erroneous information, which could happen long after the record was read.

This step often involves iterative testing. The programmer might first verify that the input is correct, next if it was read correctly, processed correctly, etc. For modular systems, this step can be a little easier by checking the validity of data passed across interfaces between different modules. If the input was correct, but the output was not, then the source of the error is within the module. By iteratively testing inputs and outputs, the debugger can identify within a few lines of code where the error is occurring.

Skilled debuggers are often able to hypothesize where the problem might be (based on analogies to previous similar situations), and test the inputs and outputs of the suspected areas of the program. This form of debugging is an instance of the scientific method. Less skilled debuggers often step sequentially through the program, looking for a place where the behavior of the program is different from that expected. Note that this is still a form of scientific method as the programmer must decide what variables to examine when looking for unusual behavior. Another approach is to use a "binary search" type of isolation process. By testing sections near the middle of the data / processing flow, the programmer can determine if the error happens during earlier or later sections of the program. If no data problems are detected, then the error is probably later in the process.

[edit] Identify cause of bug

Having found the location of the bug, the next step is to determine the actual cause of the bug, which might involve other sections of the program. For example, if it has been determined that the program faults because a field is wrong, the next step is to identify why the field is wrong. This is the actual source of the bug, although some would argue that the inability of a program to handle bad data can be considered a bug as well.

A good understanding of the system is vital to successfully identifying the source of the bug. A trained debugger can isolate where a problem originates, but only someone familiar with the system can accurately identify the actual cause behind the error. In some cases it might be external to the system: the input data was incorrect. In other cases it might be due to a logic error, where correct data was handled incorrectly. Other possibilities include unexpected values, where the initial assumptions were that a given field can have only "n" values, when in fact, it can have more, as well as unexpected combinations of values in different fields (field x was only supposed to have that value when field y was something different). Another possibility is incorrect reference data, such as a lookup table containing incorrect values relative to the record that was corrupted.

Having determined the cause of the bug, it is a good idea to examine similar sections of the code to see if the same mistake is repeated elsewhere. If the error was clearly a typo, this is less likely, but if the original programmer misunderstood the initial design and/or requirements, the same or similar mistakes could have been made elsewhere.

[edit] Determine fix for bug

Having identified the source of the problem, the next task is to determine how the problem can be fixed. An intimate knowledge of the existing system is essential for all but the simplest of problems. This is because the fix will modify the existing behavior of the system, which may produce unexpected results. Furthermore, fixing an existing bug can often either create additional bugs, or expose other bugs that were already present in the program, but never exposed because of the original bug. These problems are often caused by the program executing a previously untested branch of code, or under previously untested conditions.

In some cases, a fix is simple and obvious. This is especially true for logic errors where the original design was implemented incorrectly. On the other hand, if the problem uncovers a major design flaw that permeates a large portion of the system, then the fix might range from difficult to impossible, requiring a total rewrite of the application.

In some cases, it might be desirable to implement a "quick fix", followed by a more permanent fix. This decision is often made by considering the severity, visibility, frequency, and side effects of the problem, as well as the nature of the fix, and product schedules (e.g., are there more pressing problems?).

[edit] Fix and test

After the fix has been applied, it is important to test the system and determine that the fix handles the former problem correctly. Testing should be done for two purposes: (1) does the fix now handle the original problem correctly, and (2) make sure the fix hasn't created any undesirable side effects.

For large systems, it is a good idea to have regression tests, a series of test runs that exercise the system. After significant changes and/or bug fixes, these tests can be repeated at any time to verify that the system still executes as expected. As new features are added, additional tests can be included in the test suite.

[edit] Steps to reduce debugging

There are concrete steps that can be taken to reduce the amount of time spent debugging software. These are listed in the sections below.

[edit] The correct mindset

Probably the most important thing you can do when you are starting to debug a program is to realize that you don't understand what is going on. Programmers who are convinced that their program should work fine are less likely to find errors simply because they are refusing to admit their confusion. If the program behaved the way you think it does, you wouldn't be debugging; the program would be working fine. Even when the program appears to work, if you examine it with the thought that there is at least one bug remaining and you are going to find it, then you are more likely to find something wrong with the program

[edit] Start at the source

The time when you are most aware of where problems are more likely to arise is usually when first designing and writing the code. By inserting integrity checks at various places within the program, problems can be detected and reported by the program itself. In addition to detecting problems, considerations should be given as to how best to handle each error. Options include:

    * Report error, set invalid fields to a default value, and continue
    * Report error, discard the record associated with the invalid value, and continue
    * Report error, transfer invalid record into separate file/table so the user can examine and possibly correct the problem
    * Report error and terminate the program

See: assertion (computing)

[edit] Treat user input with suspicion

Any data that originated from users (including external systems) should be treated with suspicion. Carefully validate all such input data, performing syntactical and semantical integrity checks. Such invalid data are a common source of programming errors. Think not just of data entered in error, but malicious data as well, as in buffer overflow exploits.

If data are entered interactively by users, you can provide appropriate error messages and allow the user to correct the invalid field(s). If data are not from an interactive source, then the erroneous records should be handled as described above.

[edit] Use of log files

Programs that write information to log files can provide significant information that can be used to analyze what was going on before, during, and after problems are encountered. The number of entries to be searched can be reduced by creating various log files, such as a separate log for each major component of the system, plus one log file strictly for errors. Each entry should be date/time stamped so that entries from different logs can be correlated.

[edit] Test suites

A standard set of tests that can be run to perform tests can assist in finding errors before they make it into production. These test cases should be automated as much as possible to reduce the amount of effort required to perform these tests. As new features are added to the system, additional tests should be created to exercise those features.

[edit] Change one thing at a time

When making a lot of changes, apply them incrementally. Add one change, and then test that change thoroughly before starting on the next change. This will reduce the number of possible sources of new bugs. If several different changes are applied at the same time, then it is much more difficult to identify the source of the problem. Furthermore, minor errors in different areas can interact to produce errors that never would have happened if those changes had been applied one at a time.

[edit] Back out changes that have no effect

If you make a change to fix a problem, but the program still behaves the same, back out those changes before proceeding. The fact that your changes didn't do anything indicates one of several things:

    * The problem is not where you think it is
    * The area you modified either isn't being called, or isn't being called the way you think it is
    * Assuming the section you changed wasn't executed, you might have introduced new bugs that won't appear until you fix the current bug

[edit] Think of similar situations

When a bug has been found, think of other places where the same mistake might have been made. Check those places and see if the same problem exists there as well.

[edit] See also

    * Crash (computing)
    * Debugger
    * Error-correction
    * Breakpoint
    * Memory debugger
    * Magic number (programming) (section "Magic debug values")
    * Computer programming
    * Software testing
    * Framepointer
    * Delta Debugging

[edit] References

    * David J. Agans: Debugging: The Nine Indispensable Rules for Finding Even the Most Elusive Software and Hardware Problems, AMACOM, ISBN 0-8144-7168-4
    * Matthew A. Telles, Yuan Hsieh, Matt Telles: The Science of Debugging, The Coriolis Group, ISBN 1-57610-917-8
    * Robert Metzger: Debugging by Thinking : A Multidisciplinary Approach, Digital Press, ISBN 1-55558-307-5
    * John Robbins: Debugging Applications, Microsoft Press, ISBN 0-7356-0886-5
    * Ann R. Ford, Toby J. Teorey: Practical Debugging in C++, Prentice Hall, ISBN 0-13-065394-2
    * Bill Blunden: Software Exorcism: A Handbook for Debugging and Optimizing Legacy Code, APress, ISBN 1-59059-234-4
    * Frederick Phillips Brooks: The Mythical Man-Month: Essays on Software Engineering, Pearson Addison Wesley, ISBN 0-201-00650-2
    * Glenford J Myers: Software Reliability: Principles and Practices, John Wiley & Sons inc, ISBN 0-471-62765-8
    * Glenford J Myers: *The Art of Software Testing, John Wiley & Sons inc, ISBN 0-471-04328-1
    * Andreas Zeller: Why Programs Fail: A Guide to Systematic Debugging, Morgan Kaufmann, ISBN 1-55860-866-4

[edit] External links

    * Algorithmic and Automatic Debugging - extensive collection of links to debugging tools and methods
    * Debugging Backwards in Time - Omniscient Debugging
    * Citations from CiteSeer
    * Learn the essentials of debugging A nice article exposing a debugging methodology.
    * Debugging Software Crashes in C
    * Debugging Software Crashes in C++

Retrieved from "http://en.wikipedia.org/wiki/Debugging"

Categories: Articles with unsourced statements | Debugging
Views

    * Article
    * Discussion
    * Edit this page
    * History

Personal tools

    * Sign in / create account

Navigation

    * Main Page
    * Community Portal
    * Featured content
    * Current events
    * Recent changes
    * Random article
    * Help
    * Contact Wikipedia
    * Donations

Search
 
Toolbox

    * What links here
    * Related changes
    * Upload file
    * Special pages
    * Printable version
    * Permanent link
    * Cite this article

In other languages

    * ?????????
    * Deutsch
    * Español
    * ???
    * Italiano
    * ?????
    * Polski
    * Português
    * ???????
    * Suomi

MediaWiki
Wikimedia Foundation

    * This page was last modified 19:04, 28 November 2006.
    * All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)
      Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.
    * Privacy policy
    * About Wikipedia
    * Disclaimers

GNU Binutils

The GNU Binutils are a collection of binary tools. The main ones are:

    * ld - the GNU linker.
    * as - the GNU assembler.

But they also include:

    * addr2line - Converts addresses into filenames and line numbers.
    * ar - A utility for creating, modifying and extracting from archives.
    * c++filt - Filter to demangle encoded C++ symbols.
    * gprof - Displays profiling information.
    * nlmconv - Converts object code into an NLM.
    * nm - Lists symbols from object files.
    * objcopy - Copys and translates object files.
    * objdump - Displays information from object files.
    * ranlib - Generates an index to the contents of an archive.
    * readelf - Displays information from any ELF format object file.
    * size - Lists the section sizes of an object or archive file.
    * strings - Lists printable strings from files.
    * strip - Discards symbols.
    * windres - A compiler for Windows resource files.

Most of these programs use BFD, the Binary File Descriptor library, to do low-level manipulation. Many of them also use the opcodes library to assemble and disassemble machine instructions.

The binutils have been ported to most major Unix variants as well as Wintel systems, and their main reason for existence is to give the GNU system (and GNU/Linux) the facility to compile and link programs.
Obtaining binutils

The latest release of GNU binutils is 2.17. The various NEWS files (binutils, gas, and ld) have details of what has changed in this release.

See the SOFTWARE page for information on obtaining releases of GNU binutils and other GNU software. The current release can be downloaded from http://ftp.gnu.org/gnu/binutils

If you plan to do active work on GNU binutils, you can access the development source tree by anonymous CVS:

  cvs -z 9 -d :pserver:anoncvs@sourceware.org:/cvs/src login
  {enter "anoncvs" as the password}
  cvs -z 9 -d :pserver:anoncvs@sourceware.org:/cvs/src co binutils
  

Alternatively, you can use the cvsweb interface, or the source snapshots, available as bzipped tar files via anonymous FTP from ftp://sourceware.org/pub/binutils/snapshots.
Bug reports

There is a bug-tracking system at http://sourceware.org/bugzilla/.
Mailing lists

There are three binutils mailing lists:

bug-binutils@gnu.org (archives)
    For reporting bugs.
binutils@sourceware.org (archives)
    For discussing binutils issues.
binutils-cvs (archives)
    A read-only mailing list containing the notes from checkins to the binutils CVS repository.

You can use this form to subscribe to the binutils@sourceware.org or binutils-cvs@sourceware.org mailing lists:

    Mailing list: Your e-mail address:
    Digest version?

To subscribe to the bug-binutils@gnu.org mailing list, see the bug-binutils info page.

You may wish to browse the old mail archives of the gas2 and bfd mailing lists. These were the discussion lists for binutils until May 1999. Please do not send mail to them any longer.
Documentation

The documentation for binutils 2.17 is available.

Return to GNU's home page.

Please send FSF & GNU inquiries & questions to gnu@gnu.org. There are also other ways to contact the FSF.

Please send comments on these web pages to binutils@sourceware.org, send other questions to gnu@gnu.org.

Copyright (C) 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA

Verbatim copying and distribution of this entire article is permitted in any medium, provided this notice is preserved.

Updated: Last modified: Fri Jun 23 16:46:41 EDT 2006

Debugging rules! Find out what's wrong with anything, fast
download the free poster! 	Download the cool debugging rules poster
Read the book 	Read Debugging -- the book by Dave Agans
Links to other debugging resources 	Debugging resources -- other sites that help
Insights from your fellow debuggers 	Ideas from your fellow debuggers
Send in your stories 	Send in your war stories
Debug this site (feedback to the webmaster) 	Debug this site -- feedback to the webmaster

	
This site contains resources to help you debug stuff -- mostly software and electronic hardware, but other stuff, too.

We'll publish and link to advice and stories about any kind of debugging or troubleshooting, including cars, furnaces, plumbing, and even human bodies.

(Disclaimer:  We are not doctors, and don't even play them on TV.  Consult your physician about any health problems.  If your physician is clueless, send him or her to this site.)



© 2002 by David J. Agans
All content on this site is copyrighted.
You have permission to download, print, and otherwise distribute the Debugging Rules poster, providing you use it in its entirety with no modifications whatsoever.



Ben Liblit

goofy self-portrait

Assistant Professor
Computer Sciences Department
University of WisconsinMadison
1210 West Dayton Street
Madison, WI 53706-1685
USA
office:  	6357 Computer Science Building
work:  	+1 (608) 262-6617
fax:  	+1 (608) 262-9777

For Fall 2006 I am teaching CS706: Analysis of Software Artifacts.

Office hours are Thursdays 3:30pm - 4:30pm or by appointment. My door is usually open and unscheduled drop-in visitors are welcome as well. I am in room 6357 of the Computer Science building. Come on by and say hello!

I am an assistant professor of computer science, specializing in software engineering and programming languages. My work in this area began with a pioneering four year field study on the practice of programming. (That is, I was an actual grownup with a real job as a software engineer.) Today it is the challenges and needs of the professional programmer that inspire my research.

My research team:
Current Students 	Former Students

    * Piramanayagam Arumuga Nainar
    * Cindy Rubio Gonzalez
    * Anne Mulhern (advised by Charles Fischer)

	

    * Marina Polishchuk, now at Microsoft
    * Garrett Kolpin, now at Thomson West

Bug Isolation in an Imperfect World

Cooperative Bug Isolation Project

How many times have you crashed your computer this month? My current focus is on improving software quality in a world where bugs are a fact of life. I seek practical ways to use program analysis and other techniques to understand and fix bugs in the real world.

    * Dynamic Heap Type Inference for Program Understanding and Debugging, POPL 2007
    * Statistical Debugging: Simultaneous Identification of Multiple Bugs, ICML 2006
    * Path Optimization in Programs and its Application to Debugging, ESOP 2006
    * BTrace: Path optimization for Debugging, technical report 2005
    * Scalable Statistical Bug Isolation, PLDI 2005
    * The Open Source Proving Grounds, Bugs 2005
    * Cooperative Bug Isolation, doctoral dissertation, 2005 ACM Doctoral Dissertation Award
    * Public Deployment of Cooperative Bug Isolation, RAMSS 2004
    * Bug Isolation via Remote Program Sampling, PLDI 2003
    * Statistical Debugging of Sampled Programs, NIPS 2003
    * Sampling User Executions for Bug Isolation, RAMSS 2003
    * Building a Better Backtrace: Techniques for Postmortem Program Analysis, technical report 2002

The Cooperative Bug Isolation Project is putting many of the above ideas to work in a large scale, real world deployment. When theory collides with practice, fun things happen.
Languages for Scientific Computing

Scientific Computing

Your supercomputer is only as good as the code youre running on it. As a member of the Titanium project I developed a formal basis for understanding the behavior of distributed data with applications in language design, algorithm development, programming, and optimization.

    * Titanium Language Reference Manual, technical report 2005
    * Type Systems for Distributed Data Sharing, SAS 2003
    * Data Sharing Analysis for Titanium, technical report 2001
    * Type Systems for Distributed Data Structures, POPL 2000; masters thesis
    * Titanium: A High-Performance Java Dialect, Workshop on Java for High-Performance Network Computing 1998; CPE 1998; PPSC 1999

Odds and Ends

Odds and Ends

Ive also written a thing or two about other facets of programming and program analysis.

    * An Operational Semantics for LogTM, technical report 2006
    * Extracting Output Formats from Executables, WCRE 2006
    * Supporting Nested Transactional Memory in LogTM, ASPLOS XII / ASPLOS 2006
    * Cognitive Perspectives on the Role of Naming in Computer Programs, PPIG 2006
    * Tool Support for Proof Engineering, UITP 2006
    * Estimating the Impact of Scalable Pointer Analysis on Optimization, SAS 2001
    * Transformation of Prolog Programs to Perform Update in Place: A Prototype Code Synthesizer, undergraduate honors thesis

Ive also written a thing or two about other facets of programming and program analysis.

    * An Operational Semantics for LogTM, technical report 2006
    * Extracting Output Formats from Executables, WCRE 2006
    * Supporting Nested Transactional Memory in LogTM, ASPLOS XII / ASPLOS 2006
    * Cognitive Perspectives on the Role of Naming in Computer Programs, PPIG 2006
    * Tool Support for Proof Engineering, UITP 2006
    * Estimating the Impact of Scalable Pointer Analysis on Optimization, SAS 2001
    * Transformation of Prolog Programs to Perform Update in Place: A Prototype Code Synthesizer, undergraduate honors thesis

Ive also written a thing or two about other facets of programming and program analysis.

    * An Operational Semantics for LogTM, technical report 2006
    * Extracting Output Formats from Executables, WCRE 2006
    * Supporting Nested Transactional Memory in LogTM, ASPLOS XII / ASPLOS 2006
    * Cognitive Perspectives on the Role of Naming in Computer Programs, PPIG 2006
    * Tool Support for Proof Engineering, UITP 2006
    * Estimating the Impact of Scalable Pointer Analysis on Optimization, SAS 2001
    * Transformation of Prolog Programs to Perform Update in Place: A Prototype Code Synthesizer, undergraduate honors thesis
Ive also written a thing or two about other facets of programming and program analysis.

    * An Operational Semantics for LogTM, technical report 2006
    * Extracting Output Formats from Executables, WCRE 2006
    * Supporting Nested Transactional Memory in LogTM, ASPLOS XII / ASPLOS 2006
    * Cognitive Perspectives on the Role of Naming in Computer Programs, PPIG 2006
    * Tool Support for Proof Engineering, UITP 2006
    * Estimating the Impact of Scalable Pointer Analysis on Optimization, SAS 2001
    * Transformation of Prolog Programs to Perform Update in Place: A Prototype Code Synthesizer, undergraduate honors thesis

Ive also written a thing or two about other facets of programming and program analysis.

    * An Operational Semantics for LogTM, technical report 2006
    * Extracting Output Formats from Executables, WCRE 2006
    * Supporting Nested Transactional Memory in LogTM, ASPLOS XII / ASPLOS 2006
    * Cognitive Perspectives on the Role of Naming in Computer Programs, PPIG 2006
    * Tool Support for Proof Engineering, UITP 2006
    * Estimating the Impact of Scalable Pointer Analysis on Optimization, SAS 2001
    * Transformation of Prolog Programs to Perform Update in Place: A Prototype Code Synthesizer, undergraduate honors thesis

