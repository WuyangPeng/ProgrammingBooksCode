#include <RoboCatPCH.h>

//zoom hardcoded at 100...if we want to lock players on screen, this could be calculated from zoom
// 硬编码为100缩放...如果我们想在屏幕上锁定播放器，可以通过缩放来计算
const float HALF_WORLD_HEIGHT = 3.6f;
const float HALF_WORLD_WIDTH = 6.4f;

RoboCat::RoboCat()
    : GameObject(),
      mMaxRotationSpeed(5.f),
      mMaxLinearSpeed(50.f),
      mVelocity(Vector3::Zero),
      mWallRestitution(0.1f),
      mCatRestitution(0.1f),
      mThrustDir(0.f),
      mPlayerId(0),
      mIsShooting(false),
      mHealth(10)
{
    SetCollisionRadius(0.5f);
}

void RoboCat::ProcessInput(float inDeltaTime, const InputState& inInputState)
{
    //process our input....

    //turning...
    float newRotation = GetRotation() + inInputState.GetDesiredHorizontalDelta() * mMaxRotationSpeed * inDeltaTime;
    SetRotation(newRotation);

    //moving...
    float inputForwardDelta = inInputState.GetDesiredVerticalDelta();
    mThrustDir = inputForwardDelta;

    mIsShooting = inInputState.IsShooting();
}

void RoboCat::AdjustVelocityByThrust(float inDeltaTime)
{
    //just set the velocity based on the thrust direction -- no thrust will lead to 0 velocity
    //simulating acceleration makes the client prediction a bit more complex
    // 只需根据推力方向设置速度――没有推力将导致速度模拟加速度为0，使客户预测更加复杂
    Vector3 forwardVector = GetForwardVector();
    mVelocity = forwardVector * (mThrustDir * inDeltaTime * mMaxLinearSpeed);
}

void RoboCat::SimulateMovement(float inDeltaTime)
{
    //simulate us...
    // 模拟我们...
    AdjustVelocityByThrust(inDeltaTime);

    SetLocation(GetLocation() + mVelocity * inDeltaTime);

    ProcessCollisions();
}

void RoboCat::Update()
{
}

void RoboCat::ProcessCollisions()
{
    //right now just bounce off the sides..
    // 现在只是从侧面反弹。
    ProcessCollisionsWithScreenWalls();

    float sourceRadius = GetCollisionRadius();
    Vector3 sourceLocation = GetLocation();

    //now let's iterate through the world and see what we hit...
    //note: since there's a small number of objects in our game, this is fine.
    //but in a real game, brute-force checking collisions against every other object is not efficient.
    //it would be preferable to use a quad tree or some other structure to minimize the
    //number of collisions that need to be tested.
    // 现在让我们遍历世界，看看我们击中了什么...
    // 注意：由于我们的游戏中对象数量很少，所以很好。
    // 但是在实际游戏中，暴力检查与其他对象的碰撞效率不高。
    // 最好使用四叉树或其他方法结构以最小化需要测试的碰撞次数。
    for (auto goIt = World::sInstance->GetGameObjects().begin(), end = World::sInstance->GetGameObjects().end(); goIt != end; ++goIt)
    {
        GameObject* target = goIt->get();
        if (target != this && !target->DoesWantToDie())
        {
            //simple collision test for spheres- are the radii summed less than the distance?
            // 球的简单碰撞测试――半径的总和是否小于距离？
            Vector3 targetLocation = target->GetLocation();
            float targetRadius = target->GetCollisionRadius();

            Vector3 delta = targetLocation - sourceLocation;
            float distSq = delta.LengthSq2D();
            float collisionDist = (sourceRadius + targetRadius);
            if (distSq < (collisionDist * collisionDist))
            {
                //first, tell the other guy there was a collision with a cat, so it can do something...
                // 首先，告诉另一个人与猫发生了碰撞，所以它可以做些什么...

                if (target->HandleCollisionWithCat(this))
                {
                    //okay, you hit something!
                    //so, project your location far enough that you're not colliding
                    // 好吧，你打东西了！
                    // 因此，将您的位置投影到足够远，以免碰撞
                    Vector3 dirToTarget = delta;
                    dirToTarget.Normalize2D();
                    Vector3 acceptableDeltaFromSourceToTarget = dirToTarget * collisionDist;
                    //important note- we only move this cat. the other cat can take care of moving itself
                    // 重要说明――我们只移动这只猫。 另一只猫可以照顾自己
                    SetLocation(targetLocation - acceptableDeltaFromSourceToTarget);

                    Vector3 relVel = mVelocity;

                    //if other object is a cat, it might have velocity, so there might be relative velocity...
                    // 如果其他物体是猫，则它可能具有速度，因此可能存在相对速度...
                    RoboCat* targetCat = target->GetAsCat();
                    if (targetCat)
                    {
                        relVel -= targetCat->mVelocity;
                    }

                    //got vel with dir between objects to figure out if they're moving towards each other
                    //and if so, the magnitude of the impulse ( since they're both just balls )
                    // 弄清楚对象之间的距离，以查明它们是否朝彼此移动，如果有，则确定脉冲的大小（因为它们都是球）
                    float relVelDotDir = Dot2D(relVel, dirToTarget);

                    if (relVelDotDir > 0.f)
                    {
                        Vector3 impulse = relVelDotDir * dirToTarget;

                        if (targetCat)
                        {
                            mVelocity -= impulse;
                            mVelocity *= mCatRestitution;
                        }
                        else
                        {
                            mVelocity -= impulse * 2.f;
                            mVelocity *= mWallRestitution;
                        }
                    }
                }
            }
        }
    }
}

void RoboCat::ProcessCollisionsWithScreenWalls()
{
    Vector3 location = GetLocation();
    float x = location.mX;
    float y = location.mY;

    float vx = mVelocity.mX;
    float vy = mVelocity.mY;

    float radius = GetCollisionRadius();

    //if the cat collides against a wall, the quick solution is to push it off
    // 如果猫撞到墙壁，快速的解决方法是将其推下
    if ((y + radius) >= HALF_WORLD_HEIGHT && vy > 0)
    {
        mVelocity.mY = -vy * mWallRestitution;
        location.mY = HALF_WORLD_HEIGHT - radius;
        SetLocation(location);
    }
    else if (y <= (-HALF_WORLD_HEIGHT - radius) && vy < 0)
    {
        mVelocity.mY = -vy * mWallRestitution;
        location.mY = -HALF_WORLD_HEIGHT - radius;
        SetLocation(location);
    }

    if ((x + radius) >= HALF_WORLD_WIDTH && vx > 0)
    {
        mVelocity.mX = -vx * mWallRestitution;
        location.mX = HALF_WORLD_WIDTH - radius;
        SetLocation(location);
    }
    else if (x <= (-HALF_WORLD_WIDTH - radius) && vx < 0)
    {
        mVelocity.mX = -vx * mWallRestitution;
        location.mX = -HALF_WORLD_WIDTH - radius;
        SetLocation(location);
    }
}

uint32_t RoboCat::Write(OutputMemoryBitStream& inOutputStream, uint32_t inDirtyState) const
{
    uint32_t writtenState = 0;

    if (inDirtyState & ECRS_PlayerId)
    {
        inOutputStream.Write((bool)true);
        inOutputStream.Write(GetPlayerId());

        writtenState |= ECRS_PlayerId;
    }
    else
    {
        inOutputStream.Write((bool)false);
    }

    if (inDirtyState & ECRS_Pose)
    {
        inOutputStream.Write((bool)true);

        Vector3 velocity = mVelocity;
        inOutputStream.Write(velocity.mX);
        inOutputStream.Write(velocity.mY);

        Vector3 location = GetLocation();
        inOutputStream.Write(location.mX);
        inOutputStream.Write(location.mY);

        inOutputStream.Write(GetRotation());

        writtenState |= ECRS_Pose;
    }
    else
    {
        inOutputStream.Write((bool)false);
    }

    //always write mThrustDir- it's just two bits
    if (mThrustDir != 0.f)
    {
        inOutputStream.Write(true);
        inOutputStream.Write(mThrustDir > 0.f);
    }
    else
    {
        inOutputStream.Write(false);
    }

    if (inDirtyState & ECRS_Color)
    {
        inOutputStream.Write((bool)true);
        inOutputStream.Write(GetColor());

        writtenState |= ECRS_Color;
    }
    else
    {
        inOutputStream.Write((bool)false);
    }

    if (inDirtyState & ECRS_Health)
    {
        inOutputStream.Write((bool)true);
        inOutputStream.Write(mHealth, 4);

        writtenState |= ECRS_Health;
    }
    else
    {
        inOutputStream.Write((bool)false);
    }

    return writtenState;
}
